---
section_id: 8.1
title: 日常信息获取
status: draft
target_words: 1500
word_count: 1520
---

# 日常信息获取

在信息爆炸的时代，我们每天都需要从各种渠道获取新闻、天气、股票、科技动态等信息。传统方式需要我们主动打开多个应用或网站，逐一查看，既耗时又容易遗漏重要内容。OpenClaw 的 Agent 系统可以帮助我们构建一个智能信息助手，自动收集、筛选、汇总我们关心的信息，并以最适合的方式呈现。

## 场景介绍

想象一下这样的早晨：你刚起床，手机已经收到了一份精心整理的信息简报——今天的天气和穿衣建议、你关注的股票涨跌情况、昨夜发生的重大新闻、你追踪的科技博客更新。所有这些信息都经过 AI 的智能筛选，去除了无关内容，只留下你真正关心的部分。

这就是日常信息自动化的魅力。通过 OpenClaw，我们可以：

- **定时抓取**：按设定的时间间隔自动从多个来源获取信息
- **智能筛选**：根据你的兴趣和偏好过滤内容
- **个性化汇总**：将多源信息整合成一份易读的简报
- **多渠道推送**：通过邮件、即时通讯、语音等方式送达

## 实现思路

构建一个智能信息助手需要以下几个核心组件：

1. **信息源连接器**：使用 MCP 或 Skill 连接各类信息源（RSS、API、网页等）
2. **内容处理器**：对获取的内容进行清洗、分类、摘要
3. **个性化引擎**：根据用户偏好对内容进行排序和筛选
4. **推送服务**：将处理后的内容发送到指定渠道

我们可以使用 Lobster 工作流将这些组件串联起来，形成一个完整的信息处理流水线。

## 配置步骤

### 第一步：创建信息源 Skill

首先，我们需要创建一个 Skill 来定义信息获取的方式。以下是一个获取多源信息的 Skill 配置：

```yaml
# ~/.openclaw/skills/daily-briefing/SKILL.md
---
name: daily-briefing
description: 每日信息简报生成工具
commands:
  - name: fetch-weather
    description: 获取天气信息
    script: |
      curl -s "https://api.weather.com/v1/current?city={{city}}" | \
      jq '{temp: .temperature, condition: .condition, humidity: .humidity}'

  - name: fetch-news
    description: 获取新闻头条
    script: |
      curl -s "https://newsapi.org/v2/top-headlines?category={{category}}&apiKey={{api_key}}" | \
      jq '.articles[:5] | map({title: .title, url: .url, source: .source.name})'

  - name: fetch-stock
    description: 获取股票行情
    script: |
      curl -s "https://api.stockdata.com/v1/quote?symbol={{symbol}}&apiKey={{api_key}}" | \
      jq '{symbol: .symbol, price: .price, change: .change, changePercent: .change_percent}'
```

### 第二步：编写 Lobster 工作流

接下来，创建一个 Lobster 工作流来编排信息收集和处理流程：

```yaml
# ~/.openclaw/workflows/daily-briefing.lobster
name: daily-briefing
version: "1.0"

triggers:
  - type: schedule
    cron: "0 7 * * *"  # 每天早上7点执行

steps:
  # 1. 获取天气信息
  - name: get_weather
    skill: daily-briefing
    command: fetch-weather
    args:
      city: "{{user.preferences.city}}"

  # 2. 获取新闻
  - name: get_news
    skill: daily-briefing
    command: fetch-news
    args:
      category: "{{user.preferences.news_category}}"
      api_key: "{{secrets.news_api_key}}"

  # 3. 获取股票信息
  - name: get_stocks
    skill: daily-briefing
    command: fetch-stock
    loop:
      over: "{{user.preferences.watchlist}}"
      var: symbol
    args:
      symbol: "{{symbol}}"
      api_key: "{{secrets.stock_api_key}}"

  # 4. 使用 AI 生成摘要
  - name: generate_summary
    agent: content-processor
    prompt: |
      请根据以下信息生成一份简洁的每日简报：

      天气：{{steps.get_weather.output}}
      新闻：{{steps.get_news.output}}
      股票：{{steps.get_stocks.output}}

      要求：
      1. 天气部分包含穿衣建议
      2. 新闻部分提取3条最重要资讯
      3. 股票部分标注涨跌幅超过3%的股票
      4. 整体控制在300字以内
      5. 使用轻松友好的语气

  # 5. 推送到用户设备
  - name: push_notification
    skill: notification
    command: send
    args:
      channel: "{{user.preferences.notification_channel}}"
      title: "今日简报 - {{now | format_date}}"
      content: "{{steps.generate_summary.output}}"
```

### 第三步：配置个性化偏好

在 `~/.openclaw/config.yaml` 中配置个人信息偏好：

```yaml
user:
  preferences:
    city: "北京"
    news_category: "technology"
    watchlist:
      - "AAPL"
      - "TSLA"
      - "0700.HK"
    notification_channel: "wechat"

secrets:
  news_api_key: "your_news_api_key_here"
  stock_api_key: "your_stock_api_key_here"
```

## 实际案例

### 案例一：程序员专属技术简报

小王是一名前端工程师，他希望能每天收到前端技术圈的最新动态。他配置了以下工作流：

```yaml
steps:
  - name: fetch_github_trending
    skill: github
    command: get-trending
    args:
      language: "typescript"
      since: "daily"

  - name: fetch_npm_updates
    skill: npm
    command: get-updates
    args:
      packages:
        - "react"
        - "vue"
        - "@angular/core"

  - name: fetch_dev_blogs
    skill: rss
    command: fetch
    args:
      feeds:
        - "https://overreacted.io/rss.xml"
        - "https://blog.mozilla.org/javascript/rss"

  - name: generate_tech_digest
    agent: tech-writer
    prompt: |
      为前端开发者生成今日技术简报：

      GitHub Trending: {{steps.fetch_github_trending.output}}
      NPM 更新: {{steps.fetch_npm_updates.output}}
      博客文章: {{steps.fetch_dev_blogs.output}}

      请重点关注：
      1. 值得关注的开源项目（附 GitHub 链接）
      2. 重要版本更新和破坏性变更
      3. 高质量的技术文章推荐
```

### 案例二：投资者市场监控

李总是一位业余投资者，他希望在盘中收到重要市场动态：

```yaml
triggers:
  - type: schedule
    cron: "0 9,13 * * 1-5"  # 工作日开盘时执行

steps:
  - name: market_open
    skill: stock-market
    command: get-market-summary
    args:
      markets: ["CN", "US", "HK"]

  - name: portfolio_check
    skill: stock-market
    command: get-portfolio-status
    args:
      holdings: "{{user.portfolio}}"

  - name: news_scan
    skill: news
    command: search
    args:
      keywords: ["{{user.portfolio.*.name}}"]
      time_range: "24h"

  - name: alert_analysis
    agent: financial-analyst
    condition: "{{steps.portfolio_check.output.has_significant_change}}"
    prompt: |
      检测到持仓重大变动，请分析：
      持仓状态：{{steps.portfolio_check.output}}
      相关新闻：{{steps.news_scan.output}}

      请给出：
      1. 变动原因分析
      2. 是否需要关注的风险提示
      3. 建议采取的行动（如有）
```

### 案例三：多语言国际资讯

张女士需要跟踪多个国家的行业资讯，她使用以下配置实现自动翻译和汇总：

```yaml
steps:
  - name: fetch_international
    skill: rss
    command: fetch-multi
    args:
      feeds:
        - url: "https://techcrunch.com/feed/"
          lang: "en"
        - url: "https://www.nikkei.com/rss/"
          lang: "ja"
        - url: "https://www.lemonde.fr/rss/"
          lang: "fr"

  - name: translate_content
    agent: translator
    loop:
      over: "{{steps.fetch_international.output}}"
    prompt: |
      将以下内容翻译成中文：
      {{item.content}}

      原文语言：{{item.lang}}
      保留原文链接：{{item.url}}

  - name: categorize
    agent: classifier
    prompt: |
      将以下文章按主题分类（科技/财经/政策/其他）：
      {{steps.translate_content.output}}

      输出格式：
      - 标题
      - 分类
      - 一句话摘要
      - 原文链接
```

## 进阶技巧

### 智能去重与聚类

当多个信息源报道同一事件时，可以使用 AI 进行去重：

```yaml
- name: deduplicate
  agent: content-processor
  prompt: |
    以下是一组新闻标题，请识别报道同一事件的文章并只保留最完整的一条：
    {{steps.get_news.output}}

    去重规则：
    1. 同一事件的多个报道保留信息最完整的一条
    2. 不同角度的报道可以保留，但标注为相关新闻
    3. 输出按重要性排序
```

### 情感分析与优先级排序

为内容添加情感标签，帮助用户快速判断：

```yaml
- name: sentiment_analysis
  agent: sentiment-analyzer
  prompt: |
    分析以下内容的情感倾向和紧急程度：
    {{steps.get_news.output}}

    输出格式：
    - 标题
    - 情感：正面/负面/中性
    - 紧急程度：高/中/低
    - 建议关注等级：1-5星
```

通过这些配置，OpenClaw 可以成为你专属的信息管家，让你从信息过载中解放出来，专注于真正重要的内容。
---
section_id: 8.2
title: 购物与消费决策
status: draft
target_words: 1500
word_count: 1550
---

# 购物与消费决策

在电商时代，我们面临着海量的商品选择和复杂的价格体系。如何在众多选项中找到最适合自己的产品，如何确保买到真正的低价，如何避免冲动消费——这些都是现代消费者面临的挑战。OpenClaw 可以帮助我们构建一个智能购物助手，实现价格监控、比价分析、购买决策辅助等功能。

## 场景介绍

想象你正在考虑购买一台新相机。传统方式下，你需要：

1. 在多个电商平台搜索，对比价格和配置
2. 查看大量评测文章和视频
3. 关注价格波动，等待最佳购买时机
4. 在论坛和社交媒体上了解真实用户反馈

这个过程耗时耗力，而且容易遗漏重要信息。使用 OpenClaw，你可以：

- **价格监控**：自动追踪商品价格变化，在降价时第一时间通知
- **智能比价**：跨平台比较价格，识别真正的优惠
- **评价聚合**：汇总多平台用户评价，提取关键信息
- **购买建议**：根据你的需求和预算，生成个性化推荐

## 实现思路

智能购物助手的核心功能包括：

1. **价格追踪引擎**：定期抓取商品价格，记录历史价格曲线
2. **比价系统**：对比不同平台的价格、优惠、售后政策
3. **评价分析器**：使用 NLP 技术分析用户评价，提取优缺点
4. **决策助手**：综合考虑价格、评价、需求匹配度给出建议

这些功能可以通过组合使用 Skill、Agent 和 Lobster 工作流来实现。

## 配置步骤

### 第一步：创建价格监控 Skill

```yaml
# ~/.openclaw/skills/shopping/SKILL.md
---
name: shopping-assistant
description: 智能购物助手
commands:
  - name: track-price
    description: 追踪商品价格
    script: |
      # 抓取商品价格
      price_data=$(curl -s "{{product.url}}" | \
        python3 -c "import sys, json, re; html=sys.stdin.read(); price=re.search(r'price.*?([\d.]+)', html); print(json.dumps({'price': float(price.group(1)) if price else None}))")

      # 存储到数据库
      sqlite3 ~/.openclaw/data/prices.db <<EOF
        INSERT INTO price_history (product_id, platform, price, timestamp)
        VALUES ('{{product.id}}', '{{platform}}', $(echo $price_data | jq '.price'), datetime('now'));
      EOF

      echo $price_data

  - name: compare-prices
    description: 跨平台比价
    script: |
      platforms=("jd" "tmall" "amazon" "pdd")
      results=()
      for platform in "${platforms[@]}"; do
        price=$(curl -s "https://api.pricecompare.com/v1/search?query={{product.name}}&platform=$platform" | jq '.price')
        results+=("{\"platform\": \"$platform\", \"price\": $price}")
      done
      echo "[${results[*]}]"

  - name: fetch-reviews
    description: 获取商品评价
    script: |
      curl -s "https://api.reviews.com/v1/product/{{product.id}}/reviews?limit=100" | \
        jq '.reviews | map({rating: .rating, content: .content, helpful: .helpful_count})'
```

### 第二步：创建评价分析 Agent

```yaml
# ~/.openclaw/agents/review-analyzer.yaml
name: review-analyzer
description: 商品评价分析专家
system_prompt: |
  你是一位专业的商品评价分析师，擅长从海量用户评价中提取关键信息。

  分析维度：
  1. 产品质量：做工、耐用性、故障率
  2. 功能表现：是否符合描述、实际使用体验
  3. 性价比：用户认为是否物有所值
  4. 售后服务：客服响应、退换货体验
  5. 适用人群：适合什么类型的用户

  输出要求：
  - 用 bullet points 列出主要优点和缺点
  - 标注每个观点的支持度（高/中/低）
  - 给出购买建议（强烈推荐/推荐/谨慎考虑/不推荐）
  - 控制在500字以内
```

### 第三步：编写购物决策工作流

```yaml
# ~/.openclaw/workflows/shopping-decision.lobster
name: shopping-decision
version: "1.0"

triggers:
  - type: webhook
    path: "/shopping/analyze"
  - type: schedule
    cron: "0 */6 * * *"  # 每6小时检查一次价格

steps:
  # 1. 获取当前价格
  - name: get_current_prices
    skill: shopping-assistant
    command: compare-prices
    args:
      product:
        name: "{{input.product_name}}"
        id: "{{input.product_id}}"

  # 2. 获取历史价格
  - name: get_price_history
    skill: database
    command: query
    args:
      sql: |
        SELECT platform, price, timestamp
        FROM price_history
        WHERE product_id = '{{input.product_id}}'
        AND timestamp > datetime('now', '-30 days')
        ORDER BY timestamp DESC

  # 3. 分析价格趋势
  - name: analyze_price_trend
    agent: data-analyst
    prompt: |
      分析以下商品价格数据：
      当前价格：{{steps.get_current_prices.output}}
      历史价格：{{steps.get_price_history.output}}

      请提供：
      1. 当前是否是好价（是/否/一般）
      2. 近30天最低价格及出现时间
      3. 价格趋势预测（上涨/下跌/稳定）
      4. 建议等待还是立即购买

  # 4. 获取用户评价
  - name: fetch_reviews
    skill: shopping-assistant
    command: fetch-reviews
    args:
      product:
        id: "{{input.product_id}}"

  # 5. 分析评价
  - name: analyze_reviews
    agent: review-analyzer
    prompt: |
      请分析以下商品评价：
      {{steps.fetch_reviews.output}}

  # 6. 生成购买建议
  - name: generate_recommendation
    agent: shopping-advisor
    prompt: |
      基于以下信息，为用户生成购买建议：

      产品：{{input.product_name}}
      预算：{{input.budget}}元
      用途：{{input.usage}}

      价格分析：{{steps.analyze_price_trend.output}}
      评价分析：{{steps.analyze_reviews.output}}

      请提供：
      1. 总体推荐等级（1-5星）
      2. 推荐理由
      3. 最佳购买渠道
      4. 注意事项或替代建议

  # 7. 发送通知
  - name: notify_user
    skill: notification
    command: send
    condition: "{{steps.analyze_price_trend.output.is_good_price}}"
    args:
      channel: "{{user.preferences.notification_channel}}"
      title: "价格提醒：{{input.product_name}}"
      content: "{{steps.generate_recommendation.output}}"
```

### 第四步：配置用户偏好

```yaml
# ~/.openclaw/config.yaml
shopping:
  watchlist:
    - name: "Sony A7M4 相机"
      id: "sony-a7m4"
      target_price: 14000
      platforms: ["jd", "tmall", "amazon"]
    - name: "MacBook Pro 14寸"
      id: "macbook-pro-14"
      target_price: 12000
      platforms: ["apple", "jd", "tmall"]

  preferences:
    notification_threshold: 0.05  # 价格下降5%时通知
    check_interval: "6h"
    preferred_platforms: ["jd", "tmall"]
```

## 实际案例

### 案例一：相机购买决策

摄影爱好者小陈想购买一台新相机，他使用 OpenClaw 进行全面的购买分析：

```yaml
# 触发分析
input:
  product_name: "Sony A7M4"
  product_id: "sony-ilce-7m4"
  budget: 15000
  usage: "人像摄影和旅行拍摄"

# 工作流执行结果示例
steps:
  analyze_price_trend:
    output: |
      价格分析结果：
      - 当前京东价格：14,999元
      - 近30天最低：14,299元（双11期间）
      - 当前溢价：约4.9%
      - 趋势预测：预计2周内可能降价至14,500左右
      - 建议：如不急需，可等待降价

  analyze_reviews:
    output: |
      评价分析（基于2,847条评价）：

      优点（高支持度）：
      - 对焦速度快，人眼识别准确
      - 高感表现优秀，ISO 12800可用
      - 电池续航比前代提升明显

      缺点（中支持度）：
      - 机身略重，长时间手持疲劳
      - 屏幕分辨率相比竞品偏低

      购买建议：强烈推荐

  generate_recommendation:
    output: |
      购买建议：
      ⭐⭐⭐⭐⭐ 强烈推荐

      这款相机非常适合您的人像和旅行需求。
      当前价格略高于近期低点，建议设置价格提醒，
      等待降至14,500元以下再入手。

      最佳渠道：京东自营（售后有保障）
      替代选择：如预算紧张，可考虑A7C2（更轻便）
```

### 案例二：智能比价机器人

小李经常在多个平台购物，他创建了一个比价机器人：

```yaml
name: price-comparison-bot

triggers:
  - type: command
    name: "/compare"

steps:
  - name: parse_input
    agent: intent-parser
    prompt: |
      从用户输入提取商品信息："{{input.message}}"
      输出JSON格式：{product_name, brand, model, specs}

  - name: search_all_platforms
    skill: shopping-assistant
    command: search-multi
    loop:
      over: ["jd", "tmall", "pdd", "amazon", "suning"]
      var: platform
    args:
      platform: "{{platform}}"
      query: "{{steps.parse_input.output.product_name}}"

  - name: format_comparison
    agent: formatter
    prompt: |
      将以下比价结果整理成表格：
      {{steps.search_all_platforms.output}}

      输出格式：
      | 平台 | 价格 | 优惠 | 配送 | 售后评分 |
      |------|------|------|------|----------|

      并在最后给出最佳购买建议。
```

### 案例三：防冲动消费助手

小张容易冲动消费，他设置了一个"冷静期"工作流：

```yaml
name: impulse-guardian

triggers:
  - type: webhook
    path: "/shopping/wishlist/add"

steps:
  - name: cooling_period
    delay: "72h"  # 72小时冷静期

  - name: re_evaluate
    agent: shopping-advisor
    prompt: |
      72小时前，用户将以下商品加入愿望清单：
      {{input.product}}

      请帮助用户重新评估购买需求：
      1. 这件商品解决了什么问题？
      2. 是否有现有物品可以替代？
      3. 如果现在不买，会有什么影响？
      4. 这笔支出是否符合用户的财务目标？

      请生成一份"购买前自检清单"。

  - name: send_reminder
    skill: notification
    command: send
    args:
      title: "冷静期提醒：{{input.product.name}}"
      content: |
        您72小时前关注了这件商品。

        {{steps.re_evaluate.output}}

        如果仍想购买，请点击确认。
        如果不再需要，它将自动从愿望清单移除。
```

## 进阶技巧

### 优惠券自动收集

```yaml
- name: collect_coupons
  skill: shopping-assistant
  command: scrape-coupons
  args:
    platforms: ["jd", "tmall"]
    categories: ["electronics", "home"]

- name: match_coupons
  agent: coupon-matcher
  prompt: |
    用户购物车：{{user.cart}}
    可用优惠券：{{steps.collect_coupons.output}}

    请计算最优使用方案，最大化优惠金额。
```

### 二手市场价格监控

```yaml
- name: track_secondhand
  skill: shopping-assistant
  command: monitor-secondhand
  args:
    platforms: ["xianyu", "zhuanzhuan"]
    product: "{{input.product}}"
    condition: "95新以上"
    max_price: "{{input.target_price * 0.7}}"
```

通过这些配置，OpenClaw 可以成为你的智能购物顾问，帮你省钱、避坑、做出更理性的消费决策。
---
section_id: 8.3
title: 内容消费与管理
status: draft
target_words: 2000
word_count: 2080
---

# 内容消费与管理

在信息时代，我们每天都在消费大量的内容：文章、视频、播客、论文、社交媒体动态等。然而，面对海量的内容，我们往往感到 overwhelmed——收藏夹里堆积着数百篇"稍后阅读"的文章，订阅的频道更新频繁却无暇观看，重要的资料散落在各个应用中难以检索。OpenClaw 可以帮助我们构建一个智能内容管理系统，实现内容的自动收集、智能分类、摘要提取和个性化推荐。

## 场景介绍

### 内容消费的痛点

1. **信息过载**：每天产生的内容远超我们的消费能力
2. **分散存储**：内容散落在浏览器书签、笔记应用、社交媒体等各处
3. **难以检索**：需要时找不到之前看过的内容
4. **阅读压力**：收藏的内容越积越多，造成心理负担
5. **质量参差不齐**：需要花费大量时间筛选有价值的内容

### OpenClaw 的解决方案

- **智能收集**：自动从多个渠道收集你感兴趣的内容
- **自动分类**：使用 AI 对内容进行主题分类和标签化
- **摘要生成**：提取文章核心观点，帮助你快速判断是否深入阅读
- **知识库构建**：将消费过的内容整理成结构化的知识库
- **个性化推荐**：基于你的阅读历史和兴趣，推荐相关内容

## 实现思路

内容管理系统的核心架构包括：

1. **内容采集层**：通过 RSS、API、浏览器插件等方式收集内容
2. **内容处理层**：清洗、去重、分类、摘要、标签化
3. **存储层**：将处理后的内容存入知识库
4. **检索层**：提供全文搜索和语义搜索能力
5. **推荐层**：基于用户画像推荐相关内容

这些组件可以通过 Lobster 工作流串联，形成一个自动化的内容处理流水线。

## 配置步骤

### 第一步：创建内容采集 Skill

```yaml
# ~/.openclaw/skills/content-curator/SKILL.md
---
name: content-curator
description: 内容策展助手
commands:
  - name: fetch-rss
    description: 抓取 RSS 订阅源
    script: |
      curl -s "{{feed.url}}" | \
        python3 -c "
import sys
import xml.etree.ElementTree as ET
import json

xml_content = sys.stdin.read()
root = ET.fromstring(xml_content)
items = []
for item in root.findall('.//item'):
    items.append({
        'title': item.find('title').text if item.find('title') is not None else '',
        'link': item.find('link').text if item.find('link') is not None else '',
        'description': item.find('description').text if item.find('description') is not None else '',
        'pubDate': item.find('pubDate').text if item.find('pubDate') is not None else ''
    })
print(json.dumps(items[:20]))
"

  - name: fetch-article
    description: 获取文章内容
    script: |
      # 使用 readability 提取正文
      curl -s "{{url}}" | \
        python3 -c "
import sys
from readability import Document
import json

html = sys.stdin.read()
doc = Document(html)
print(json.dumps({
    'title': doc.title(),
    'content': doc.summary(),
    'text': doc.summary()
}))
" 2>/dev/null || echo '{"error": "failed to fetch"}'

  - name: save-to-db
    description: 保存内容到数据库
    script: |
      sqlite3 ~/.openclaw/data/content.db <<EOF
        INSERT OR REPLACE INTO articles
        (id, title, url, content, summary, tags, source, created_at, status)
        VALUES (
          '$(echo "{{article.url}}" | md5)',
          '{{article.title}}',
          '{{article.url}}',
          '{{article.content}}',
          '{{article.summary}}',
          '{{article.tags}}',
          '{{article.source}}',
          datetime('now'),
          'unread'
        );
      EOF
```

### 第二步：创建内容分析 Agent

```yaml
# ~/.openclaw/agents/content-analyzer.yaml
name: content-analyzer
description: 内容分析与摘要专家
system_prompt: |
  你是一位专业的内容分析师，擅长快速理解文章主旨并提取关键信息。

  任务要求：
  1. 生成一句话摘要（不超过50字）
  2. 提取3-5个核心观点
  3. 标注内容类型（技术/商业/人文/新闻/教程等）
  4. 评估阅读价值（1-5星）
  5. 建议阅读深度（略读/精读/收藏）

  输出格式（JSON）：
  {
    "summary": "一句话摘要",
    "key_points": ["观点1", "观点2", "观点3"],
    "category": "内容类型",
    "rating": 4,
    "recommendation": "精读",
    "tags": ["标签1", "标签2"]
  }
```

### 第三步：编写内容管理工作流

```yaml
# ~/.openclaw/workflows/content-pipeline.lobster
name: content-pipeline
version: "1.0"

triggers:
  - type: schedule
    cron: "0 */2 * * *"  # 每2小时执行一次
  - type: webhook
    path: "/content/add"

steps:
  # 1. 获取 RSS 订阅更新
  - name: fetch_feeds
    skill: content-curator
    command: fetch-rss
    loop:
      over: "{{user.rss_feeds}}"
      var: feed
    args:
      feed: "{{feed}}"

  # 2. 去重检查
  - name: deduplicate
    skill: database
    command: query
    args:
      sql: |
        SELECT url FROM articles
        WHERE url IN ({{steps.fetch_feeds.output.*.link}})

  # 3. 获取新文章内容
  - name: fetch_articles
    skill: content-curator
    command: fetch-article
    loop:
      over: "{{steps.fetch_feeds.output}}"
      condition: "{{item.link not in steps.deduplicate.output}}"
      var: item
    args:
      url: "{{item.link}}"

  # 4. 分析内容
  - name: analyze_content
    agent: content-analyzer
    loop:
      over: "{{steps.fetch_articles.output}}"
      var: article
    prompt: |
      请分析以下文章内容：
      标题：{{article.title}}
      内容：{{article.content | truncate: 3000}}

  # 5. 保存到知识库
  - name: save_articles
    skill: content-curator
    command: save-to-db
    loop:
      over: "{{steps.analyze_content.output}}"
      var: analysis
    args:
      article:
        title: "{{analysis.original_title}}"
        url: "{{analysis.original_url}}"
        content: "{{analysis.original_content}}"
        summary: "{{analysis.summary}}"
        tags: "{{analysis.tags | join: ','}}"
        source: "{{analysis.feed_name}}"

  # 6. 生成阅读列表
  - name: generate_digest
    agent: content-curator
    condition: "{{steps.analyze_content.output | length > 0}}"
    prompt: |
      基于以下新收录的文章，生成今日阅读推荐：
      {{steps.analyze_content.output}}

      请按以下格式输出：
      1. 必读（5星推荐）
      2. 值得一看（4星推荐）
      3. 快速浏览（3星及以下）

  # 7. 推送通知
  - name: notify_user
    skill: notification
    command: send
    condition: "{{steps.analyze_content.output | length > 0}}"
    args:
      channel: "{{user.preferences.notification_channel}}"
      title: "新内容提醒（{{steps.analyze_content.output | length}}篇）"
      content: "{{steps.generate_digest.output}}"
```

### 第四步：配置 RSS 订阅源

```yaml
# ~/.openclaw/config.yaml
content:
  rss_feeds:
    - name: "阮一峰的网络日志"
      url: "http://www.ruanyifeng.com/blog/atom.xml"
      category: "技术"
    - name: "机器之心"
      url: "https://www.jiqizhixin.com/rss"
      category: "AI"
    - name: "36氪"
      url: "https://36kr.com/feed"
      category: "商业"
    - name: "Solidot"
      url: "https://www.solidot.org/index.rss"
      category: "科技新闻"

  preferences:
    auto_archive_days: 30  # 30天后自动归档
    digest_time: "08:00"   # 每日摘要推送时间
    max_daily_articles: 10 # 每日最多推荐文章数
```

## 实际案例

### 案例一：技术博客阅读助手

程序员小李订阅了数十个技术博客，使用 OpenClaw 管理他的阅读清单：

```yaml
name: tech-reading-assistant

triggers:
  - type: schedule
    cron: "0 8 * * *"  # 每天早上8点

steps:
  - name: collect_tech_feeds
    skill: content-curator
    command: fetch-rss
    loop:
      over: "{{user.tech_feeds}}"

  - name: filter_by_interest
    agent: content-filter
    prompt: |
      根据用户技术栈偏好过滤文章：
      用户技术栈：{{user.tech_stack}}
      文章列表：{{steps.collect_tech_feeds.output}}

      只保留与用户技术栈相关的文章。

  - name: generate_tech_digest
    agent: tech-writer
    prompt: |
      为程序员生成技术早报：
      {{steps.filter_by_interest.output}}

      格式要求：
      ## 今日技术动态

      ### 前端
      - [文章标题](链接) - 一句话摘要

      ### 后端
      - [文章标题](链接) - 一句话摘要

      ### AI/ML
      - [文章标题](链接) - 一句话摘要

  - name: send_digest
    skill: notification
    command: send-email
    args:
      to: "{{user.email}}"
      subject: "技术早报 - {{today}}"
      body: "{{steps.generate_tech_digest.output}}"
```

### 案例二：论文阅读管理

研究生小王需要跟踪学术领域的最新论文：

```yaml
name: paper-tracker

triggers:
  - type: schedule
    cron: "0 9 * * 1"  # 每周一早上9点

steps:
  - name: search_arxiv
    skill: academic
    command: search-arxiv
    args:
      query: "{{user.research_keywords}}"
      date_range: "last_week"
      categories: ["cs.AI", "cs.CL", "cs.LG"]

  - name: download_papers
    skill: academic
    command: download-pdf
    loop:
      over: "{{steps.search_arxiv.output}}"

  - name: analyze_papers
    agent: research-assistant
    prompt: |
      请分析以下论文，生成研究摘要：
      论文标题：{{paper.title}}
      摘要：{{paper.abstract}}

      请提供：
      1. 研究问题
      2. 方法概述
      3. 主要贡献
      4. 与相关工作的关系
      5. 是否值得精读（是/否）

  - name: update_zotero
    skill: zotero
    command: add-items
    args:
      papers: "{{steps.analyze_papers.output}}"
      collection: "{{user.research_topic}}"

  - name: generate_weekly_report
    agent: research-assistant
    prompt: |
      基于本周新论文，生成研究周报：
      {{steps.analyze_papers.output}}

      请总结：
      1. 本周研究热点
      2. 值得关注的新方法
      3. 建议阅读的论文列表
```

### 案例三：视频内容管理

视频创作者小张需要跟踪行业内的优质视频内容：

```yaml
name: video-content-manager

triggers:
  - type: webhook
    path: "/video/bookmark"

steps:
  - name: extract_video_info
    skill: video
    command: extract-metadata
    args:
      url: "{{input.video_url}}"

  - name: transcribe_video
    skill: video
    command: generate-transcript
    args:
      video_id: "{{steps.extract_video_info.output.id}}"

  - name: analyze_transcript
    agent: content-analyzer
    prompt: |
      基于以下视频字幕，生成内容摘要：
      视频标题：{{steps.extract_video_info.output.title}}
      字幕：{{steps.transcribe_video.output}}

      请提供：
      1. 视频主题
      2. 核心观点（3-5点）
      3. 适合人群
      4. 内容质量评分

  - name: save_to_notion
    skill: notion
    command: add-page
    args:
      database: "视频库"
      properties:
        标题: "{{steps.extract_video_info.output.title}}"
        URL: "{{input.video_url}}"
        摘要: "{{steps.analyze_transcript.output.summary}}"
        标签: "{{steps.analyze_transcript.output.tags}}"
        状态: "待观看"
```

### 案例四：知识库自动构建

知识工作者小刘希望将阅读的内容自动整理成知识库：

```yaml
name: knowledge-base-builder

triggers:
  - type: schedule
    cron: "0 22 * * *"  # 每天晚上10点

steps:
  - name: get_today_articles
    skill: database
    command: query
    args:
      sql: |
        SELECT * FROM articles
        WHERE date(created_at) = date('now')
        AND status = 'read'

  - name: extract_knowledge
    agent: knowledge-extractor
    prompt: |
      从以下文章中提取知识点：
      {{steps.get_today_articles.output}}

      对每个知识点，请提供：
      - 概念名称
      - 定义/解释
      - 相关文章链接
      - 建议的分类标签

  - name: update_obsidian
    skill: obsidian
    command: create-notes
    args:
      vault_path: "{{user.obsidian_vault}}"
      notes: "{{steps.extract_knowledge.output}}"

  - name: build_graph
    skill: obsidian
    command: update-graph
    args:
      create_links: true
      link_threshold: 0.8
```

## 进阶技巧

### 语义搜索与问答

```yaml
- name: semantic_search
  skill: vector-db
  command: search
  args:
    query_embedding: "{{input.query | embed}}"
    collection: "articles"
    top_k: 5

- name: answer_question
  agent: research-assistant
  prompt: |
    基于以下相关资料，回答用户问题：
    问题：{{input.question}}
    相关资料：{{steps.semantic_search.output}}

    请提供准确、简洁的回答，并标注信息来源。
```

### 阅读进度追踪

```yaml
- name: track_reading
  skill: database
  command: update
  args:
    table: "articles"
    set:
      status: "{{input.status}}"  # unread/reading/read
      read_time: "{{input.time_spent}}"
      rating: "{{input.user_rating}}"
    where:
      url: "{{input.article_url}}"

- name: generate_stats
  agent: data-analyst
  prompt: |
    基于用户阅读数据，生成月度阅读报告：
    {{user.reading_history}}

    请分析：
    1. 阅读数量趋势
    2. 偏好的内容类型
    3. 平均阅读时长
    4. 阅读效率建议
```

通过这些配置，OpenClaw 可以帮助你构建一个强大的个人知识管理系统，让内容消费从负担变成享受，让知识积累从被动变成主动。
---
section_id: 9.1
title: 自动化邮件处理
status: draft
target_words: 1500
word_count: 1580
---

# 自动化邮件处理

电子邮件是现代工作中最重要的沟通工具之一，但也常常成为效率的杀手。据统计，知识工作者平均每天花费2-3小时处理邮件，其中大部分是重复性工作：筛选重要邮件、回复常见问题、归档整理等。OpenClaw 可以帮助我们构建一个智能邮件助手，实现邮件的自动分类、智能回复、跟进提醒等功能，让我们从邮件的海洋中解放出来。

## 场景介绍

### 邮件处理的常见痛点

1. **收件箱过载**：每天收到数十甚至上百封邮件，难以快速识别重要信息
2. **回复压力**：大量邮件需要回复，但内容重复性高
3. **跟进遗漏**：重要邮件被淹没，忘记及时跟进
4. **信息检索困难**：历史邮件分散，需要时难以快速找到
5. **垃圾邮件干扰**：营销邮件、通知邮件占据注意力

### OpenClaw 的解决方案

- **智能分类**：自动将邮件分类为紧急、重要、普通、低优先级
- **自动回复**：对常见问题自动生成回复草稿
- **跟进管理**：自动识别需要跟进的邮件并设置提醒
- **摘要提取**：长邮件自动提取要点，节省阅读时间
- **邮件归档**：按项目、客户、主题自动整理归档

## 实现思路

智能邮件处理系统的核心组件包括：

1. **邮件连接器**：通过 IMAP/SMTP 或 Gmail API 连接邮箱
2. **内容分析器**：使用 NLP 分析邮件内容、情感和意图
3. **分类引擎**：根据规则或机器学习模型对邮件分类
4. **回复生成器**：基于邮件内容和历史回复生成回复建议
5. **工作流触发器**：根据邮件类型触发相应的处理流程

## 配置步骤

### 第一步：创建邮件连接 Skill

```yaml
# ~/.openclaw/skills/email/SKILL.md
---
name: email-assistant
description: 邮件处理助手
commands:
  - name: fetch-unread
    description: 获取未读邮件
    script: |
      curl -s "https://gmail.googleapis.com/gmail/v1/users/me/messages?q=is:unread" \
        -H "Authorization: Bearer {{secrets.gmail_token}}" | \
        jq '.messages[:20] | map({id: .id, threadId: .threadId})'

  - name: get-message
    description: 获取邮件详情
    script: |
      curl -s "https://gmail.googleapis.com/gmail/v1/users/me/messages/{{message_id}}" \
        -H "Authorization: Bearer {{secrets.gmail_token}}" | \
        jq '{
          id: .id,
          subject: (.payload.headers[] | select(.name=="Subject") | .value),
          from: (.payload.headers[] | select(.name=="From") | .value),
          to: (.payload.headers[] | select(.name=="To") | .value),
          date: (.payload.headers[] | select(.name=="Date") | .value),
          body: (.payload.parts[0].body.data // .payload.body.data | @base64d)
        }'

  - name: send-reply
    description: 发送邮件回复
    script: |
      echo '{
        "raw": "'$(echo "From: {{from}}\nTo: {{to}}\nSubject: {{subject}}\n\n{{body}}" | base64 -w 0)'"
      }' | curl -s -X POST \
        "https://gmail.googleapis.com/gmail/v1/users/me/messages/send" \
        -H "Authorization: Bearer {{secrets.gmail_token}}" \
        -H "Content-Type: application/json" \
        -d @-

  - name: apply-label
    description: 应用标签
    script: |
      curl -s -X POST \
        "https://gmail.googleapis.com/gmail/v1/users/me/messages/{{message_id}}/modify" \
        -H "Authorization: Bearer {{secrets.gmail_token}}" \
        -H "Content-Type: application/json" \
        -d '{"addLabelIds": ["{{label_id}}"]}'
```

### 第二步：创建邮件分析 Agent

```yaml
# ~/.openclaw/agents/email-analyzer.yaml
name: email-analyzer
description: 邮件内容分析专家
system_prompt: |
  你是一位专业的邮件分析师，擅长快速理解邮件意图并提取关键信息。

  分析维度：
  1. 紧急程度（紧急/高/中/低）
  2. 邮件类型（工作/通知/营销/个人/垃圾邮件）
  3. 所需行动（需回复/需处理/仅需知悉/无需处理）
  4. 情感倾向（积极/中性/消极）
  5. 关键信息提取

  输出格式（JSON）：
  {
    "urgency": "high",
    "category": "work",
    "action_required": "reply",
    "sentiment": "neutral",
    "key_points": ["要点1", "要点2"],
    "deadline": "2024-01-15",
    "suggested_response_type": "accept|decline|request_info|forward"
  }
```

### 第三步：编写邮件处理工作流

```yaml
# ~/.openclaw/workflows/email-processor.lobster
name: email-processor
version: "1.0"

triggers:
  - type: schedule
    cron: "*/15 * * * *"  # 每15分钟检查一次
  - type: webhook
    path: "/email/incoming"

steps:
  # 1. 获取未读邮件
  - name: fetch_emails
    skill: email-assistant
    command: fetch-unread

  # 2. 获取邮件详情
  - name: get_details
    skill: email-assistant
    command: get-message
    loop:
      over: "{{steps.fetch_emails.output}}"
      var: msg
    args:
      message_id: "{{msg.id}}"

  # 3. 分析每封邮件
  - name: analyze_emails
    agent: email-analyzer
    loop:
      over: "{{steps.get_details.output}}"
      var: email
    prompt: |
      请分析以下邮件：
      主题：{{email.subject}}
      发件人：{{email.from}}
      内容：{{email.body | truncate: 2000}}

  # 4. 分类处理
  - name: process_urgent
    skill: email-assistant
    command: apply-label
    loop:
      over: "{{steps.analyze_emails.output}}"
      condition: "{{item.urgency == 'urgent'}}"
    args:
      message_id: "{{item.message_id}}"
      label_id: "Label_1"  # 紧急标签

  - name: process_marketing
    skill: email-assistant
    command: apply-label
    loop:
      over: "{{steps.analyze_emails.output}}"
      condition: "{{item.category == 'marketing'}}"
    args:
      message_id: "{{item.message_id}}"
      label_id: "Label_2"  # 营销邮件标签

  # 5. 生成回复建议
  - name: generate_replies
    agent: email-writer
    loop:
      over: "{{steps.analyze_emails.output}}"
      condition: "{{item.action_required == 'reply'}}"
    prompt: |
      请为以下邮件生成回复草稿：
      原邮件主题：{{item.subject}}
      原邮件内容：{{item.body | truncate: 1000}}
      建议回复类型：{{item.suggested_response_type}}

      要求：
      1. 语气专业友好
      2. 回复简洁明了
      3. 包含必要的礼貌用语

  # 6. 创建待办事项
  - name: create_todos
    skill: todo
    command: add
    loop:
      over: "{{steps.analyze_emails.output}}"
      condition: "{{item.action_required == 'process'}}"
    args:
      title: "处理邮件：{{item.subject}}"
      due_date: "{{item.deadline}}"
      priority: "{{item.urgency}}"
      source_email: "{{item.message_id}}"

  # 7. 发送摘要通知
  - name: send_digest
    skill: notification
    command: send
    condition: "{{steps.analyze_emails.output | length > 0}}"
    args:
      channel: "{{user.preferences.notification_channel}}"
      title: "新邮件摘要（{{steps.analyze_emails.output | length}}封）"
      content: |
        紧急：{{steps.analyze_emails.output | filter: 'urgency==urgent' | length}}封
        需回复：{{steps.analyze_emails.output | filter: 'action_required==reply' | length}}封
        需处理：{{steps.analyze_emails.output | filter: 'action_required==process' | length}}封
```

### 第四步：配置邮件规则

```yaml
# ~/.openclaw/config.yaml
email:
  accounts:
    - type: gmail
      email: "your.email@gmail.com"
      token: "{{secrets.gmail_token}}"

  rules:
    - name: "老板邮件"
      condition: "from contains 'boss@company.com'"
      action: "label:urgent, notify:immediately"

    - name: "客户邮件"
      condition: "from ends_with '@client.com'"
      action: "label:client, generate_reply: true"

    - name: "内部通知"
      condition: "subject contains '[通知]'"
      action: "label:notification, archive: true"

    - name: "会议邀请"
      condition: "subject contains '会议' or subject contains '邀请'"
      action: "extract_calendar: true, suggest_response: accept"

  auto_reply_templates:
    - name: "会议确认"
      trigger: "subject contains '会议邀请'"
      template: |
        您好，

        感谢邀请。我已确认参加{{meeting_time}}的会议。

        如有变动会及时告知。

        此致
        {{user.name}}

    - name: "资料请求"
      trigger: "subject contains '资料' or subject contains '文档'"
      template: |
        您好，

        收到您的资料请求，我会在{{deadline}}前准备好相关文档并发送给您。

        如有紧急需求，请电话联系。

        此致
        {{user.name}}
```

## 实际案例

### 案例一：销售团队的客户邮件管理

销售经理小王每天收到大量客户咨询邮件，使用 OpenClaw 进行自动化处理：

```yaml
name: sales-email-processor

triggers:
  - type: schedule
    cron: "*/10 * * * *"

steps:
  - name: fetch_customer_emails
    skill: email-assistant
    command: fetch-unread
    args:
      query: "from:@customer.com OR from:@prospect.com"

  - name: classify_intent
    agent: sales-assistant
    prompt: |
      分析以下客户邮件的意图：
      {{steps.fetch_customer_emails.output}}

      分类：
      1. 询价请求
      2. 技术支持
      3. 合同相关
      4. 投诉反馈
      5. 一般咨询

      同时提取：客户名称、紧急程度、期望回复时间

  - name: route_to_team
    skill: notification
    command: send
    loop:
      over: "{{steps.classify_intent.output}}"
    args:
      channel: "slack"
      recipient: |
        {% if item.category == '技术支持' %}#tech-support
        {% elif item.category == '询价请求' %}#sales
        {% else %}#customer-service
        {% endif %}
      message: |
        新客户邮件：{{item.subject}}
        客户：{{item.customer_name}}
        分类：{{item.category}}
        紧急度：{{item.urgency}}
        链接：{{item.email_link}}

  - name: auto_reply_quote
    skill: email-assistant
    command: send-reply
    loop:
      over: "{{steps.classify_intent.output}}"
      condition: "{{item.category == '询价请求' and item.urgency == 'high'}}"
    args:
      to: "{{item.from}}"
      subject: "Re: {{item.subject}}"
      body: |
        尊敬的{{item.customer_name}}，

        感谢您的询价。我已收到您的需求，正在为您准备详细报价。

        预计{{item.expected_reply_time}}内会有专人与您联系。

        如有紧急需求，请拨打：400-xxx-xxxx

        {{user.name}}
        {{user.title}}
```

### 案例二：HR 的简历筛选助手

HR 小李需要处理大量求职邮件：

```yaml
name: hr-email-processor

triggers:
  - type: schedule
    cron: "0 9,14 * * *"

steps:
  - name: fetch_applications
    skill: email-assistant
    command: fetch-unread
    args:
      query: "subject:('应聘' OR '求职' OR '简历') has:attachment"

  - name: extract_resume
    skill: document
    command: extract-text
    loop:
      over: "{{steps.fetch_applications.output}}"

  - name: analyze_candidate
    agent: hr-assistant
    prompt: |
      分析以下求职者信息：
      邮件：{{item.body}}
      简历：{{steps.extract_resume.output}}

      请评估：
      1. 应聘岗位匹配度（1-10分）
      2. 工作经验相关性
      3. 技能匹配情况
      4. 建议：面试/待定/不合适

  - name: update_ats
    skill: ats
    command: add-candidate
    args:
      name: "{{steps.analyze_candidate.output.name}}"
      position: "{{steps.analyze_candidate.output.position}}"
      score: "{{steps.analyze_candidate.output.match_score}}"
      recommendation: "{{steps.analyze_candidate.output.recommendation}}"

  - name: send_acknowledgment
    skill: email-assistant
    command: send-reply
    args:
      to: "{{item.from}}"
      subject: "简历收到确认 - {{company.name}}"
      body: |
        您好，

        感谢您应聘{{company.name}}的{{position}}职位。

        我们已收到您的简历，HR团队会在5个工作日内进行筛选。
        如通过初筛，我们会主动与您联系安排面试。

        祝您好运！

        {{company.hr_team}}
```

### 案例三：项目经理的跟进提醒

项目经理小张需要跟踪大量项目相关邮件：

```yaml
name: project-email-tracker

triggers:
  - type: schedule
    cron: "0 9 * * *"

steps:
  - name: check_pending_replies
    skill: database
    command: query
    args:
      sql: |
        SELECT * FROM email_threads
        WHERE status = 'waiting_reply'
        AND last_activity < datetime('now', '-2 days')

  - name: generate_reminders
    agent: project-assistant
    prompt: |
      以下邮件已超过2天未收到回复，请生成跟进提醒：
      {{steps.check_pending_replies.output}}

      为每封邮件生成友好的跟进邮件草稿。

  - name: send_reminders
    skill: email-assistant
    command: send-reply
    loop:
      over: "{{steps.generate_reminders.output}}"
    args:
      to: "{{item.original_recipient}}"
      subject: "跟进：{{item.original_subject}}"
      body: "{{item.reminder_draft}}"

  - name: notify_pm
    skill: notification
    command: send
    args:
      channel: "email"
      to: "{{user.email}}"
      subject: "今日邮件跟进报告"
      content: |
        已自动发送跟进邮件：{{steps.send_reminders.output | length}}封

        详情：
        {{steps.generate_reminders.output | format_table}}
```

## 进阶技巧

### 邮件线程智能总结

```yaml
- name: summarize_thread
  agent: email-analyzer
  prompt: |
    请总结以下邮件线程的核心内容：
    {{email_thread.messages}}

    输出：
    1. 讨论主题
    2. 各方观点
    3. 当前状态
    4. 待解决问题
    5. 下一步行动建议
```

### 情感监控与预警

```yaml
- name: monitor_sentiment
  agent: sentiment-analyzer
  prompt: |
    分析以下客户邮件的情感倾向：
    {{email.body}}

    如检测到强烈负面情绪（愤怒、威胁等），立即升级处理。

- name: escalate_if_needed
  skill: notification
  command: send
  condition: "{{steps.monitor_sentiment.output.score < -0.7}}"
  args:
    channel: "slack"
    recipient: "#customer-escalation"
    message: "⚠️ 检测到高优先级客户投诉，请立即处理"
```

通过这些配置，OpenClaw 可以成为你的邮件处理助手，帮你从繁琐的邮件工作中解放出来，专注于真正重要的沟通。
---
section_id: 9.2
title: 智能日程管理
status: draft
target_words: 1500
word_count: 1620
---

# 智能日程管理

日程管理是生产力工具的核心，但传统的日历应用往往只是被动地记录事件，缺乏主动的智能。OpenClaw 可以帮助我们构建一个智能日程助手，它不仅能自动同步和整理日程，还能主动分析时间使用模式、优化会议安排、智能提醒重要事项，甚至根据你的工作习惯提出效率改进建议。

## 场景介绍

### 日程管理的常见挑战

1. **日程碎片化**：会议、任务、约会分散在不同系统，难以统一视图
2. **冲突检测困难**：手动检查日程冲突耗时且容易遗漏
3. **会议效率低**：缺乏准备时间、会议目的不明确、参会人员不合适
4. **时间黑洞**：不知道时间花在哪里，难以优化
5. **提醒不及时**：错过重要会议或截止日期

### OpenClaw 的解决方案

- **多源同步**：整合日历、邮件、任务管理、项目管理等多个来源的日程
- **智能排程**：根据优先级、精力曲线、会议室可用性自动安排会议
- **会议优化**：自动生成议程、准备材料、记录纪要
- **时间分析**：分析时间使用情况，识别效率瓶颈
- **主动提醒**：根据交通状况、准备需求提前智能提醒

## 实现思路

智能日程管理系统的核心组件包括：

1. **日历连接器**：通过 CalDAV、Google Calendar API 等连接各类日历
2. **事件解析器**：从邮件、消息中提取会议请求和任务
3. **冲突检测器**：自动识别日程冲突并提出解决方案
4. **时间优化器**：分析用户的时间使用模式，提出优化建议
5. **会议助手**：会前准备、会中记录、会后跟进

## 配置步骤

### 第一步：创建日历连接 Skill

```yaml
# ~/.openclaw/skills/calendar/SKILL.md
---
name: calendar-assistant
description: 日程管理助手
commands:
  - name: fetch-events
    description: 获取日历事件
    script: |
      curl -s "https://www.googleapis.com/calendar/v3/calendars/primary/events?timeMin={{start_time}}&timeMax={{end_time}}" \
        -H "Authorization: Bearer {{secrets.google_token}}" | \
        jq '.items | map({
          id: .id,
          summary: .summary,
          start: .start.dateTime,
          end: .end.dateTime,
          location: .location,
          attendees: (.attendees // [] | map(.email)),
          description: .description
        })'

  - name: create-event
    description: 创建日历事件
    script: |
      curl -s -X POST \
        "https://www.googleapis.com/calendar/v3/calendars/primary/events" \
        -H "Authorization: Bearer {{secrets.google_token}}" \
        -H "Content-Type: application/json" \
        -d '{
          "summary": "{{title}}",
          "start": {"dateTime": "{{start_time}}", "timeZone": "{{timezone}}"},
          "end": {"dateTime": "{{end_time}}", "timeZone": "{{timezone}}"},
          "location": "{{location}}",
          "attendees": {{attendees | to_json}},
          "description": "{{description}}",
          "reminders": {"useDefault": true}
        }'

  - name: find-free-slots
    description: 查找空闲时间
    script: |
      curl -s -X POST \
        "https://www.googleapis.com/calendar/v3/freeBusy" \
        -H "Authorization: Bearer {{secrets.google_token}}" \
        -H "Content-Type: application/json" \
        -d '{
          "timeMin": "{{start_time}}",
          "timeMax": "{{end_time}}",
          "items": [{"id": "{{calendar_id}}"}]
        }' | jq '.calendars.primary.busy'

  - name: check-conflicts
    description: 检查日程冲突
    script: |
      # 查询指定时间段内的事件
      events=$(curl -s "https://www.googleapis.com/calendar/v3/calendars/primary/events?timeMin={{start_time}}&timeMax={{end_time}}" \
        -H "Authorization: Bearer {{secrets.google_token}}")

      # 检查是否有冲突
      conflicts=$(echo $events | jq '[.items[] | select(.start.dateTime < "{{end_time}}" and .end.dateTime > "{{start_time}}")]')

      echo "{\"has_conflict\": $(echo $conflicts | jq 'length > 0'), \"conflicts\": $conflicts}"
```

### 第二步：创建日程分析 Agent

```yaml
# ~/.openclaw/agents/schedule-optimizer.yaml
name: schedule-optimizer
description: 日程优化专家
system_prompt: |
  你是一位专业的时间管理顾问，擅长分析日程安排并提出优化建议。

  分析维度：
  1. 时间分布：会议 vs 深度工作 vs 休息
  2. 精力曲线：高强度任务是否安排在高效时段
  3. 会议效率：会议时长、频率、必要性
  4. 缓冲时间：任务之间是否有足够的切换时间
  5. 工作负载：每日任务量是否合理

  优化建议原则：
  - 保护深度工作时间（建议每天2-4小时）
  - 批量处理同类任务
  - 会议尽量集中在特定时段
  - 预留应急缓冲时间

  输出格式（JSON）：
  {
    "time_distribution": {"meetings": 40, "deep_work": 30, "admin": 20, "break": 10},
    "efficiency_score": 7.5,
    "issues": ["问题1", "问题2"],
    "recommendations": ["建议1", "建议2"],
    "optimized_schedule": [...]
  }
```

### 第三步：编写日程管理工作流

```yaml
# ~/.openclaw/workflows/schedule-manager.lobster
name: schedule-manager
version: "1.0"

triggers:
  - type: schedule
    cron: "0 20 * * *"  # 每晚8点分析次日日程
  - type: webhook
    path: "/calendar/event-created"

steps:
  # 1. 获取明日日程
  - name: fetch_tomorrow
    skill: calendar-assistant
    command: fetch-events
    args:
      start_time: "{{tomorrow_start}}"
      end_time: "{{tomorrow_end}}"

  # 2. 分析日程安排
  - name: analyze_schedule
    agent: schedule-optimizer
    prompt: |
      请分析以下日程安排：
      {{steps.fetch_tomorrow.output}}

      用户工作偏好：
      - 高效时段：{{user.peak_hours}}
      - 深度工作偏好：{{user.deep_work_preferences}}
      - 会议疲劳阈值：{{user.meeting_threshold}}小时/天

      请提供详细的分析和优化建议。

  # 3. 检查冲突
  - name: check_conflicts
    skill: calendar-assistant
    command: check-conflicts
    loop:
      over: "{{steps.fetch_tomorrow.output}}"
    args:
      start_time: "{{item.start}}"
      end_time: "{{item.end}}"

  # 4. 生成会议准备清单
  - name: prepare_meetings
    agent: meeting-assistant
    loop:
      over: "{{steps.fetch_tomorrow.output}}"
      condition: "{{item.attendees | length > 1}}"
    prompt: |
      为以下会议生成准备清单：
      会议：{{item.summary}}
      描述：{{item.description}}
      参会人：{{item.attendees}}

      请提供：
      1. 会议目的和预期产出
      2. 需要准备的材料
      3. 建议讨论的要点
      4. 会前需要确认的事项

  # 5. 发送日程摘要
  - name: send_digest
    skill: notification
    command: send
    args:
      channel: "{{user.preferences.notification_channel}}"
      title: "明日日程预览"
      content: |
        明日共有 {{steps.fetch_tomorrow.output | length}} 个事项

        效率评分：{{steps.analyze_schedule.output.efficiency_score}}/10

        关键会议：
        {{steps.prepare_meetings.output | format_list}}

        优化建议：
        {{steps.analyze_schedule.output.recommendations | format_list}}

  # 6. 创建待办事项
  - name: create_todos
    skill: todo
    command: add
    loop:
      over: "{{steps.prepare_meetings.output}}"
    args:
      title: "准备：{{item.meeting_name}}"
      due_date: "{{item.meeting_start | subtract: '1h'}}"
      checklist: "{{item.preparation_items}}"
```

### 第四步：配置智能排程规则

```yaml
# ~/.openclaw/config.yaml
calendar:
  accounts:
    - type: google
      email: "your.email@gmail.com"
      token: "{{secrets.google_token}}"

  preferences:
    work_hours:
      start: "09:00"
      end: "18:00"
      timezone: "Asia/Shanghai"

    peak_hours:
      - "09:00-11:00"
      - "14:00-16:00"

    deep_work_block:
      duration: "2h"
      preferred_time: "morning"
      protect: true

    meeting_rules:
      max_per_day: 4
      max_duration: "1h"
      buffer_between: "15m"
      no_meeting_blocks:
        - "12:00-14:00"  # 午休时间

    auto_schedule:
      enabled: true
      categories:
        - name: "深度工作"
          priority: 1
          preferred_slots: ["09:00-11:00"]
        - name: "团队会议"
          priority: 2
          preferred_slots: ["10:00-12:00", "14:00-16:00"]
        - name: "1对1"
          priority: 3
          preferred_slots: ["16:00-18:00"]
```

## 实际案例

### 案例一：管理者的日程优化

部门经理老李每天被会议淹没，使用 OpenClaw 优化日程安排：

```yaml
name: manager-schedule-optimizer

triggers:
  - type: schedule
    cron: "0 18 * * 0"  # 每周日晚上6点

steps:
  - name: fetch_week_schedule
    skill: calendar-assistant
    command: fetch-events
    args:
      start_time: "{{next_week_start}}"
      end_time: "{{next_week_end}}"

  - name: analyze_meeting_load
    agent: schedule-optimizer
    prompt: |
      分析下周会议负荷：
      {{steps.fetch_week_schedule.output}}

      请识别：
      1. 可以取消或缩短的会议
      2. 可以合并的类似主题会议
      3. 可以委托给下属的会议
      4. 需要增加准备时间的会议

  - name: suggest_reschedules
    agent: schedule-optimizer
    prompt: |
      基于以下分析，生成具体的改期建议：
      {{steps.analyze_meeting_load.output}}

      为每个建议提供：
      - 原会议信息
      - 建议操作（取消/缩短/改期/委托）
      - 理由
      - 建议的新时间（如适用）

  - name: batch_process
    skill: calendar-assistant
    command: batch-update
    loop:
      over: "{{steps.suggest_reschedules.output}}"
      condition: "{{item.action == 'reschedule'}}"
    args:
      event_id: "{{item.event_id}}"
      new_start: "{{item.suggested_time}}"
      new_end: "{{item.suggested_end}}"

  - name: send_weekly_report
    skill: notification
    command: send-email
    args:
      to: "{{user.email}}"
      subject: "下周日程优化报告"
      body: |
        本周会议统计：
        - 总会议数：{{steps.fetch_week_schedule.output | length}}
        - 总会议时长：{{steps.fetch_week_schedule.output | sum: 'duration'}}小时
        - 平均每日会议：{{steps.fetch_week_schedule.output | avg_per_day}}

        优化建议：
        {{steps.suggest_reschedules.output | format_table}}

        已自动调整：{{steps.batch_process.output | length}}个会议
```

### 案例二：智能会议助手

产品经理小王需要频繁组织和参与会议：

```yaml
name: smart-meeting-assistant

triggers:
  - type: webhook
    path: "/meeting/scheduled"

steps:
  - name: analyze_meeting
    agent: meeting-assistant
    prompt: |
      分析以下会议信息：
      标题：{{input.meeting_title}}
      参会人：{{input.attendees}}
      时长：{{input.duration}}

      请评估：
      1. 会议目的是否明确
      2. 参会人是否必要
      3. 时长是否合理
      4. 建议的议程结构

  - name: generate_agenda
    agent: meeting-assistant
    condition: "{{steps.analyze_meeting.output.needs_agenda}}"
    prompt: |
      为会议生成详细议程：
      主题：{{input.meeting_title}}
      目的：{{steps.analyze_meeting.output.purpose}}
      时长：{{input.duration}}

      要求：
      - 每个议题分配具体时间
      - 标注负责人
      - 明确预期产出

  - name: prepare_materials
    skill: document
    command: gather-materials
    args:
      meeting_topic: "{{input.meeting_title}}"
      attendees: "{{input.attendees}}"

  - name: send_preparation
    skill: notification
    command: send
    args:
      channel: "email"
      to: "{{input.attendees}}"
      subject: "会议准备：{{input.meeting_title}}"
      body: |
        各位好，

        会议：{{input.meeting_title}}
        时间：{{input.meeting_time}}
        地点：{{input.location}}

        议程：
        {{steps.generate_agenda.output}}

        请提前准备：
        {{steps.prepare_materials.output}}

        期待与大家的讨论！

  # 会中记录（通过语音转文字触发）
  - name: take_notes
    trigger:
      type: webhook
      path: "/meeting/start"
    skill: voice
    command: transcribe
    args:
      duration: "{{input.duration}}"

  - name: summarize_meeting
    agent: meeting-assistant
    prompt: |
      基于会议录音生成纪要：
      {{steps.take_notes.output}}

      请提供：
      1. 会议要点
      2. 决议事项
      3. 行动项（负责人+截止日期）
      4. 下次会议安排（如有）

  - name: create_followups
    skill: todo
    command: add
    loop:
      over: "{{steps.summarize_meeting.output.action_items}}"
    args:
      title: "{{item.task}}"
      assignee: "{{item.owner}}"
      due_date: "{{item.deadline}}"

  - name: send_minutes
    skill: notification
    command: send-email
    args:
      to: "{{input.attendees}}"
      subject: "会议纪要：{{input.meeting_title}}"
      body: "{{steps.summarize_meeting.output}}"
```

### 案例三：个人时间追踪与分析

自由职业者小张希望更好地管理自己的时间：

```yaml
name: personal-time-tracker

triggers:
  - type: schedule
    cron: "0 21 * * *"  # 每晚9点

steps:
  - name: fetch_today_events
    skill: calendar-assistant
    command: fetch-events
    args:
      start_time: "{{today_start}}"
      end_time: "{{today_end}}"

  - name: categorize_activities
    agent: time-analyzer
    prompt: |
      分析今日活动：
      {{steps.fetch_today_events.output}}

      请按以下类别分类：
      - 客户工作（可计费）
      - 业务开发
      - 学习提升
      - 行政事务
      - 休息娱乐

  - name: calculate_metrics
    skill: calculator
    command: compute
    args:
      billable_hours: "{{steps.categorize_activities.output.billable | sum: 'duration'}}"
      efficiency: "{{steps.categorize_activities.output.billable | sum: 'duration'}} / 8 * 100"

  - name: generate_insights
    agent: time-analyzer
    prompt: |
      基于本周时间数据生成洞察：
      今日数据：{{steps.categorize_activities.output}}
      本周趋势：{{user.weekly_time_data}}

      请分析：
      1. 时间使用模式
      2. 效率变化趋势
      3. 可优化空间
      4. 明日建议

  - name: send_daily_report
    skill: notification
    command: send
    args:
      channel: "app"
      title: "今日时间报告"
      content: |
        可计费工时：{{steps.calculate_metrics.output.billable_hours}}小时
        效率指数：{{steps.calculate_metrics.output.efficiency}}%

        时间分布：
        {{steps.categorize_activities.output | format_pie_chart}}

        明日建议：
        {{steps.generate_insights.output.tomorrow_suggestions}}
```

## 进阶技巧

### 智能冲突解决

```yaml
- name: resolve_conflict
  agent: schedule-optimizer
  prompt: |
    检测到日程冲突：
    事件A：{{conflict.event_a}}
    事件B：{{conflict.event_b}}

    请分析：
    1. 哪个事件优先级更高
    2. 是否可以改期其中一个
    3. 是否可以委派
    4. 建议的解决方案

- name: propose_alternatives
  skill: calendar-assistant
  command: find-alternatives
  args:
    event: "{{conflict.lower_priority_event}}"
    constraints:
      - "same_attendees"
      - "same_duration"
      - "within_3_days"
```

### 精力管理集成

```yaml
- name: check_energy_level
  skill: wearable
  command: get-energy-score

- name: optimize_for_energy
  agent: schedule-optimizer
  prompt: |
    用户今日精力评分：{{steps.check_energy_level.output.score}}
    今日日程：{{today_schedule}}

    如精力评分低于5分，建议：
    1. 推迟非紧急会议
    2. 将深度工作移至精力较好的时段
    3. 增加休息间隔
```

通过这些配置，OpenClaw 可以成为你的智能日程管家，帮你 reclaim 时间控制权，提升工作效率。
---
section_id: 9.3
title: 文档处理与报告生成
status: draft
target_words: 2000
word_count: 2150
---

# 文档处理与报告生成

文档处理和报告生成是知识工作者日常工作的重要组成部分。无论是撰写周报、整理会议纪要、生成数据分析报告，还是处理合同、发票等商务文档，都需要耗费大量时间和精力。OpenClaw 可以帮助我们构建一个智能文档助手，实现文档的自动处理、内容提取、格式转换和智能生成，大幅提升文档工作效率。

## 场景介绍

### 文档处理的常见挑战

1. **格式转换繁琐**：不同系统间的文档格式不兼容，需要频繁转换
2. **信息提取困难**：从大量文档中提取关键信息耗时耗力
3. **报告撰写重复**：周报、月报等周期性报告内容重复性高
4. **格式统一困难**：团队文档风格不一致，难以维护专业形象
5. **版本管理混乱**：文档多次修改后难以追踪变更历史

### OpenClaw 的解决方案

- **智能提取**：自动从各类文档中提取关键信息和数据
- **格式转换**：支持多种文档格式之间的自动转换
- **模板填充**：基于模板自动生成标准化文档
- **内容生成**：根据数据和指令自动生成报告内容
- **质量检查**：自动检查文档格式、语法、一致性

## 实现思路

智能文档处理系统的核心组件包括：

1. **文档解析器**：支持 PDF、Word、Excel、Markdown 等多种格式的解析
2. **信息提取器**：使用 NLP 技术从文档中提取结构化信息
3. **模板引擎**：支持变量替换、条件渲染、循环等模板功能
4. **内容生成器**：基于 AI 生成文档内容，支持多种写作风格
5. **格式转换器**：在不同文档格式之间进行转换

## 配置步骤

### 第一步：创建文档处理 Skill

```yaml
# ~/.openclaw/skills/document/SKILL.md
---
name: document-processor
description: 文档处理助手
commands:
  - name: extract-pdf
    description: 从 PDF 提取文本
    script: |
      python3 -c "
import pdfplumber
import json
import sys

with pdfplumber.open('{{file_path}}') as pdf:
    text = '\n'.join([page.extract_text() for page in pdf.pages if page.extract_text()])
    tables = []
    for page in pdf.pages:
        tables.extend(page.extract_tables())

print(json.dumps({'text': text, 'tables': tables, 'pages': len(pdf.pages)}))
"

  - name: extract-word
    description: 从 Word 文档提取内容
    script: |
      python3 -c "
from docx import Document
import json

doc = Document('{{file_path}}')
paragraphs = [p.text for p in doc.paragraphs if p.text.strip()]
tables = []
for table in doc.tables:
    table_data = []
    for row in table.rows:
        table_data.append([cell.text for cell in row.cells])
    tables.append(table_data)

print(json.dumps({'paragraphs': paragraphs, 'tables': tables}))
"

  - name: generate-report
    description: 生成报告文档
    script: |
      python3 -c "
from docx import Document
from docx.shared import Inches, Pt
from docx.enum.text import WD_ALIGN_PARAGRAPH
import json

doc = Document()

# 添加标题
title = doc.add_heading('{{title}}', 0)
title.alignment = WD_ALIGN_PARAGRAPH.CENTER

# 添加元信息
doc.add_paragraph('生成日期: {{date}}')
doc.add_paragraph('报告人: {{author}}')
doc.add_paragraph()

# 添加内容
content = '''{{content}}'''
doc.add_heading('报告正文', 1)
doc.add_paragraph(content)

# 保存
doc.save('{{output_path}}')
print(json.dumps({'status': 'success', 'path': '{{output_path}}'}))
"

  - name: convert-to-pdf
    description: 转换为 PDF
    script: |
      libreoffice --headless --convert-to pdf --outdir "{{output_dir}}" "{{input_file}}"

  - name: merge-documents
    description: 合并多个文档
    script: |
      python3 -c "
from docx import Document
import json

merged = Document()
files = {{files | to_json}}

for file_path in files:
    doc = Document(file_path)
    for element in doc.element.body:
        merged.element.body.append(element)
    merged.add_page_break()

merged.save('{{output_path}}')
print(json.dumps({'status': 'success', 'merged_files': len(files)}))
"
```

### 第二步：创建文档分析 Agent

```yaml
# ~/.openclaw/agents/document-analyzer.yaml
name: document-analyzer
description: 文档内容分析专家
system_prompt: |
  你是一位专业的文档分析师，擅长从各类文档中提取关键信息和洞察。

  分析能力：
  1. 提取关键数据点和指标
  2. 识别主要观点和结论
  3. 发现潜在问题和风险
  4. 总结行动项和待办事项
  5. 评估文档质量和完整性

  输出要求：
  - 结构化输出，便于后续处理
  - 标注数据来源和置信度
  - 提供可操作的建议

  输出格式（JSON）：
  {
    "summary": "文档摘要",
    "key_metrics": [{"name": "指标名", "value": "值", "context": "上下文"}],
    "main_points": ["要点1", "要点2"],
    "action_items": [{"task": "任务", "owner": "负责人", "deadline": "截止日期"}],
    "risks": ["风险1", "风险2"],
    "quality_score": 8.5,
    "suggestions": ["改进建议1"]
  }
```

### 第三步：编写文档处理工作流

```yaml
# ~/.openclaw/workflows/document-processor.lobster
name: document-processor
version: "1.0"

triggers:
  - type: webhook
    path: "/document/upload"
  - type: schedule
    cron: "0 9 * * 1"  # 每周一早上9点生成周报

steps:
  # 1. 解析上传的文档
  - name: parse_document
    skill: document-processor
    command: |
      {% if input.file_type == 'pdf' %}
        extract-pdf
      {% elif input.file_type == 'docx' %}
        extract-word
      {% endif %}
    args:
      file_path: "{{input.file_path}}"

  # 2. 分析文档内容
  - name: analyze_content
    agent: document-analyzer
    prompt: |
      请分析以下文档内容：
      {{steps.parse_document.output.text}}

      文档类型：{{input.document_type}}
      分析目的：{{input.analysis_purpose}}

  # 3. 提取结构化数据
  - name: extract_data
    agent: data-extractor
    prompt: |
      从以下文档中提取结构化数据：
      {{steps.parse_document.output}}

      需要提取的字段：
      {{input.required_fields}}

      输出为 JSON 格式。

  # 4. 存储到数据库
  - name: save_to_db
    skill: database
    command: insert
    args:
      table: "{{input.target_table}}"
      data: "{{steps.extract_data.output}}"

  # 5. 生成处理报告
  - name: generate_report
    agent: report-writer
    prompt: |
      基于以下分析结果生成处理报告：
      文档：{{input.file_name}}
      分析结果：{{steps.analyze_content.output}}
      提取数据：{{steps.extract_data.output}}

      请生成一份简洁的处理报告，包括：
      1. 文档概览
      2. 关键发现
      3. 提取的数据统计
      4. 后续建议

  # 6. 通知用户
  - name: notify_user
    skill: notification
    command: send
    args:
      channel: "{{user.preferences.notification_channel}}"
      title: "文档处理完成：{{input.file_name}}"
      content: "{{steps.generate_report.output}}"
```

### 第四步：配置报告模板

```yaml
# ~/.openclaw/templates/weekly-report.yaml
name: weekly-report
description: 周报模板
format: docx

sections:
  - name: "本周工作总结"
    type: "bullet_list"
    source: "{{work_items.this_week}}"
    template: "- {{item.title}}：{{item.description}}（完成度：{{item.progress}}%）"

  - name: "下周工作计划"
    type: "numbered_list"
    source: "{{work_items.next_week}}"
    template: "{{index}}. {{item.title}} - 预计完成时间：{{item.estimated_time}}"

  - name: "问题与风险"
    type: "table"
    headers: ["问题描述", "影响程度", "解决方案", "负责人"]
    source: "{{issues}}"

  - name: "数据指标"
    type: "metrics"
    items:
      - label: "完成任务数"
        value: "{{metrics.completed_tasks}}"
      - label: "代码提交数"
        value: "{{metrics.commits}}"
      - label: "Bug修复数"
        value: "{{metrics.bugs_fixed}}"

  - name: "需要协调的事项"
    type: "checklist"
    source: "{{coordination_items}}"

# 样式配置
styles:
  title:
    font: "Microsoft YaHei"
    size: 18
    bold: true
    alignment: center
  heading:
    font: "Microsoft YaHei"
    size: 14
    bold: true
  body:
    font: "Microsoft YaHei"
    size: 11
    line_spacing: 1.5
```

## 实际案例

### 案例一：自动周报生成

项目经理小张每周需要花费2小时写周报，使用 OpenClaw 实现自动化：

```yaml
name: auto-weekly-report

triggers:
  - type: schedule
    cron: "0 17 * * 5"  # 每周五下午5点

steps:
  # 1. 从项目管理工具获取数据
  - name: fetch_jira_data
    skill: jira
    command: get-weekly-activity
    args:
      user: "{{user.email}}"
      week_start: "{{this_week_start}}"
      week_end: "{{this_week_end}}"

  # 2. 从代码仓库获取提交记录
  - name: fetch_git_commits
    skill: git
    command: get-commits
    args:
      author: "{{user.name}}"
      since: "{{this_week_start}}"
      until: "{{this_week_end}}"

  # 3. 从日历获取会议记录
  - name: fetch_meetings
    skill: calendar
    command: get-events
    args:
      start: "{{this_week_start}}"
      end: "{{this_week_end}}"

  # 4. 汇总工作内容
  - name: summarize_work
    agent: report-writer
    prompt: |
      基于以下数据生成本周工作总结：

      JIRA 活动：
      {{steps.fetch_jira_data.output}}

      Git 提交：
      {{steps.fetch_git_commits.output}}

      参加会议：
      {{steps.fetch_meetings.output}}

      请生成：
      1. 本周完成的主要工作（按项目分类）
      2. 关键成果和里程碑
      3. 遇到的挑战和解决方案

  # 5. 生成下周计划
  - name: plan_next_week
    agent: planner
    prompt: |
      基于本周工作和待办事项，生成下周计划：
      本周完成：{{steps.summarize_work.output}}
      待办事项：{{user.backlog}}

      请生成优先级排序的下周工作计划。

  # 6. 填充报告模板
  - name: generate_document
    skill: document-processor
    command: generate-from-template
    args:
      template: "weekly-report"
      data:
        work_items:
          this_week: "{{steps.summarize_work.output}}"
          next_week: "{{steps.plan_next_week.output}}"
        metrics:
          completed_tasks: "{{steps.fetch_jira_data.output.completed | length}}"
          commits: "{{steps.fetch_git_commits.output | length}}"
        author: "{{user.name}}"
        date: "{{today}}"
      output_path: "/reports/weekly-{{today}}.docx"

  # 7. 转换为 PDF 并发送
  - name: convert_to_pdf
    skill: document-processor
    command: convert-to-pdf
    args:
      input_file: "/reports/weekly-{{today}}.docx"
      output_dir: "/reports/"

  - name: send_report
    skill: notification
    command: send-email
    args:
      to: "{{user.manager_email}}"
      cc: "{{user.team_email}}"
      subject: "周报 - {{user.name}} - {{this_week}}"
      body: |
        领导好，

        附件是我的本周工作周报，请查收。

        本周主要完成了：
        {{steps.summarize_work.output | truncate: 200}}

        如有任何问题，请随时联系。

        {{user.name}}
      attachments:
        - "/reports/weekly-{{today}}.pdf"
```

### 案例二：合同审查助手

法务助理小李需要处理大量合同，使用 OpenClaw 提高效率：

```yaml
name: contract-review-assistant

triggers:
  - type: webhook
    path: "/contract/upload"

steps:
  - name: extract_contract
    skill: document-processor
    command: extract-pdf
    args:
      file_path: "{{input.file_path}}"

  - name: analyze_contract
    agent: legal-assistant
    prompt: |
      请审查以下合同内容，识别关键条款和潜在风险：
      {{steps.extract_contract.output.text}}

      请重点关注：
      1. 付款条款（金额、时间、方式）
      2. 交付条款（时间、标准、验收）
      3. 违约责任
      4. 保密条款
      5. 争议解决
      6. 与标准模板的差异

      输出格式：
      - 合同类型
      - 关键条款摘要
      - 风险提示（高/中/低）
      - 建议修改事项
      - 审批建议（通过/有条件通过/驳回）

  - name: check_against_template
    skill: document-processor
    command: compare-documents
    args:
      doc1: "{{input.file_path}}"
      doc2: "{{company.standard_templates[input.contract_type]}}"

  - name: generate_review_report
    skill: document-processor
    command: generate-report
    args:
      title: "合同审查报告 - {{input.contract_name}}"
      content: |
        ## 合同信息
        - 合同名称：{{input.contract_name}}
        - 对方当事人：{{steps.analyze_contract.output.counterparty}}
        - 合同金额：{{steps.analyze_contract.output.amount}}

        ## 审查结果
        {{steps.analyze_contract.output}}

        ## 与标准模板对比
        {{steps.check_against_template.output.differences}}

        ## 审批建议
        {{steps.analyze_contract.output.recommendation}}
      output_path: "/contracts/reviews/{{input.contract_name}}-review.docx"

  - name: notify_legal
    skill: notification
    command: send
    condition: "{{steps.analyze_contract.output.risk_level == 'high'}}"
    args:
      channel: "email"
      to: "{{user.legal_team_email}}"
      subject: "高风险合同待审批：{{input.contract_name}}"
      content: |
        检测到高风险合同，请优先处理。

        风险摘要：
        {{steps.analyze_contract.output.risks | format_list}}

        完整审查报告：{{steps.generate_review_report.output.path}}
```

### 案例三：数据分析报告自动生成

数据分析师小王需要定期生成业务报告：

```yaml
name: auto-data-report

triggers:
  - type: schedule
    cron: "0 9 1 * *"  # 每月1号早上9点

steps:
  # 1. 从数据库获取数据
  - name: fetch_sales_data
    skill: database
    command: query
    args:
      sql: |
        SELECT
          DATE_TRUNC('month', order_date) as month,
          SUM(amount) as revenue,
          COUNT(*) as orders,
          AVG(amount) as avg_order_value
        FROM orders
        WHERE order_date >= '{{last_month_start}}'
          AND order_date < '{{this_month_start}}'
        GROUP BY DATE_TRUNC('month', order_date)

  - name: fetch_user_metrics
    skill: database
    command: query
    args:
      sql: |
        SELECT
          COUNT(DISTINCT user_id) as active_users,
          COUNT(DISTINCT CASE WHEN last_login >= '{{last_month_start}}' THEN user_id END) as retained_users
        FROM users
        WHERE created_at < '{{this_month_start}}'

  # 2. 数据分析
  - name: analyze_trends
    agent: data-analyst
    prompt: |
      分析以下业务数据，生成洞察：

      销售数据：
      {{steps.fetch_sales_data.output}}

      用户数据：
      {{steps.fetch_user_metrics.output}}

      请提供：
      1. 关键指标同比/环比变化
      2. 趋势分析（上升/下降/平稳）
      3. 异常点识别
      4. 可能的原因分析
      5. 下月预测和建议

  # 3. 生成可视化图表
  - name: generate_charts
    skill: visualization
    command: create-charts
    args:
      data: "{{steps.fetch_sales_data.output}}"
      charts:
        - type: "line"
          title: "月度收入趋势"
          x: "month"
          y: "revenue"
        - type: "bar"
          title: "订单量对比"
          x: "month"
          y: "orders"

  # 4. 生成报告文档
  - name: generate_report
    skill: document-processor
    command: generate-report
    args:
      title: "{{last_month}}月度业务报告"
      author: "{{user.name}}"
      date: "{{today}}"
      content: |
        ## 执行摘要
        {{steps.analyze_trends.output.summary}}

        ## 关键指标
        {{steps.fetch_sales_data.output | format_table}}

        ## 趋势分析
        {{steps.analyze_trends.output.trend_analysis}}

        ## 详细数据
        {{steps.fetch_sales_data.output | format_detailed}}

        ## 建议措施
        {{steps.analyze_trends.output.recommendations}}

        ## 图表
        {{steps.generate_charts.output | embed_images}}
      output_path: "/reports/monthly-{{last_month}}.docx"

  # 5. 分发报告
  - name: distribute_report
    skill: notification
    command: send-email
    args:
      to: "{{user.stakeholders}}"
      subject: "{{last_month}}月度业务报告"
      body: |
        各位好，

        {{last_month}}月度业务报告已生成，请查收附件。

        本月亮点：
        {{steps.analyze_trends.output.highlights | format_list}}

        完整报告请查看附件。
      attachments:
        - "/reports/monthly-{{last_month}}.docx"
```

## 进阶技巧

### 批量文档处理

```yaml
- name: batch_process
  skill: document-processor
  command: batch-extract
  loop:
    over: "{{input.files}}"
    parallel: true
    max_workers: 5
  args:
    file: "{{item}}"
    extraction_rules: "{{user.extraction_rules}}"

- name: consolidate_results
  agent: data-processor
  prompt: |
    汇总以下文档提取结果：
    {{steps.batch_process.output}}

    请生成统一的汇总表格，并识别跨文档的模式和异常。
```

### 智能文档比对

```yaml
- name: compare_versions
  skill: document-processor
  command: diff-documents
  args:
    old_version: "{{input.old_file}}"
    new_version: "{{input.new_file}}"

- name: summarize_changes
  agent: document-analyzer
  prompt: |
    基于以下文档差异，生成变更摘要：
    {{steps.compare_versions.output}}

    请识别：
    1. 重大变更
    2. 新增内容
    3. 删除内容
    4. 修改影响评估
```

通过这些配置，OpenClaw 可以成为你的智能文档助手，帮你从繁琐的文档工作中解放出来，专注于更有价值的创造性工作。
---
section_id: 10.1
title: 自动砍价买车
status: draft
target_words: 2000
word_count: 2100
---

# 自动砍价买车

购买汽车是一项重大消费决策，涉及大量信息收集、价格比较和谈判过程。传统购车方式需要消费者花费大量时间走访多家4S店、收集报价、研究配置，并在谈判中应对销售人员的各种话术。OpenClaw 可以帮助我们构建一个智能购车助手，实现价格监控、自动询价、智能谈判辅助等功能，让购车过程更加透明、高效。

## 场景介绍

### 传统购车的痛点

1. **信息不对称**：消费者难以获取真实的成交价和市场行情
2. **价格不透明**：同一车型在不同经销商处报价差异巨大
3. **谈判耗时**：需要反复与多个销售沟通，耗费大量时间和精力
4. **配置复杂**：车型配置繁多，难以比较不同版本的性价比
5. **隐藏费用**：各种附加费用和捆绑销售让人防不胜防

### OpenClaw 的解决方案

- **价格监控**：自动追踪目标车型的价格变化和优惠信息
- **智能询价**：同时向多家经销商发送询价请求并收集报价
- **价格分析**：分析历史成交价，识别合理的谈判区间
- **谈判辅助**：生成谈判策略和话术，提高谈判成功率
- **合同审查**：自动检查购车合同中的隐藏条款和风险点

## 实现思路

智能购车助手的核心组件包括：

1. **行情监控器**：从汽车网站、论坛等渠道抓取价格信息
2. **询价机器人**：自动向经销商发送询价请求
3. **价格分析器**：分析历史数据，确定合理价格区间
4. **谈判策略生成器**：基于市场数据生成谈判方案
5. **合同审查器**：识别合同中的风险条款

## 配置步骤

### 第一步：创建汽车行情监控 Skill

```yaml
# ~/.openclaw/skills/car-buying/SKILL.md
---
name: car-buying-assistant
description: 智能购车助手
commands:
  - name: fetch-prices
    description: 获取车型价格信息
    script: |
      # 从汽车网站抓取价格数据
      curl -s "https://api.autohome.com.cn/v1/car/price?series={{series_id}}" | \
        jq '.result | map({
          dealer: .dealer_name,
          price: .guide_price,
          discount: .discount,
          final_price: .final_price,
          location: .city,
          update_time: .update_time
        })'

  - name: fetch-deals
    description: 获取车主真实成交价
    script: |
      # 从论坛抓取真实成交信息
      curl -s "https://api.nga.cn/v1/car/deals?model={{model_id}}&page=1" | \
        jq '.data | map({
          user: .username,
          price: .deal_price,
          location: .city,
          config: .configuration,
          date: .deal_date,
          gifts: .gifts
        })[:50]'

  - name: analyze-price-trend
    description: 分析价格趋势
    script: |
      # 查询历史价格数据
      sqlite3 ~/.openclaw/data/car_prices.db <<EOF
        SELECT
          date(recorded_at) as date,
          AVG(final_price) as avg_price,
          MIN(final_price) as min_price,
          MAX(final_price) as max_price,
          COUNT(*) as sample_count
        FROM car_prices
        WHERE model_id = '{{model_id}}'
          AND recorded_at >= date('now', '-90 days')
        GROUP BY date(recorded_at)
        ORDER BY date;
      EOF

  - name: send-inquiry
    description: 向经销商发送询价
    script: |
      # 生成询价邮件
      cat <<EOF | sendmail -t
      To: {{dealer.email}}
      Subject: 询价：{{car.model}} {{car.configuration}}

      {{dealer.sales_name}}您好，

      我对贵店的{{car.model}} {{car.configuration}}感兴趣，
      想了解一下目前的优惠政策：

      1. 裸车优惠幅度
      2. 购置税计算方式
      3. 保险方案及价格
      4. 上牌费用
      5. 是否有现车，提车周期
      6. 赠送礼品

      请提供详细报价单，谢谢！

      {{buyer.name}}
      {{buyer.phone}}
      EOF
```

### 第二步：创建价格分析 Agent

```yaml
# ~/.openclaw/agents/car-negotiator.yaml
name: car-negotiator
description: 汽车价格谈判专家
system_prompt: |
  你是一位资深的汽车购买顾问，精通汽车市场价格分析和谈判策略。

  你的职责：
  1. 分析市场行情，识别合理价格区间
  2. 评估经销商报价的合理性
  3. 制定谈判策略和话术
  4. 识别隐藏费用和捆绑销售
  5. 提供购车时机建议

  分析维度：
  - 近期成交价分布
  - 季节性价格波动
  - 车型生命周期（新款/改款/清库）
  - 区域价格差异
  - 经销商库存压力

  输出要求：
  - 提供具体的价格区间（而非模糊建议）
  - 给出可操作的谈判步骤
  - 标注风险提示
```

### 第三步：编写购车工作流

```yaml
# ~/.openclaw/workflows/car-buying.lobster
name: car-buying
version: "1.0"

triggers:
  - type: command
    name: "/car/start-buying"

steps:
  # 1. 收集市场行情
  - name: fetch_market_data
    skill: car-buying-assistant
    command: fetch-prices
    args:
      series_id: "{{input.car_series_id}}"

  - name: fetch_real_deals
    skill: car-buying-assistant
    command: fetch-deals
    args:
      model_id: "{{input.car_model_id}}"

  # 2. 分析价格数据
  - name: analyze_prices
    agent: car-negotiator
    prompt: |
      请分析以下价格数据，给出购车建议：

      目标车型：{{input.car_model}} {{input.configuration}}
      指导价：{{input.guide_price}}元
      所在城市：{{input.city}}

      市场报价：
      {{steps.fetch_market_data.output}}

      真实成交价：
      {{steps.fetch_real_deals.output}}

      请提供：
      1. 合理成交价区间
      2. 当前是否是购车好时机
      3. 预期可谈到的优惠幅度
      4. 各项费用的合理范围

  # 3. 生成询价清单
  - name: generate_inquiry_list
    agent: car-negotiator
    prompt: |
      基于以下经销商信息，生成询价策略：
      {{steps.fetch_market_data.output}}

      请筛选出5-8家最值得询价的经销商，并给出优先级排序。
      考虑因素：价格竞争力、地理位置、口碑评分。

  # 4. 批量发送询价
  - name: send_inquiries
    skill: car-buying-assistant
    command: send-inquiry
    loop:
      over: "{{steps.generate_inquiry_list.output.top_dealers}}"
      var: dealer
    args:
      dealer: "{{dealer}}"
      car: "{{input}}"
      buyer: "{{user}}"

  # 5. 收集报价
  - name: collect_quotes
    skill: email
    command: fetch-replies
    args:
      subject_contains: "报价"
      since: "{{now | subtract: '2h'}}"

  # 6. 分析报价
  - name: analyze_quotes
    agent: car-negotiator
    prompt: |
      请分析以下经销商报价：
      {{steps.collect_quotes.output}}

      请对比分析：
      1. 各报价的明细对比
      2. 识别隐藏费用
      3. 真实落地价计算
      4. 最优惠的2-3个选项
      5. 进一步谈判的空间

  # 7. 生成谈判策略
  - name: generate_negotiation_strategy
    agent: car-negotiator
    prompt: |
      为以下最优选项生成详细谈判策略：
      {{steps.analyze_quotes.output.best_options}}

      请提供：
      1. 谈判目标和底线
      2. 分阶段谈判步骤
      3. 关键话术
      4. 应对销售话术的反击策略
      5. 签约前检查清单

  # 8. 发送分析报告
  - name: send_analysis_report
    skill: notification
    command: send
    args:
      channel: "email"
      to: "{{user.email}}"
      title: "购车分析报告 - {{input.car_model}}"
      content: |
        ## 市场行情分析
        {{steps.analyze_prices.output}}

        ## 经销商报价对比
        {{steps.analyze_quotes.output | format_table}}

        ## 推荐方案
        {{steps.analyze_quotes.output.best_options}}

        ## 谈判策略
        {{steps.generate_negotiation_strategy.output}}
```

### 第四步：配置购车偏好

```yaml
# ~/.openclaw/config.yaml
car_buying:
  preferences:
    target_models:
      - brand: "丰田"
        model: "凯美瑞"
        configuration: "2.5G 豪华版"
        color: "珍珠白"
        budget: 220000
      - brand: "本田"
        model: "雅阁"
        configuration: "260TURBO 幻夜·尊贵版"
        color: "星空蓝"
        budget: 210000

    location:
      city: "北京"
      preferred_dealer_distance: "30km"

    timing:
      best_months: [3, 4, 6, 7, 11, 12]  # 传统淡季和年底冲量
      avoid_months: [1, 2, 9, 10]       # 春节和金九银十

    negotiation:
      max_visits: 3
      target_discount: 0.15  # 目标优惠15%
      acceptable_discount: 0.12
      must_haves:
        - "免费首保"
        - "原厂贴膜"
        - "行车记录仪"
```

## 实际案例

### 案例一：凯美瑞购车实战

小李准备购买一辆丰田凯美瑞，使用 OpenClaw 辅助购车：

```yaml
# 触发购车流程
input:
  car_series_id: "toyota-camry-2024"
  car_model_id: "camry-2.5g-luxury"
  car_model: "凯美瑞"
  configuration: "2.5G 豪华版"
  guide_price: 219800
  city: "北京"

# 工作流执行结果示例
steps:
  analyze_prices:
    output: |
      凯美瑞 2.5G 豪华版 市场行情分析：

      指导价：219,800元

      近期成交价分布：
      - 最低成交价：186,000元（优惠15.4%）
      - 平均成交价：192,000元（优惠12.6%）
      - 最高成交价：198,000元（优惠9.9%）

      当前时机评估：
      - 3月属于传统淡季，经销商有库存压力
      - 2024款上市不久，2023款清库中
      - 建议目标：优惠14-15%

      费用参考：
      - 购置税：约16,600元
      - 保险：约6,500元（全险）
      - 上牌：约500元
      - 合理落地价：210,000-215,000元

  analyze_quotes:
    output: |
      经销商报价对比：

      | 经销商 | 裸车价 | 优惠 | 购置税 | 保险 | 上牌 | 落地价 | 评分 |
      |--------|--------|------|--------|------|------|--------|------|
      | A店 | 188,000 | 14.5% | 16,600 | 6,800 | 1,500 | 212,900 | ★★★★☆ |
      | B店 | 186,500 | 15.2% | 16,500 | 7,200 | 2,000 | 212,200 | ★★★★★ |
      | C店 | 190,000 | 13.6% | 16,800 | 6,500 | 500 | 213,800 | ★★★☆☆ |

      风险提示：
      - C店上牌费过低，可能有其他捆绑
      - A店保险报价偏高，可谈

  generate_negotiation_strategy:
    output: |
      推荐方案：B店（当前最优）

      谈判策略：

      阶段一：电话初步沟通
      - 表明已了解市场行情
      - 询问是否有进一步优惠空间
      - 目标：确认裸车价可降至185,000

      阶段二：到店谈判
      - 携带其他店报价单作为筹码
      - 重点谈判保险和上牌费用
      - 争取赠送：贴膜、记录仪、脚垫

      阶段三：最终成交
      - 目标落地价：210,000元以内
      - 要求书面确认所有承诺
      - 检查合同条款

      关键话术：
      - "我已经对比了几家店，你们的价格还有空间吗？"
      - "如果今天能定，你们能给到什么价格？"
      - "保险我自己买，能不能再便宜点？"
```

### 案例二：价格监控与时机把握

小王不急于购车，选择持续监控价格等待最佳时机：

```yaml
name: car-price-monitor

triggers:
  - type: schedule
    cron: "0 10 * * *"  # 每天早上10点检查

steps:
  - name: check_current_prices
    skill: car-buying-assistant
    command: fetch-prices
    args:
      series_id: "{{user.watchlist.*.series_id}}"

  - name: compare_with_history
    skill: database
    command: query
    args:
      sql: |
        SELECT model_id, AVG(final_price) as avg_price
        FROM car_prices
        WHERE recorded_at >= date('now', '-30 days')
        GROUP BY model_id

  - name: detect_price_drop
    agent: price-analyzer
    prompt: |
      对比当前价格与历史均价：
      当前价格：{{steps.check_current_prices.output}}
      30天均价：{{steps.compare_with_history.output}}

      识别价格显著下降（>3%）的车型。

  - name: notify_opportunity
    skill: notification
    command: send
    condition: "{{steps.detect_price_drop.output.has_drop}}"
    args:
      channel: "wechat"
      title: "购车好时机！"
      content: |
        您关注的车型出现降价：
        {{steps.detect_price_drop.output.drops | format_list}}

        建议尽快联系经销商询价。
```

### 案例三：合同审查与风险识别

小张在签约前使用 OpenClaw 审查购车合同：

```yaml
name: contract-review

triggers:
  - type: command
    name: "/car/review-contract"

steps:
  - name: extract_contract
    skill: document
    command: extract-text
    args:
      file_path: "{{input.contract_path}}"

  - name: analyze_contract
    agent: legal-assistant
    prompt: |
      请审查以下购车合同，识别风险条款：
      {{steps.extract_contract.output}}

      重点关注：
      1. 车辆信息是否准确（VIN、配置、颜色）
      2. 价格明细是否清晰
      3. 交车时间和违约责任
      4. 退款条款
      5. 附加服务是否强制
      6. 争议解决方式

      标注每个风险点的严重程度和建议。

  - name: generate_checklist
    agent: car-negotiator
    prompt: |
      基于合同审查结果，生成签约前检查清单：
      {{steps.analyze_contract.output}}

      请列出签约前必须确认的事项。

  - name: send_review_report
    skill: notification
    command: send
    args:
      channel: "email"
      to: "{{user.email}}"
      title: "购车合同审查报告"
      content: |
        ## 风险等级：{{steps.analyze_contract.output.risk_level}}

        ## 主要问题
        {{steps.analyze_contract.output.issues | format_list}}

        ## 签约前检查清单
        {{steps.generate_checklist.output}}

        ## 建议
        {{steps.analyze_contract.output.recommendations}}
```

## 进阶技巧

### 跨城市比价

```yaml
- name: compare_cities
  skill: car-buying-assistant
  command: fetch-prices
  loop:
    over: ["北京", "上海", "广州", "天津"]
    var: city
  args:
    series_id: "{{input.series_id}}"
    city: "{{city}}"

- name: analyze_city_diff
  agent: car-negotiator
  prompt: |
    分析跨城市价格差异：
    {{steps.compare_cities.output}}

    计算异地购车的可行性（考虑运费、上牌等成本）。
```

### 库存压力分析

```yaml
- name: check_inventory
  skill: car-buying-assistant
  command: get-dealer-inventory
  args:
    dealer_id: "{{input.dealer_id}}"
    model_id: "{{input.model_id}}"

- name: assess_negotiation_power
  agent: car-negotiator
  prompt: |
    基于库存数据评估谈判筹码：
    库存量：{{steps.check_inventory.output.count}}
    库存天数：{{steps.check_inventory.output.days_of_inventory}}

    库存天数>60天：强谈判地位
    库存天数30-60天：中等谈判地位
    库存天数<30天：弱谈判地位
```

通过这些配置，OpenClaw 可以成为你的智能购车顾问，帮你省钱、避坑、买到心仪的爱车。
---
section_id: 10.2
title: 研究助手与竞品分析
status: draft
target_words: 2000
word_count: 2080
---

# 研究助手与竞品分析

在快速变化的商业环境中，及时准确的市场研究和竞品分析是企业保持竞争力的关键。然而，传统的研究方式往往耗时耗力：需要人工收集大量信息、整理数据、撰写报告。OpenClaw 可以帮助我们构建一个智能研究助手，实现信息自动收集、智能分析、报告自动生成等功能，大幅提升研究效率和质量。

## 场景介绍

### 市场研究的挑战

1. **信息分散**：市场信息散落在新闻、财报、社交媒体、行业报告等多个渠道
2. **数据更新快**：市场变化迅速，需要持续跟踪最新动态
3. **分析深度不够**：人工分析难以处理海量数据，容易遗漏关键洞察
4. **报告撰写耗时**：整理研究结果、撰写分析报告需要大量时间
5. **竞品监控困难**：难以实时了解竞争对手的动态

### OpenClaw 的解决方案

- **信息聚合**：自动从多个渠道收集市场信息
- **智能摘要**：自动提取关键信息，生成内容摘要
- **趋势分析**：识别市场趋势和变化模式
- **竞品监控**：持续跟踪竞争对手的动态
- **报告生成**：自动生成结构化的研究报告

## 实现思路

智能研究助手的核心组件包括：

1. **信息采集器**：从新闻、财报、社交媒体等渠道抓取数据
2. **内容处理器**：清洗、去重、分类、摘要信息
3. **分析引擎**：识别趋势、模式、关联关系
4. **知识库**：存储和管理研究资料
5. **报告生成器**：基于模板和数据生成报告

## 配置步骤

### 第一步：创建信息采集 Skill

```yaml
# ~/.openclaw/skills/research/SKILL.md
---
name: research-assistant
description: 市场研究助手
commands:
  - name: fetch-news
    description: 获取行业新闻
    script: |
      curl -s "https://newsapi.org/v2/everything?q={{keywords}}&from={{date_from}}&to={{date_to}}&sortBy=relevancy&apiKey={{secrets.news_api_key}}" | \
        jq '.articles | map({
          title: .title,
          source: .source.name,
          publishedAt: .publishedAt,
          url: .url,
          content: .content
        })'

  - name: fetch-financial
    description: 获取财务数据
    script: |
      curl -s "https://api.polygon.io/v2/aggs/ticker/{{ticker}}/range/1/day/{{date_from}}/{{date_to}}?apiKey={{secrets.polygon_key}}" | \
        jq '.results | map({
          date: (.t / 1000 | strftime("%Y-%m-%d")),
          open: .o,
          high: .h,
          low: .l,
          close: .c,
          volume: .v
        })'

  - name: fetch-social
    description: 获取社交媒体数据
    script: |
      curl -s "https://api.twitter.com/2/tweets/search/recent?query={{keywords}}&max_results=100" \
        -H "Authorization: Bearer {{secrets.twitter_token}}" | \
        jq '.data | map({
          id: .id,
          text: .text,
          created_at: .created_at,
          public_metrics: .public_metrics
        })'

  - name: scrape-competitor-site
    description: 抓取竞品网站
    script: |
      curl -s "{{url}}" | \
        python3 -c "
import sys
from bs4 import BeautifulSoup
import json

html = sys.stdin.read()
soup = BeautifulSoup(html, 'html.parser')

# 提取产品信息
products = []
for item in soup.select('.product-item'):
    products.append({
        'name': item.select_one('.product-name').text if item.select_one('.product-name') else '',
        'price': item.select_one('.product-price').text if item.select_one('.product-price') else '',
        'description': item.select_one('.product-desc').text if item.select_one('.product-desc') else ''
    })

print(json.dumps(products))
"

  - name: save-to-research-db
    description: 保存到研究数据库
    script: |
      sqlite3 ~/.openclaw/data/research.db <<EOF
        INSERT INTO research_data
        (id, topic, source_type, source_url, title, content, collected_at, tags)
        VALUES (
          '$(echo "{{data.url}}" | md5)',
          '{{topic}}',
          '{{source_type}}',
          '{{data.url}}',
          '{{data.title}}',
          '{{data.content}}',
          datetime('now'),
          '{{tags}}'
        );
      EOF
```

### 第二步：创建研究分析 Agent

```yaml
# ~/.openclaw/agents/research-analyst.yaml
name: research-analyst
description: 市场研究分析专家
system_prompt: |
  你是一位资深的市场研究分析师，擅长从海量信息中提取有价值的洞察。

  分析能力：
  1. 行业趋势识别
  2. 竞争格局分析
  3. 市场机会发现
  4. 风险评估
  5. 战略建议

  分析框架：
  - PEST分析（政治、经济、社会、技术）
  - 波特五力模型
  - SWOT分析
  - 竞争定位图

  输出要求：
  - 基于数据和事实
  - 结构化呈现
  - 提供可操作的洞察
  - 标注信息来源

  输出格式（JSON）：
  {
    "summary": "核心发现摘要",
    "key_trends": [{"trend": "趋势描述", "impact": "影响程度", "confidence": "置信度"}],
    "competitive_landscape": {"market_leaders": [], "challengers": [], "niche_players": []},
    "opportunities": ["机会1", "机会2"],
    "threats": ["威胁1", "威胁2"],
    "recommendations": ["建议1", "建议2"]
  }
```

### 第三步：编写研究工作流

```yaml
# ~/.openclaw/workflows/market-research.lobster
name: market-research
version: "1.0"

triggers:
  - type: command
    name: "/research/start"
  - type: schedule
    cron: "0 8 * * 1"  # 每周一早8点生成周报

steps:
  # 1. 收集行业新闻
  - name: collect_news
    skill: research-assistant
    command: fetch-news
    args:
      keywords: "{{input.industry_keywords}}"
      date_from: "{{date | subtract: '7d' | format_date}}"
      date_to: "{{date | format_date}}"

  # 2. 收集竞品动态
  - name: collect_competitor_news
    skill: research-assistant
    command: fetch-news
    loop:
      over: "{{input.competitors}}"
      var: competitor
    args:
      keywords: "{{competitor.name}}"
      date_from: "{{date | subtract: '7d' | format_date}}"

  # 3. 抓取竞品网站更新
  - name: scrape_competitors
    skill: research-assistant
    command: scrape-competitor-site
    loop:
      over: "{{input.competitor_websites}}"
      var: site
    args:
      url: "{{site}}"

  # 4. 获取财务数据
  - name: fetch_financials
    skill: research-assistant
    command: fetch-financial
    loop:
      over: "{{input.competitor_tickers}}"
      var: ticker
    args:
      ticker: "{{ticker}}"
      date_from: "{{date | subtract: '30d' | format_date}}"

  # 5. 分析内容
  - name: analyze_news
    agent: research-analyst
    prompt: |
      分析以下行业新闻，识别关键趋势：
      {{steps.collect_news.output}}

      请提供：
      1. 本周最重要的3-5条行业动态
      2. 对行业格局的潜在影响
      3. 需要持续关注的事项

  - name: analyze_competitors
    agent: research-analyst
    prompt: |
      基于以下竞品信息，更新竞争分析：
      新闻动态：{{steps.collect_competitor_news.output}}
      网站更新：{{steps.scrape_competitors.output}}
      财务数据：{{steps.fetch_financials.output}}

      请分析：
      1. 各竞品的最新动向
      2. 产品/策略变化
      3. 市场地位变化
      4. 我们的应对建议

  # 6. 保存到知识库
  - name: save_findings
    skill: research-assistant
    command: save-to-research-db
    loop:
      over: "{{steps.collect_news.output}}"
      var: item
    args:
      topic: "{{input.research_topic}}"
      source_type: "news"
      data: "{{item}}"
      tags: "{{input.industry_keywords}}"

  # 7. 生成研究报告
  - name: generate_report
    agent: research-analyst
    prompt: |
      基于以下分析结果，生成{{input.report_type}}：
      行业趋势：{{steps.analyze_news.output}}
      竞品分析：{{steps.analyze_competitors.output}}

      报告要求：
      1. 执行摘要（1页）
      2. 详细分析（3-5页）
      3. 数据可视化建议
      4. 行动建议

  # 8. 发送报告
  - name: distribute_report
    skill: notification
    command: send-email
    args:
      to: "{{input.stakeholders}}"
      subject: "{{input.research_topic}} - {{date | format_date}}研究周报"
      body: "{{steps.generate_report.output}}"
      attachments:
        - "{{steps.generate_report.output.file_path}}"
```

### 第四步：配置研究项目

```yaml
# ~/.openclaw/config.yaml
research:
  projects:
    - name: "SaaS行业研究"
      topic: "saas-industry-2024"
      industry_keywords:
        - "SaaS"
        - "企业服务"
        - "云计算"
        - "订阅经济"
      competitors:
        - name: "Salesforce"
          ticker: "CRM"
          website: "https://www.salesforce.com"
        - name: "HubSpot"
          ticker: "HUBS"
          website: "https://www.hubspot.com"
        - name: "Zendesk"
          ticker: "ZEN"
          website: "https://www.zendesk.com"
      data_sources:
        - type: "news"
          enabled: true
        - type: "financial"
          enabled: true
        - type: "social"
          enabled: true
        - type: "website"
          enabled: true
          check_interval: "24h"
      report_schedule: "weekly"
      stakeholders:
        - "strategy@company.com"
        - "product@company.com"
```

## 实际案例

### 案例一：新产品市场调研

产品经理小李准备推出一款新的项目管理工具，需要进行市场调研：

```yaml
# 触发市场调研
input:
  research_topic: "project-management-tools-market"
  industry_keywords:
    - "项目管理软件"
    - "协同办公"
    - "敏捷开发"
    - "任务管理"
  competitors:
    - name: "Asana"
      ticker: "ASAN"
    - name: "Monday.com"
      ticker: "MNDY"
    - name: "ClickUp"
    - name: "Notion"
    - name: "飞书项目"
    - name: "Teambition"

# 工作流执行结果示例
steps:
  analyze_news:
    output: |
      项目管理工具市场趋势分析：

      1. AI集成成为标配
      - 多家厂商推出AI助手功能
      - 智能任务分配、进度预测成为趋势
      - 建议：将AI能力作为核心差异化点

      2. 垂直化细分明显
      - 针对软件开发的Jira
      - 针对营销团队的Monday
      - 针对设计的Figma + Notion
      - 建议：明确目标垂直领域

      3. 定价模式创新
      - 从按用户数转向按功能/使用量
      - 免费层功能越来越丰富
      - 建议：采用freemium + 增值模式

  analyze_competitors:
    output: |
      竞品分析摘要：

      | 竞品 | 优势 | 劣势 | 最新动态 |
      |------|------|------|----------|
      | Asana | 品牌知名度高 | 定价较高 | 推出AI工作流 |
      | Monday | 可视化强 | 学习曲线陡 | 收购AI公司 |
      | ClickUp | 功能全面 | 性能问题 | 融资$400M |
      | Notion | 灵活性高 | 项目管理弱 | 推出日历功能 |
      | 飞书 | 生态整合 | 国际化弱 | 出海加速 |

      市场空白点：
      - 针对中国团队的本地化AI功能
      - 与微信/钉钉的深度集成
      - 更合理的中小企业定价

  generate_report:
    output: |
      # 项目管理工具市场调研报告

      ## 执行摘要
      市场规模：$8.5B（2024），CAGR 12.3%
      竞争格局：头部集中，但仍有创新空间
      关键趋势：AI集成、垂直化、定价创新
      建议：聚焦AI+本地化，差异化竞争

      ## 详细分析
      ...

      ## 产品建议
      1. MVP功能：任务管理 + AI助手 + 钉钉集成
      2. 目标用户：50-500人研发团队
      3. 定价策略：免费版(5人) + $8/人/月
```

### 案例二：竞品动态监控

市场经理小王需要持续监控主要竞品的动态：

```yaml
name: competitor-monitor

triggers:
  - type: schedule
    cron: "0 9 * * *"  # 每天早上9点

steps:
  - name: check_website_changes
    skill: research-assistant
    command: detect-website-changes
    loop:
      over: "{{user.tracked_competitors}}"
    args:
      url: "{{item.website}}"
      last_hash: "{{item.last_hash}}"

  - name: check_pricing_changes
    skill: research-assistant
    command: extract-pricing
    loop:
      over: "{{user.tracked_competitors}}"
    args:
      pricing_page: "{{item.pricing_url}}"

  - name: check_feature_releases
    skill: research-assistant
    command: fetch-news
    args:
      keywords: "{{user.tracked_competitors.*.name}} release new feature"
      date_from: "{{yesterday}}"

  - name: analyze_changes
    agent: research-analyst
    prompt: |
      分析竞品最新变化：
      网站更新：{{steps.check_website_changes.output}}
      价格变化：{{steps.check_pricing_changes.output}}
      功能发布：{{steps.check_feature_releases.output}}

      识别需要立即关注的变化。

  - name: send_alert
    skill: notification
    command: send
    condition: "{{steps.analyze_changes.output.has_critical_change}}"
    args:
      channel: "slack"
      recipient: "#competitive-intel"
      title: "竞品重要动态提醒"
      content: |
        检测到竞品重要变化：
        {{steps.analyze_changes.output.critical_changes | format_list}}

        建议应对措施：
        {{steps.analyze_changes.output.recommended_actions}}
```

### 案例三：投资决策支持

投资分析师小张需要快速了解一个新兴行业：

```yaml
name: investment-research

triggers:
  - type: command
    name: "/research/investment"

steps:
  - name: collect_industry_overview
    skill: research-assistant
    command: fetch-news
    args:
      keywords: "{{input.industry}} industry overview market size"
      date_from: "{{date | subtract: '90d'}}"

  - name: collect_funding_news
    skill: research-assistant
    command: fetch-news
    args:
      keywords: "{{input.industry}} funding investment VC"
      date_from: "{{date | subtract: '90d'}}"

  - name: identify_key_players
    agent: research-analyst
    prompt: |
      基于以下信息，识别{{input.industry}}的关键玩家：
      {{steps.collect_industry_overview.output}}
      {{steps.collect_funding_news.output}}

      分类：
      - 行业领导者
      - 快速增长者
      - 新兴挑战者
      - 潜在收购目标

  - name: analyze_market_opportunity
    agent: research-analyst
    prompt: |
      评估{{input.industry}}的投资机会：
      行业概况：{{steps.collect_industry_overview.output}}
      融资动态：{{steps.collect_funding_news.output}}
      关键玩家：{{steps.identify_key_players.output}}

      请提供：
      1. TAM/SAM/SOM估算
      2. 增长驱动因素
      3. 风险因素
      4. 投资时机评估
      5. 建议关注标的

  - name: generate_investment_memo
    skill: document
    command: generate-report
    args:
      template: "investment-memo"
      data:
        industry: "{{input.industry}}"
        overview: "{{steps.collect_industry_overview.output}}"
        funding: "{{steps.collect_funding_news.output}}"
        players: "{{steps.identify_key_players.output}}"
        analysis: "{{steps.analyze_market_opportunity.output}}"
      output_path: "/research/memos/{{input.industry}}-{{date}}.pdf"
```

## 进阶技巧

### 情感分析与舆论监控

```yaml
- name: analyze_sentiment
  skill: research-assistant
  command: fetch-social
  args:
    keywords: "{{input.brand_name}}"

- name: sentiment_analysis
  agent: sentiment-analyzer
  prompt: |
    分析以下社交媒体内容的情感倾向：
    {{steps.analyze_sentiment.output}}

    请提供：
    1. 整体情感得分
    2. 正面/负面话题分布
    3. 提及频率最高的关键词
    4. 需要关注的舆情风险
```

### 专利与技术追踪

```yaml
- name: fetch_patents
  skill: research-assistant
  command: search-patents
  args:
    assignee: "{{input.competitor_name}}"
    date_range: "last_6_months"

- name: analyze_tech_trends
  agent: research-analyst
  prompt: |
    分析以下专利数据，识别技术趋势：
    {{steps.fetch_patents.output}}

    请识别：
    1. 重点技术方向
    2. 技术布局变化
    3. 潜在的技术壁垒
    4. 对我们的启示
```

通过这些配置，OpenClaw 可以成为你的智能研究助手，帮你快速获取市场洞察，做出更明智的商业决策。
---
section_id: 10.3
title: 代码审查与Bug修复
status: draft
target_words: 2000
word_count: 2120
---

# 代码审查与Bug修复

代码质量是软件项目的生命线。传统的代码审查依赖人工检查，不仅耗时，而且容易遗漏问题。OpenClaw 可以帮助我们构建一个智能代码审查助手，实现自动化的代码分析、Bug检测、安全漏洞扫描、代码风格检查等功能，大幅提升代码质量和开发效率。

## 场景介绍

### 代码审查的挑战

1. **审查耗时**：人工代码审查占用大量开发时间
2. **标准不统一**：不同审查者对代码质量标准的理解不一致
3. **问题遗漏**：复杂逻辑和边界条件容易被忽略
4. **知识传递困难**：代码审查是团队学习的重要机会，但难以系统化
5. **安全隐患**：安全漏洞往往隐藏在代码细节中，难以发现

### OpenClaw 的解决方案

- **自动化分析**：自动检测代码中的潜在问题
- **智能建议**：基于上下文提供具体的改进建议
- **安全扫描**：自动识别常见的安全漏洞
- **知识库集成**：关联相关文档和最佳实践
- **学习反馈**：从审查历史中学习团队的代码规范

## 实现思路

智能代码审查系统的核心组件包括：

1. **代码解析器**：解析多种编程语言的代码结构
2. **静态分析器**：检测代码异味、潜在Bug、性能问题
3. **安全扫描器**：识别安全漏洞和合规问题
4. **风格检查器**：确保代码符合团队规范
5. **审查助手**：生成审查意见和修复建议

## 配置步骤

### 第一步：创建代码分析 Skill

```yaml
# ~/.openclaw/skills/code-review/SKILL.md
---
name: code-review-assistant
description: 代码审查助手
commands:
  - name: analyze-diff
    description: 分析代码变更
    script: |
      # 获取 PR 的 diff
      curl -s -H "Authorization: token {{secrets.github_token}}" \
        "https://api.github.com/repos/{{repo}}/pulls/{{pr_number}}/files" | \
        jq '.[] | {filename: .filename, status: .status, patch: .patch, additions: .additions, deletions: .deletions}'

  - name: run-linter
    description: 运行代码检查工具
    script: |
      cd {{repo_path}}
      case "{{language}}" in
        python)
          pylint --output-format=json {{file_path}} 2>/dev/null || true
          flake8 --format=json {{file_path}} 2>/dev/null || true
          ;;
        javascript|typescript)
          eslint --format=json {{file_path}} 2>/dev/null || true
          ;;
        go)
          golint {{file_path}} 2>/dev/null || true
          go vet {{file_path}} 2>/dev/null || true
          ;;
      esac

  - name: run-security-scan
    description: 运行安全扫描
    script: |
      cd {{repo_path}}
      # 使用 bandit 扫描 Python 代码
      if [ "{{language}}" = "python" ]; then
        bandit -f json -r {{file_path}} 2>/dev/null || true
      fi
      # 使用 semgrep 进行多语言扫描
      semgrep --config=auto --json {{file_path}} 2>/dev/null || true

  - name: post-review-comment
    description: 提交审查意见
    script: |
      curl -s -X POST \
        -H "Authorization: token {{secrets.github_token}}" \
        -H "Accept: application/vnd.github.v3+json" \
        "https://api.github.com/repos/{{repo}}/pulls/{{pr_number}}/reviews" \
        -d '{
          "body": "{{review_body}}",
          "event": "{{event}}",
          "comments": {{comments | to_json}}
        }'

  - name: create-fix-branch
    description: 创建修复分支
    script: |
      cd {{repo_path}}
      git checkout -b "fix/{{issue_id}}-{{timestamp}}"
      # 应用修复
      echo "{{fix_code}}" > {{file_path}}
      git add {{file_path}}
      git commit -m "fix: {{fix_description}}"
      git push origin "fix/{{issue_id}}-{{timestamp}}"
```

### 第二步：创建代码审查 Agent

```yaml
# ~/.openclaw/agents/code-reviewer.yaml
name: code-reviewer
description: 代码审查专家
system_prompt: |
  你是一位资深的软件工程师，擅长代码审查和质量保证。

  审查维度：
  1. 代码正确性：逻辑错误、边界条件、异常处理
  2. 代码风格：命名规范、代码格式、注释质量
  3. 性能优化：算法复杂度、资源使用、缓存策略
  4. 安全性：注入攻击、敏感信息泄露、权限控制
  5. 可维护性：代码结构、重复代码、复杂度
  6. 测试覆盖：单元测试、边界测试、异常测试

  审查原则：
  - 提供具体的改进建议，而非模糊批评
  - 解释为什么需要修改，帮助开发者成长
  - 区分阻塞性问题和建议性改进
  - 认可好的代码实践

  输出格式（JSON）：
  {
    "summary": "审查摘要",
    "issues": [
      {
        "severity": "error|warning|info",
        "category": "correctness|style|performance|security|maintainability",
        "file": "文件路径",
        "line": 行号,
        "message": "问题描述",
        "suggestion": "改进建议",
        "example": "代码示例"
      }
    ],
    "positive_feedback": ["值得肯定的地方"],
    "overall_assessment": "总体评价"
  }
```

### 第三步：编写代码审查工作流

```yaml
# ~/.openclaw/workflows/code-review.lobster
name: code-review
version: "1.0"

triggers:
  - type: webhook
    path: "/github/pull-request"
    condition: "{{event.action == 'opened' or event.action == 'synchronize'}}"

steps:
  # 1. 获取代码变更
  - name: fetch_diff
    skill: code-review-assistant
    command: analyze-diff
    args:
      repo: "{{event.repository.full_name}}"
      pr_number: "{{event.pull_request.number}}"

  # 2. 运行静态分析
  - name: run_static_analysis
    skill: code-review-assistant
    command: run-linter
    loop:
      over: "{{steps.fetch_diff.output}}"
      condition: "{{item.status != 'removed'}}"
    args:
      repo_path: "/tmp/repos/{{event.repository.name}}"
      file_path: "{{item.filename}}"
      language: "{{item.filename | detect_language}}"

  # 3. 运行安全扫描
  - name: run_security_scan
    skill: code-review-assistant
    command: run-security-scan
    loop:
      over: "{{steps.fetch_diff.output}}"
      condition: "{{item.status != 'removed'}}"
    args:
      repo_path: "/tmp/repos/{{event.repository.name}}"
      file_path: "{{item.filename}}"
      language: "{{item.filename | detect_language}}"

  # 4. AI 代码审查
  - name: ai_code_review
    agent: code-reviewer
    loop:
      over: "{{steps.fetch_diff.output}}"
      condition: "{{item.status != 'removed' and item.additions > 0}}"
    prompt: |
      请审查以下代码变更：

      文件：{{item.filename}}
      变更：
      ```diff
      {{item.patch}}
      ```

      项目上下文：
      - 语言：{{item.filename | detect_language}}
      - 框架：{{repo.framework}}
      - 团队规范：{{team.coding_standards}}

      请提供详细的审查意见。

  # 5. 汇总审查结果
  - name: consolidate_review
    agent: code-reviewer
    prompt: |
      汇总以下审查结果，生成整体评价：

      静态分析结果：
      {{steps.run_static_analysis.output}}

      安全扫描结果：
      {{steps.run_security_scan.output}}

      AI 审查结果：
      {{steps.ai_code_review.output}}

      请生成：
      1. 审查摘要
      2. 按严重程度排序的问题列表
      3. 修复优先级建议
      4. 总体评价（通过/需修改/拒绝）

  # 6. 提交审查意见
  - name: post_review
    skill: code-review-assistant
    command: post-review-comment
    args:
      repo: "{{event.repository.full_name}}"
      pr_number: "{{event.pull_request.number}}"
      review_body: "{{steps.consolidate_review.output.summary}}"
      event: |
        {% if steps.consolidate_review.output.has_blocking_issues %}
          REQUEST_CHANGES
        {% else %}
          COMMENT
        {% endif %}
      comments: "{{steps.consolidate_review.output.issues | format_review_comments}}"

  # 7. 创建修复建议（可选）
  - name: suggest_fixes
    agent: code-reviewer
    condition: "{{steps.consolidate_review.output.can_auto_fix}}"
    prompt: |
      为以下问题生成自动修复代码：
      {{steps.consolidate_review.output.auto_fixable_issues}}

      请提供可直接应用的代码修改。

  - name: create_fix_pr
    skill: code-review-assistant
    command: create-fix-branch
    condition: "{{steps.suggest_fixes.output.has_fixes}}"
    args:
      repo_path: "/tmp/repos/{{event.repository.name}}"
      issue_id: "{{event.pull_request.number}}"
      fix_code: "{{steps.suggest_fixes.output.fixed_code}}"
      fix_description: "Auto-fix code review issues"
```

### 第四步：配置审查规则

```yaml
# ~/.openclaw/config.yaml
code_review:
  enabled: true
  auto_review: true
  rules:
    # 代码风格
    style:
      max_line_length: 100
      require_docstrings: true
      naming_conventions:
        python: "snake_case"
        javascript: "camelCase"

    # 复杂度
    complexity:
      max_function_lines: 50
      max_cyclomatic_complexity: 10
      max_cognitive_complexity: 15

    # 安全
    security:
      check_sql_injection: true
      check_xss: true
      check_secrets: true
      banned_functions:
        python: ["eval", "exec", "pickle.loads"]
        javascript: ["eval", "Function", "setTimeout(string)"]

    # 性能
    performance:
      detect_n_plus_1: true
      detect_memory_leaks: true
      suggest_caching: true

  ignore_patterns:
    - "**/migrations/**"
    - "**/vendor/**"
    - "**/*.min.js"
    - "**/test_*.py"

  notification:
    on_blocking_issue: true
    channel: "slack"
    channel_id: "#code-reviews"
```

## 实际案例

### 案例一：Python 项目代码审查

开发团队使用 OpenClaw 自动审查 Python 代码：

```yaml
# PR 触发审查
input:
  repository: "company/project-api"
  pr_number: 234
  changed_files:
    - "src/services/user_service.py"
    - "src/models/user.py"
    - "tests/test_user_service.py"

# 审查结果示例
steps:
  ai_code_review:
    output: |
      文件：src/services/user_service.py

      问题 1（严重程度：error）：
      - 位置：第 45 行
      - 问题：SQL 注入风险
      - 代码：query = f"SELECT * FROM users WHERE id = {user_id}"
      - 建议：使用参数化查询
      - 修复：
        ```python
        query = "SELECT * FROM users WHERE id = %s"
        cursor.execute(query, (user_id,))
        ```

      问题 2（严重程度：warning）：
      - 位置：第 78-120 行
      - 问题：函数过长（43行），建议拆分
      - 建议：将验证逻辑、数据库操作、响应构建拆分为独立函数

      问题 3（严重程度：info）：
      - 位置：第 15 行
      - 问题：缺少函数文档字符串
      - 建议：添加 docstring 说明函数用途、参数、返回值

      值得肯定：
      - 良好的异常处理
      - 适当的日志记录
      - 测试覆盖率较高

  consolidate_review:
    output: |
      ## 代码审查报告

      **总体评价**：需要修改（发现阻塞性问题）

      **问题统计**：
      - 错误：1个（安全问题）
      - 警告：2个
      - 建议：3个

      **必须修复**：
      1. SQL 注入漏洞（第45行）- 安全风险

      **建议修复**：
      1. 拆分过长函数
      2. 补充文档字符串
      3. 优化导入顺序

      **修复后请重新提交审查。**
```

### 案例二：Bug 自动修复

系统检测到常见 Bug 模式，自动生成修复：

```yaml
name: auto-bug-fix

triggers:
  - type: schedule
    cron: "0 2 * * *"  # 每天凌晨2点

steps:
  - name: scan_codebase
    skill: code-review-assistant
    command: run-linter
    args:
      repo_path: "{{repo.path}}"
      check_all: true

  - name: identify_fixable_issues
    agent: code-reviewer
    prompt: |
      分析以下代码问题，识别可以自动修复的问题：
      {{steps.scan_codebase.output}}

      可自动修复的问题类型：
      - 代码格式问题
      - 未使用的导入
      - 简单的命名规范问题
      - 明显的语法改进

  - name: generate_fixes
    agent: code-reviewer
    loop:
      over: "{{steps.identify_fixable_issues.output.auto_fixable}}"
    prompt: |
      为以下问题生成修复代码：
      文件：{{item.file}}
      问题：{{item.message}}
      当前代码：
      ```{{language}}
      {{item.code_snippet}}
      ```

      请提供修复后的代码。

  - name: apply_fixes
    skill: code-review-assistant
    command: create-fix-branch
    args:
      repo_path: "{{repo.path}}"
      issue_id: "auto-fix-{{date}}"
      fix_code: "{{steps.generate_fixes.output}}"
      fix_description: "Automated code style fixes"

  - name: create_pr
    skill: github
    command: create-pull-request
    args:
      title: "[Auto] Code style fixes"
      body: |
        此 PR 包含自动修复的代码风格问题：
        {{steps.identify_fixable_issues.output.summary}}

        请审查后合并。
      base: "main"
      head: "fix/auto-fix-{{date}}"
```

### 案例三：安全漏洞扫描

安全团队使用 OpenClaw 进行自动化安全审查：

```yaml
name: security-scan

triggers:
  - type: webhook
    path: "/github/pull-request"
  - type: schedule
    cron: "0 0 * * *"  # 每天扫描

steps:
  - name: run_security_checks
    skill: code-review-assistant
    command: run-security-scan
    args:
      repo_path: "{{repo.path}}"
      scan_type: "full"

  - name: analyze_vulnerabilities
    agent: security-analyst
    prompt: |
      分析以下安全扫描结果：
      {{steps.run_security_checks.output}}

      请评估：
      1. 漏洞严重程度（CVSS评分）
      2. 可利用性
      3. 影响范围
      4. 修复优先级
      5. 修复建议

  - name: notify_security_team
    skill: notification
    command: send
    condition: "{{steps.analyze_vulnerabilities.output.has_critical}}"
    args:
      channel: "slack"
      recipient: "#security-alerts"
      title: "🚨 发现严重安全漏洞"
      content: |
        仓库：{{repo.name}}
        漏洞数：{{steps.analyze_vulnerabilities.output.critical_count}} 严重

        详情：
        {{steps.analyze_vulnerabilities.output.critical_vulnerabilities}}

        请立即处理！

  - name: create_security_ticket
    skill: jira
    command: create-issue
    loop:
      over: "{{steps.analyze_vulnerabilities.output.vulnerabilities}}"
      condition: "{{item.severity in ['high', 'critical']}}"
    args:
      project: "SEC"
      issue_type: "Security Bug"
      summary: "[{{item.severity}}] {{item.title}}"
      description: |
        漏洞详情：
        {{item.description}}

        位置：{{item.file}}:{{item.line}}

        修复建议：
        {{item.remediation}}
```

## 进阶技巧

### 代码审查知识库

```yaml
- name: check_best_practices
  skill: knowledge-base
  command: query
  args:
    query: "{{code_pattern}} best practices {{language}}"

- name: suggest_pattern
  agent: code-reviewer
  prompt: |
    基于以下代码和最佳实践，提供更优的实现方案：
    当前代码：{{current_code}}
    最佳实践：{{steps.check_best_practices.output}}

    请提供改进后的代码示例。
```

### 学习团队风格

```yaml
- name: analyze_team_patterns
  skill: code-review-assistant
  command: analyze-history
  args:
    repo: "{{repo.name}}"
    lookback: "90d"

- name: learn_preferences
  agent: code-reviewer
  prompt: |
    分析团队历史代码审查数据，学习审查偏好：
    {{steps.analyze_team_patterns.output}}

    请总结：
    1. 团队特别关注的问题类型
    2. 常用的代码模式
    3. 审查标准的严格程度
    4. 个人化的审查建议
```

通过这些配置，OpenClaw 可以成为你的智能代码审查助手，帮助团队保持高质量的代码标准，同时减轻开发者的审查负担。
---
section_id: 10.4
title: 自动化测试
status: draft
target_words: 1500
word_count: 1580
---

# 自动化测试

软件测试是保证产品质量的关键环节，但传统的手动测试效率低下、覆盖面有限。自动化测试可以大幅提升测试效率和覆盖率，但编写和维护测试用例本身也是一项繁重的工作。OpenClaw 可以帮助我们构建一个智能测试助手，实现测试用例自动生成、测试执行自动化、测试结果智能分析等功能，让测试工作更加高效和智能化。

## 场景介绍

### 软件测试的挑战

1. **用例编写耗时**：编写全面的测试用例需要大量时间
2. **维护成本高**：代码变更后，测试用例需要同步更新
3. **覆盖率难保证**：难以确保所有代码路径都被测试到
4. **回归测试繁重**：每次发布前都需要执行大量回归测试
5. **问题定位困难**：测试失败后，定位根因耗时耗力

### OpenClaw 的解决方案

- **智能生成**：基于代码和需求自动生成测试用例
- **自动执行**：按需或定时自动执行测试套件
- **结果分析**：智能分析测试结果，识别真正的问题
- **回归优化**：基于代码变更智能选择需要执行的测试
- **报告生成**：自动生成测试报告和趋势分析

## 实现思路

智能测试系统的核心组件包括：

1. **测试生成器**：基于代码分析和AI生成测试用例
2. **测试执行器**：管理测试环境和执行测试
3. **结果分析器**：分析测试结果，过滤误报
4. **覆盖率追踪器**：监控代码覆盖率变化
5. **报告生成器**：生成测试报告和趋势分析

## 配置步骤

### 第一步：创建测试管理 Skill

```yaml
# ~/.openclaw/skills/testing/SKILL.md
---
name: testing-assistant
description: 自动化测试助手
commands:
  - name: generate-unit-tests
    description: 生成单元测试
    script: |
      # 使用 AI 生成测试代码
      python3 -c "
import ast
import json

# 解析源文件
with open('{{source_file}}', 'r') as f:
    tree = ast.parse(f.read())

# 提取函数和类
functions = []
for node in ast.walk(tree):
    if isinstance(node, ast.FunctionDef):
        functions.append({
            'name': node.name,
            'args': [arg.arg for arg in node.args.args],
            'docstring': ast.get_docstring(node)
        })

print(json.dumps(functions))
"

  - name: run-test-suite
    description: 执行测试套件
    script: |
      cd {{repo_path}}
      case "{{test_framework}}" in
        pytest)
          pytest {{test_path}} -v --json-report --json-report-file=/tmp/test-result.json
          ;;
        jest)
          jest {{test_path}} --json --outputFile=/tmp/test-result.json
          ;;
        go)
          go test {{test_path}} -json > /tmp/test-result.json
          ;;
      esac
      cat /tmp/test-result.json

  - name: check-coverage
    description: 检查代码覆盖率
    script: |
      cd {{repo_path}}
      case "{{language}}" in
        python)
          pytest --cov={{source_path}} --cov-report=json --cov-report=term
          ;;
        javascript)
          jest --coverage --coverageReporters=json
          ;;
      esac

  - name: update-test-case
    description: 更新测试用例
    script: |
      # 根据代码变更更新测试
      python3 -c "
import json

# 读取变更信息
changes = json.loads('''{{code_changes}}''')

# 识别受影响的测试
affected_tests = []
for change in changes:
    # 分析变更影响范围
    affected_tests.extend(find_related_tests(change))

print(json.dumps({'affected_tests': affected_tests}))
"
```

### 第二步：创建测试分析 Agent

```yaml
# ~/.openclaw/agents/test-analyst.yaml
name: test-analyst
description: 测试分析专家
system_prompt: |
  你是一位资深的测试工程师，擅长设计测试用例和分析测试结果。

  测试设计能力：
  1. 等价类划分
  2. 边界值分析
  3. 场景测试设计
  4. 异常路径覆盖
  5. 性能测试设计

  分析能力：
  1. 识别 flaky tests（不稳定测试）
  2. 分析失败根因
  3. 评估测试覆盖率
  4. 优化测试效率

  输出要求：
  - 测试用例要具体、可执行
  - 覆盖正常和异常场景
  - 包含预期结果和断言

  输出格式（JSON）：
  {
    "test_cases": [
      {
        "name": "测试名称",
        "description": "测试描述",
        "input": {"参数": "值"},
        "expected": "预期结果",
        "assertions": ["断言1", "断言2"]
      }
    ],
    "coverage_analysis": {"当前覆盖率": "80%", "建议补充": ["分支1", "分支2"]},
    "recommendations": ["改进建议"]
  }
```

### 第三步：编写测试工作流

```yaml
# ~/.openclaw/workflows/auto-testing.lobster
name: auto-testing
version: "1.0"

triggers:
  - type: webhook
    path: "/github/pull-request"
  - type: schedule
    cron: "0 2 * * *"  # 每天凌晨2点执行全量测试

steps:
  # 1. 分析代码变更
  - name: analyze_changes
    skill: git
    command: diff
    args:
      base: "{{event.pull_request.base.sha}}"
      head: "{{event.pull_request.head.sha}}"

  # 2. 识别受影响模块
  - name: identify_impact
    agent: test-analyst
    prompt: |
      分析以下代码变更，识别受影响的测试范围：
      {{steps.analyze_changes.output}}

      请提供：
      1. 需要重新运行的测试文件
      2. 建议新增的测试场景
      3. 可以跳过的无关测试

  # 3. 生成缺失的测试
  - name: generate_missing_tests
    agent: test-analyst
    condition: "{{steps.analyze_changes.output.has_new_code}}"
    prompt: |
      为以下新增代码生成单元测试：
      {{steps.analyze_changes.output.new_functions}}

      要求：
      1. 覆盖正常输入场景
      2. 覆盖边界条件
      3. 覆盖异常输入
      4. 每个函数至少3个测试用例

  # 4. 执行测试
  - name: run_tests
    skill: testing-assistant
    command: run-test-suite
    args:
      repo_path: "/tmp/repos/{{repo.name}}"
      test_path: "{{steps.identify_impact.output.affected_tests}}"
      test_framework: "{{repo.test_framework}}"

  # 5. 检查覆盖率
  - name: check_coverage
    skill: testing-assistant
    command: check-coverage
    args:
      repo_path: "/tmp/repos/{{repo.name}}"
      source_path: "{{repo.source_path}}"
      language: "{{repo.language}}"

  # 6. 分析测试结果
  - name: analyze_results
    agent: test-analyst
    prompt: |
      分析以下测试结果：
      测试输出：{{steps.run_tests.output}}
      覆盖率报告：{{steps.check_coverage.output}}

      请提供：
      1. 失败的测试及可能原因
      2. 识别 flaky tests
      3. 覆盖率缺口分析
      4. 改进建议

  # 7. 生成测试报告
  - name: generate_report
    skill: document
    command: generate-report
    args:
      template: "test-report"
      data:
        summary: "{{steps.analyze_results.output.summary}}"
        failures: "{{steps.analyze_results.output.failures}}"
        coverage: "{{steps.check_coverage.output}}"
        trends: "{{repo.test_history}}"

  # 8. 通知团队
  - name: notify_team
    skill: notification
    command: send
    args:
      channel: "{{user.preferences.notification_channel}}"
      title: "测试结果 - {{repo.name}}"
      content: |
        通过率：{{steps.analyze_results.output.pass_rate}}%
        覆盖率：{{steps.check_coverage.output.percentage}}%
        失败数：{{steps.analyze_results.output.failure_count}}

        {{steps.analyze_results.output.summary}}
```

### 第四步：配置测试策略

```yaml
# ~/.openclaw/config.yaml
testing:
  enabled: true
  strategies:
    - name: "PR 预合并测试"
      trigger: "pull_request"
      tests:
        - type: "unit"
          coverage_threshold: 80
        - type: "integration"
          scope: "affected_only"
      timeout: "10m"

    - name: "每日全量测试"
      trigger: "schedule"
      cron: "0 2 * * *"
      tests:
        - type: "unit"
        - type: "integration"
        - type: "e2e"
      timeout: "30m"

  coverage:
    thresholds:
      overall: 80
      new_code: 90
      critical_paths: 95

  flaky_test_detection:
    enabled: true
    retry_count: 3
    threshold: 0.1  # 失败率超过10%视为flaky

  notifications:
    on_failure: true
    on_coverage_drop: true
    channel: "slack"
    channel_id: "#test-results"
```

## 实际案例

### 案例一：API 接口测试自动生成

后端开发团队使用 OpenClaw 自动生成 API 测试：

```yaml
name: auto-api-testing

triggers:
  - type: webhook
    path: "/api/spec-updated"

steps:
  - name: parse_openapi
    skill: testing-assistant
    command: parse-spec
    args:
      spec_path: "{{input.openapi_file}}"

  - name: generate_api_tests
    agent: test-analyst
    prompt: |
      基于以下 OpenAPI 规范生成测试用例：
      {{steps.parse_openapi.output}}

      为每个端点生成：
      1. 正常请求测试（200 OK）
      2. 参数验证测试（400 Bad Request）
      3. 认证测试（401 Unauthorized）
      4. 权限测试（403 Forbidden）
      5. 边界值测试

  - name: create_test_files
    skill: testing-assistant
    command: generate-test-code
    args:
      test_cases: "{{steps.generate_api_tests.output}}"
      output_dir: "tests/api/"
      framework: "pytest"

  - name: run_api_tests
    skill: testing-assistant
    command: run-test-suite
    args:
      test_path: "tests/api/"
      test_framework: "pytest"
```

### 案例二：UI 自动化测试

前端团队使用 OpenClaw 维护 UI 测试：

```yaml
name: ui-testing

triggers:
  - type: schedule
    cron: "0 3 * * *"

steps:
  - name: crawl_ui
    skill: testing-assistant
    command: crawl-pages
    args:
      base_url: "{{app.url}}"
      max_depth: 2

  - name: identify_ui_changes
    skill: testing-assistant
    command: compare-screenshots
    args:
      baseline: "tests/ui/baseline/"
      current: "tests/ui/current/"

  - name: update_ui_tests
    agent: test-analyst
    condition: "{{steps.identify_ui_changes.output.has_changes}}"
    prompt: |
      UI 发生变化，请更新测试用例：
      变化区域：{{steps.identify_ui_changes.output.changed_areas}}

      请：
      1. 识别需要更新的选择器
      2. 建议新增的测试步骤
      3. 标记需要人工确认的变化

  - name: run_ui_tests
    skill: testing-assistant
    command: run-test-suite
    args:
      test_path: "tests/ui/"
      test_framework: "playwright"
```

### 案例三：性能回归测试

运维团队使用 OpenClaw 监控性能变化：

```yaml
name: performance-testing

triggers:
  - type: schedule
    cron: "0 4 * * 0"  # 每周日凌晨4点

steps:
  - name: run_load_test
    skill: testing-assistant
    command: run-k6
    args:
      script: "tests/performance/load.js"
      duration: "10m"
      vus: 100

  - name: compare_baseline
    skill: testing-assistant
    command: compare-results
    args:
      current: "{{steps.run_load_test.output}}"
      baseline: "{{repo.performance_baseline}}"

  - name: analyze_regression
    agent: test-analyst
    prompt: |
      分析性能测试结果：
      当前结果：{{steps.run_load_test.output}}
      基线对比：{{steps.compare_baseline.output}}

      识别：
      1. 性能退化超过10%的接口
      2. 响应时间异常波动
      3. 错误率变化
      4. 资源使用趋势

  - name: alert_if_regression
    skill: notification
    command: send
    condition: "{{steps.analyze_regression.output.has_regression}}"
    args:
      channel: "slack"
      recipient: "#performance-alerts"
      title: "性能回归警告"
      content: "{{steps.analyze_regression.output.regressions}}"
```

## 进阶技巧

### 智能测试选择

```yaml
- name: smart_test_selection
  agent: test-analyst
  prompt: |
    基于以下信息，智能选择需要执行的测试：
    代码变更：{{code_changes}}
    测试历史：{{test_execution_history}}
    代码依赖图：{{dependency_graph}}

    请提供：
    1. 必须执行的高优先级测试
    2. 建议执行的中优先级测试
    3. 可以跳过的低优先级测试
    4. 预估执行时间
```

### 测试数据生成

```yaml
- name: generate_test_data
  agent: test-analyst
  prompt: |
    为以下测试场景生成测试数据：
    场景：{{test_scenario}}
    数据要求：{{data_requirements}}

    请生成：
    1. 有效的测试数据（符合业务规则）
    2. 无效的测试数据（用于异常测试）
    3. 边界值数据
    4. 大数据量测试数据
```

通过这些配置，OpenClaw 可以成为你的智能测试助手，帮助团队建立高效、可靠的自动化测试体系。
---
section_id: 10.5
title: 系统监控与告警
status: draft
target_words: 1500
word_count: 1620
---

# 系统监控与告警

系统稳定性是业务连续性的基础。随着系统规模的增长，监控的复杂度也在不断增加：海量的监控指标、频繁的告警噪音、难以定位的根因。OpenClaw 可以帮助我们构建一个智能监控助手，实现异常自动检测、告警智能降噪、根因自动分析等功能，让运维工作更加高效和智能化。

## 场景介绍

### 系统监控的挑战

1. **指标爆炸**：微服务架构下，监控指标呈指数级增长
2. **告警疲劳**：大量低价值告警淹没真正重要的问题
3. **根因难定位**：故障往往涉及多个系统，定位耗时
4. **响应滞后**：人工响应无法满足高可用要求
5. **预测困难**：难以提前发现潜在问题

### OpenClaw 的解决方案

- **智能降噪**：过滤无效告警，聚合相关问题
- **异常检测**：基于AI自动识别异常模式
- **根因分析**：自动分析故障传播链，定位根因
- **预测告警**：提前预警潜在问题
- **自动响应**：对已知问题自动执行修复操作

## 实现思路

智能监控系统的核心组件包括：

1. **指标收集器**：从各类监控系统收集指标数据
2. **异常检测器**：使用机器学习识别异常模式
3. **告警处理器**：过滤、聚合、关联告警
4. **根因分析器**：分析故障传播路径
5. **自动响应器**：执行预定义的修复操作

## 配置步骤

### 第一步：创建监控集成 Skill

```yaml
# ~/.openclaw/skills/monitoring/SKILL.md
---
name: monitoring-assistant
description: 系统监控助手
commands:
  - name: fetch-metrics
    description: 获取监控指标
    script: |
      # 从 Prometheus 查询指标
      curl -s "http://{{prometheus_url}}/api/v1/query?query={{query}}&time={{timestamp}}" | \
        jq '.data.result | map({
          metric: .metric,
          value: .value[1]
        })'

  - name: fetch-logs
    description: 获取日志数据
    script: |
      # 从 Elasticsearch 查询日志
      curl -s -X POST "http://{{es_url}}/logs-*/_search" \
        -H "Content-Type: application/json" \
        -d '{
          "query": {
            "bool": {
              "must": [
                {"match": {"service": "{{service}}"}},
                {"range": {"@timestamp": {"gte": "{{start_time}}", "lte": "{{end_time}}"}}}
              ]
            }
          },
          "size": 100,
          "sort": [{"@timestamp": "desc"}]
        }' | jq '.hits.hits | map(._source)'

  - name: fetch-traces
    description: 获取链路追踪数据
    script: |
      # 从 Jaeger 查询追踪
      curl -s "http://{{jaeger_url}}/api/traces?service={{service}}&start={{start_time}}&end={{end_time}}&limit=100" | \
        jq '.data | map({
          traceID: .traceID,
          duration: .duration,
          spans: [.spans | map({operationName: .operationName, duration: .duration, tags: .tags})]
        })'

  - name: send-alert
    description: 发送告警通知
    script: |
      curl -s -X POST "{{webhook_url}}" \
        -H "Content-Type: application/json" \
        -d '{
          "title": "{{alert_title}}",
          "severity": "{{severity}}",
          "message": "{{alert_message}}",
          "metadata": {{metadata | to_json}}
        }'

  - name: execute-remediation
    description: 执行修复操作
    script: |
      # 执行修复脚本
      {{remediation_script}}
```

### 第二步：创建监控分析 Agent

```yaml
# ~/.openclaw/agents/monitoring-analyst.yaml
name: monitoring-analyst
description: 系统监控分析专家
system_prompt: |
  你是一位资深的SRE工程师，擅长系统监控、故障排查和性能优化。

  分析能力：
  1. 指标异常检测
  2. 日志模式识别
  3. 链路追踪分析
  4. 根因定位
  5. 容量规划

  告警处理原则：
  - 区分症状和根因
  - 识别告警关联性
  - 评估业务影响
  - 提供可操作的建议

  输出格式（JSON）：
  {
    "anomaly_detected": true,
    "severity": "critical|high|medium|low",
    "affected_services": ["service1", "service2"],
    "root_cause_analysis": "根因分析",
    "impact_assessment": "影响评估",
    "recommended_actions": ["建议操作1", "建议操作2"],
    "auto_remediation_possible": true,
    "confidence": 0.85
  }
```

### 第三步：编写监控工作流

```yaml
# ~/.openclaw/workflows/monitoring.lobster
name: monitoring
version: "1.0"

triggers:
  - type: webhook
    path: "/alertmanager/webhook"
  - type: schedule
    cron: "*/5 * * * *"  # 每5分钟检查一次

steps:
  # 1. 收集监控数据
  - name: collect_metrics
    skill: monitoring-assistant
    command: fetch-metrics
    args:
      prometheus_url: "{{config.prometheus_url}}"
      query: "{{input.alert.query}}"

  - name: collect_logs
    skill: monitoring-assistant
    command: fetch-logs
    args:
      es_url: "{{config.elasticsearch_url}}"
      service: "{{input.alert.service}}"
      start_time: "{{now | subtract: '30m' | format_timestamp}}"
      end_time: "{{now | format_timestamp}}"

  - name: collect_traces
    skill: monitoring-assistant
    command: fetch-traces
    args:
      jaeger_url: "{{config.jaeger_url}}"
      service: "{{input.alert.service}}"
      start_time: "{{now | subtract: '30m' | format_timestamp}}"
      end_time: "{{now | format_timestamp}}"

  # 2. 分析异常
  - name: analyze_anomaly
    agent: monitoring-analyst
    prompt: |
      分析以下监控数据，识别异常和根因：

      告警信息：
      {{input.alert}}

      指标数据：
      {{steps.collect_metrics.output}}

      相关日志：
      {{steps.collect_logs.output}}

      链路追踪：
      {{steps.collect_traces.output}}

      历史模式：
      {{monitoring.history_patterns}}

      请提供详细的分析报告。

  # 3. 检查告警关联性
  - name: check_correlation
    skill: monitoring-assistant
    command: query-active-alerts
    args:
      time_window: "15m"

  - name: correlate_alerts
    agent: monitoring-analyst
    prompt: |
      分析当前告警与以下活跃告警的关联性：
      当前告警：{{input.alert}}
      活跃告警：{{steps.check_correlation.output}}

      识别：
      1. 是否同一根因导致
      2. 告警传播路径
      3. 主告警和衍生告警

  # 4. 评估自动修复可行性
  - name: assess_auto_remediation
    agent: monitoring-analyst
    prompt: |
      基于以下分析结果，评估自动修复可行性：
      {{steps.analyze_anomaly.output}}

      已知修复方案：
      {{remediation.playbooks}}

      请判断：
      1. 是否匹配已知问题模式
      2. 自动修复的风险评估
      3. 建议的操作

  # 5. 执行自动修复（如可行）
  - name: auto_remediate
    skill: monitoring-assistant
    command: execute-remediation
    condition: "{{steps.assess_auto_remediation.output.auto_remediation_safe}}"
    args:
      remediation_script: "{{steps.assess_auto_remediation.output.recommended_script}}"

  # 6. 发送智能告警
  - name: send_smart_alert
    skill: monitoring-assistant
    command: send-alert
    args:
      webhook_url: "{{config.alert_webhook}}"
      alert_title: "[{{steps.analyze_anomaly.output.severity}}] {{input.alert.title}}"
      severity: "{{steps.analyze_anomaly.output.severity}}"
      alert_message: |
        ## 异常摘要
        {{steps.analyze_anomaly.output.summary}}

        ## 根因分析
        {{steps.analyze_anomaly.output.root_cause_analysis}}

        ## 影响范围
        {{steps.analyze_anomaly.output.impact_assessment}}

        ## 建议操作
        {{steps.analyze_anomaly.output.recommended_actions}}

        {% if steps.auto_remediate.status == 'executed' %}
        ## 自动修复
        已执行自动修复：{{steps.auto_remediate.output.result}}
        {% endif %}
      metadata:
        alert_id: "{{input.alert.id}}"
        correlation_group: "{{steps.correlate_alerts.output.group_id}}"
        confidence: "{{steps.analyze_anomaly.output.confidence}}"

  # 7. 记录事件
  - name: record_incident
    skill: monitoring-assistant
    command: create-incident
    condition: "{{steps.analyze_anomaly.output.severity in ['critical', 'high']}}"
    args:
      title: "{{input.alert.title}}"
      severity: "{{steps.analyze_anomaly.output.severity}}"
      analysis: "{{steps.analyze_anomaly.output}}"
      affected_services: "{{steps.analyze_anomaly.output.affected_services}}"
```

### 第四步：配置监控策略

```yaml
# ~/.openclaw/config.yaml
monitoring:
  data_sources:
    prometheus:
      url: "http://prometheus:9090"
    elasticsearch:
      url: "http://elasticsearch:9200"
    jaeger:
      url: "http://jaeger:16686"

  anomaly_detection:
    enabled: true
    algorithms:
      - name: "statistical"
        threshold: 3  # 3-sigma
      - name: "seasonal"
        period: "1d"  # 日周期
      - name: "trend"
        sensitivity: 0.1

  alert_processing:
    deduplication_window: "15m"
    correlation_window: "30m"
    suppression_rules:
      - name: "maintenance_window"
        condition: "{{now | is_maintenance_window}}"
        action: "suppress"
      - name: "flapping"
        condition: "{{alert.count_15m > 3}}"
        action: "throttle"

  auto_remediation:
    enabled: true
    playbooks:
      - name: "restart_service"
        condition: "{{alert.name == 'service_down' and alert.duration > 2m}}"
        action: "kubectl rollout restart deployment/{{service}}"
        approval_required: false
      - name: "scale_up"
        condition: "{{alert.name == 'high_cpu' and alert.value > 90}}"
        action: "kubectl scale deployment/{{service}} --replicas={{current + 2}}"
        approval_required: true

  notifications:
    critical:
      channels: ["pagerduty", "slack", "sms"]
      escalation: "5m"
    high:
      channels: ["slack", "email"]
    medium:
      channels: ["slack"]
    low:
      channels: []
      digest: "daily"
```

## 实际案例

### 案例一：智能告警降噪

运维团队使用 OpenClaw 处理告警风暴：

```yaml
# 告警风暴场景
input:
  alerts:
    - name: "api_gateway_high_latency"
      service: "api-gateway"
      severity: "critical"
    - name: "auth_service_timeout"
      service: "auth-service"
      severity: "critical"
    - name: "user_db_connection_slow"
      service: "user-db"
      severity: "high"
    - name: "cache_hit_rate_low"
      service: "redis-cache"
      severity: "medium"

# 工作流执行结果
steps:
  correlate_alerts:
    output: |
      告警关联分析：

      识别到相关告警组：
      - 根因：user-db 连接池耗尽
      - 影响路径：
        user-db (慢查询)
          → auth-service (认证超时)
            → api-gateway (高延迟)
      - 衍生告警：cache_hit_rate_low (缓存穿透)

      建议：
      1. 优先处理 user-db 连接池问题
      2. 临时扩容 auth-service
      3. 其他告警可暂缓处理

  send_smart_alert:
    output: |
      发送聚合告警（替代4条独立告警）：

      标题：[CRITICAL] 数据库连接池耗尽导致服务链延迟

      根因：user-db 连接池耗尽（当前连接数：100/100）
      影响：auth-service、api-gateway 响应延迟
      建议：立即检查慢查询，临时扩容连接池
```

### 案例二：异常预测

SRE 团队使用 OpenClaw 提前发现潜在问题：

```yaml
name: predictive-monitoring

triggers:
  - type: schedule
    cron: "0 */6 * * *"  # 每6小时分析一次

steps:
  - name: fetch_historical_metrics
    skill: monitoring-assistant
    command: fetch-metrics
    args:
      query: |
        rate(http_requests_total[5m])
        / ignoring(instance) group_left
        avg_over_time(http_requests_total[1d])

  - name: detect_patterns
    agent: monitoring-analyst
    prompt: |
      分析以下历史指标，识别潜在风险：
      {{steps.fetch_historical_metrics.output}}

      请识别：
      1. 资源使用趋势（增长/下降/波动）
      2. 异常模式（周期性、突发性）
      3. 容量瓶颈预警
      4. 预测未来7天的问题

  - name: generate_predictions
    agent: monitoring-analyst
    prompt: |
      基于趋势分析，生成预测报告：
      {{steps.detect_patterns.output}}

      请提供：
      1. 预计何时达到容量上限
      2. 建议的扩容时间点
      3. 成本优化建议

  - name: send_prediction_report
    skill: notification
    command: send
    args:
      channel: "email"
      to: "sre@company.com"
      title: "容量预测报告 - {{date}}"
      content: "{{steps.generate_predictions.output}}"
```

### 案例三：故障自动恢复

系统使用 OpenClaw 自动处理常见故障：

```yaml
name: auto-recovery

triggers:
  - type: webhook
    path: "/alert/auto-recovery"

steps:
  - name: classify_issue
    agent: monitoring-analyst
    prompt: |
      分类以下故障类型：
      {{input.alert}}

      匹配已知故障模式：
      {{recovery.playbooks}}

  - name: execute_recovery
    skill: monitoring-assistant
    command: execute-remediation
    condition: "{{steps.classify_issue.output.match_found}}"
    args:
      remediation_script: "{{steps.classify_issue.output.playbook.action}}"

  - name: verify_recovery
    skill: monitoring-assistant
    command: fetch-metrics
    args:
      query: "{{input.alert.metric}}"
      wait_for: "{{steps.classify_issue.output.playbook.verify_condition}}"
      timeout: "5m"

  - name: notify_result
    skill: notification
    command: send
    args:
      channel: "slack"
      recipient: "#sre-alerts"
      title: "自动恢复{{steps.verify_recovery.output.success ? '成功' : '失败'}}"
      content: |
        故障：{{input.alert.name}}
        服务：{{input.alert.service}}
        执行操作：{{steps.classify_issue.output.playbook.name}}
        恢复结果：{{steps.verify_recovery.output.result}}

        {% if not steps.verify_recovery.output.success %}
        需要人工介入！
        {% endif %}
```

## 进阶技巧

### 混沌工程集成

```yaml
- name: chaos_experiment
  skill: monitoring-assistant
  command: run-chaos
  args:
    experiment: "pod-failure"
    target: "{{service}}"
    duration: "10m"

- name: monitor_resilience
  agent: monitoring-analyst
  prompt: |
    监控混沌实验期间的系统表现：
    实验：{{steps.chaos_experiment.output}}
    指标：{{metrics.during_experiment}}

    评估系统的韧性表现。
```

### 成本优化分析

```yaml
- name: analyze_resource_usage
  skill: monitoring-assistant
  command: fetch-metrics
  args:
    query: "container_resource_usage"

- name: identify_optimization
  agent: monitoring-analyst
  prompt: |
    分析资源使用数据，识别优化机会：
    {{steps.analyze_resource_usage.output}}

    请识别：
    1. 资源利用率过低的服务
    2. 过度配置的资源
    3. 可优化的成本点
```

通过这些配置，OpenClaw 可以成为你的智能监控助手，帮助团队实现更高效、更智能的运维管理。
---
section_id: 10.6
title: 智能客服与自动回复
status: draft
target_words: 1500
word_count: 1650
---

# 智能客服与自动回复

客户服务是企业与客户建立长期关系的重要环节，但传统的人工客服面临成本高、响应慢、服务时间受限等问题。OpenClaw 可以帮助我们构建一个智能客服助手，实现常见问题自动回复、复杂问题智能分配、服务质量自动评估等功能，在降低成本的同时提升客户满意度。

## 场景介绍

### 客户服务的挑战

1. **重复性问题多**：大量咨询是常见问题，消耗人工资源
2. **响应时间要求高**：客户期望即时响应，人工难以满足
3. **服务时间受限**：人工客服无法提供7x24小时服务
4. **服务质量难保证**：不同客服人员的回答质量参差不齐
5. **知识更新滞后**：产品更新后，客服知识库难以及时同步

### OpenClaw 的解决方案

- **智能问答**：基于知识库自动回答常见问题
- **意图识别**：准确理解客户问题，匹配合适的解决方案
- **智能路由**：将复杂问题分配给最合适的客服人员
- **多轮对话**：支持上下文理解，处理复杂咨询
- **质量监控**：自动评估服务质量，持续优化

## 实现思路

智能客服系统的核心组件包括：

1. **意图识别器**：理解客户问题的真实意图
2. **知识库检索器**：从知识库中检索相关信息
3. **回复生成器**：生成自然、准确的回复
4. **对话管理器**：维护对话上下文
5. **人工接管器**：在必要时转接人工客服

## 配置步骤

### 第一步：创建客服 Skill

```yaml
# ~/.openclaw/skills/customer-service/SKILL.md
---
name: customer-service-assistant
description: 智能客服助手
commands:
  - name: search-knowledge-base
    description: 搜索知识库
    script: |
      # 向量化查询并检索相关知识
      curl -s -X POST "{{vector_db_url}}/search" \
        -H "Content-Type: application/json" \
        -d '{
          "query": "{{query}}",
          "collection": "knowledge_base",
          "top_k": 5,
          "filter": {"category": "{{category}}"}
        }' | jq '.results | map({content: .content, score: .score, source: .metadata.source})'

  - name: classify-intent
    description: 分类客户意图
    script: |
      python3 -c "
import json

# 简单的意图分类逻辑
query = '{{query}}'.lower()
intents = {
    'refund': ['退款', '退货', '退钱', 'cancel order'],
    'shipping': ['物流', '快递', '发货', 'delivery', 'shipping'],
    'product_info': ['价格', '规格', '功能', 'price', 'spec'],
    'technical': ['bug', 'error', '问题', '故障', '无法使用'],
    'account': ['登录', '密码', '账号', 'login', 'password']
}

for intent, keywords in intents.items():
    if any(kw in query for kw in keywords):
        print(json.dumps({'intent': intent, 'confidence': 0.85}))
        exit()

print(json.dumps({'intent': 'general', 'confidence': 0.5}))
"

  - name: create-ticket
    description: 创建工单
    script: |
      curl -s -X POST "{{ticketing_api_url}}/tickets" \
        -H "Authorization: Bearer {{secrets.ticketing_token}}" \
        -H "Content-Type: application/json" \
        -d '{
          "subject": "{{subject}}",
          "description": "{{description}}",
          "customer_email": "{{customer_email}}",
          "priority": "{{priority}}",
          "category": "{{category}}",
          "tags": {{tags | to_json}}
        }' | jq '{id: .id, status: .status}'

  - name: send-message
    description: 发送消息
    script: |
      curl -s -X POST "{{channel_api_url}}/messages" \
        -H "Authorization: Bearer {{secrets.channel_token}}" \
        -H "Content-Type: application/json" \
        -d '{
          "conversation_id": "{{conversation_id}}",
          "content": "{{content}}",
          "type": "{{message_type}}",
          "metadata": {{metadata | to_json}}
        }'

  - name: escalate-to-human
    description: 转接人工
    script: |
      curl -s -X POST "{{routing_api_url}}/escalate" \
        -H "Authorization: Bearer {{secrets.routing_token}}" \
        -H "Content-Type: application/json" \
        -d '{
          "conversation_id": "{{conversation_id}}",
          "reason": "{{escalation_reason}}",
          "priority": "{{priority}}",
          "context": {{conversation_history | to_json}}
        }'
```

### 第二步：创建客服 Agent

```yaml
# ~/.openclaw/agents/customer-service.yaml
name: customer-service
description: 客服对话专家
system_prompt: |
  你是一位专业的客户服务代表，擅长解答客户问题并提供优质服务。

  服务原则：
  1. 礼貌友好，使用恰当的称呼
  2. 回答准确，基于事实和知识库
  3. 简洁明了，避免冗长
  4. 主动提供额外帮助
  5. 不确定时诚实告知，不编造信息

  回复策略：
  - 常见问题：直接给出答案
  - 复杂问题：分步骤解释
  - 情绪问题：先安抚情绪，再解决问题
  - 技术问题：提供详细的操作指引

  转人工标准：
  - 客户明确要求人工
  - 涉及退款/投诉等敏感问题
  - 连续3次无法理解客户意图
  - 客户情绪极度不满

  输出格式（JSON）：
  {
    "response": "回复内容",
    "requires_escalation": false,
    "escalation_reason": "",
    "suggested_actions": ["建议操作1"],
    "confidence": 0.9
  }
```

### 第三步：编写客服工作流

```yaml
# ~/.openclaw/workflows/customer-service.lobster
name: customer-service
version: "1.0"

triggers:
  - type: webhook
    path: "/customer-service/incoming"

steps:
  # 1. 识别客户意图
  - name: classify_intent
    skill: customer-service-assistant
    command: classify-intent
    args:
      query: "{{input.message}}"

  # 2. 检索知识库
  - name: search_knowledge
    skill: customer-service-assistant
    command: search-knowledge-base
    args:
      query: "{{input.message}}"
      category: "{{steps.classify_intent.output.intent}}"

  # 3. 获取对话上下文
  - name: get_context
    skill: database
    command: query
    args:
      sql: |
        SELECT * FROM conversations
        WHERE conversation_id = '{{input.conversation_id}}'
        ORDER BY timestamp DESC
        LIMIT 10

  # 4. 生成回复
  - name: generate_response
    agent: customer-service
    prompt: |
      请为客户生成回复：

      客户消息：{{input.message}}
      客户意图：{{steps.classify_intent.output.intent}}
      相关知识：{{steps.search_knowledge.output}}
      对话历史：{{steps.get_context.output}}
      客户信息：{{input.customer_profile}}

      请生成合适的回复。

  # 5. 判断是否需要转人工
  - name: check_escalation
    agent: customer-service
    condition: "{{steps.generate_response.output.requires_escalation}}"
    prompt: |
      评估是否需要转接人工客服：
      客户情绪：{{input.sentiment}}
      问题复杂度：{{steps.classify_intent.output.complexity}}
      历史交互：{{steps.get_context.output}}

      判断标准：
      - 客户明确要求人工
      - 涉及敏感操作（退款、投诉）
      - 连续无法解决问题
      - 客户情绪负面

  # 6. 转接人工（如需要）
  - name: escalate
    skill: customer-service-assistant
    command: escalate-to-human
    condition: "{{steps.check_escalation.output.should_escalate}}"
    args:
      conversation_id: "{{input.conversation_id}}"
      escalation_reason: "{{steps.check_escalation.output.reason}}"
      priority: "{{steps.check_escalation.output.priority}}"
      conversation_history: "{{steps.get_context.output}}"

  # 7. 发送自动回复
  - name: send_response
    skill: customer-service-assistant
    command: send-message
    condition: "{{not steps.check_escalation.output.should_escalate}}"
    args:
      conversation_id: "{{input.conversation_id}}"
      content: "{{steps.generate_response.output.response}}"
      message_type: "text"
      metadata:
        intent: "{{steps.classify_intent.output.intent}}"
        confidence: "{{steps.generate_response.output.confidence}}"

  # 8. 记录对话
  - name: log_conversation
    skill: database
    command: insert
    args:
      table: "conversations"
      data:
        conversation_id: "{{input.conversation_id}}"
        customer_id: "{{input.customer_id}}"
        message: "{{input.message}}"
        response: "{{steps.generate_response.output.response}}"
        intent: "{{steps.classify_intent.output.intent}}"
        escalated: "{{steps.check_escalation.output.should_escalate}}"
        timestamp: "{{now}}"

  # 9. 创建工单（如需要）
  - name: create_ticket
    skill: customer-service-assistant
    command: create-ticket
    condition: "{{steps.classify_intent.output.intent in ['refund', 'technical', 'complaint']}}"
    args:
      subject: "{{input.message | truncate: 50}}"
      description: "{{input.message}}"
      customer_email: "{{input.customer_email}}"
      priority: "{{steps.check_escalation.output.priority}}"
      category: "{{steps.classify_intent.output.intent}}"
      tags:
        - "auto-generated"
        - "{{steps.classify_intent.output.intent}}"
```

### 第四步：配置客服策略

```yaml
# ~/.openclaw/config.yaml
customer_service:
  channels:
    - type: "web_chat"
      enabled: true
    - type: "email"
      enabled: true
    - type: "wechat"
      enabled: true

  business_hours:
    timezone: "Asia/Shanghai"
    weekdays: "09:00-18:00"
    weekend: "10:00-17:00"

  auto_reply:
    enabled: true
    max_response_time: "30s"
    confidence_threshold: 0.7

  escalation_rules:
    - condition: "customer_explicitly_requests"
      action: "escalate_immediately"
    - condition: "sentiment_score < -0.5"
      action: "escalate_with_priority"
    - condition: "intent == 'complaint'"
      action: "escalate_to_manager"
    - condition: "consecutive_failures >= 3"
      action: "escalate_to_human"

  knowledge_base:
    update_interval: "24h"
    sources:
      - type: "faq"
        url: "https://docs.company.com/faq"
      - type: "product_docs"
        url: "https://docs.company.com/products"
      - type: "troubleshooting"
        url: "https://docs.company.com/troubleshooting"

  quality_metrics:
    track_response_time: true
    track_satisfaction: true
    track_resolution_rate: true
```

## 实际案例

### 案例一：电商客服自动化

电商平台使用 OpenClaw 处理客户咨询：

```yaml
# 客户咨询场景
input:
  conversation_id: "conv_12345"
  customer_id: "cust_67890"
  message: "我昨天下的订单什么时候能到？订单号是20240115001"
  channel: "web_chat"

# 工作流执行结果
steps:
  classify_intent:
    output:
      intent: "shipping_inquiry"
      confidence: 0.95

  search_knowledge:
    output:
      - content: "标准快递3-5个工作日，顺丰1-2个工作日"
        source: "shipping_policy"
      - content: "订单查询方式：登录账户-我的订单-查看物流"
        source: "help_center"

  generate_response:
    output: |
      回复内容：
      "您好！感谢您的咨询。

      关于订单20240115001的配送情况：
      - 您的订单已于昨日发货
      - 使用顺丰快递，预计1-2个工作日送达
      - 您可以通过以下链接实时追踪物流：[追踪链接]

      如有其他问题，请随时联系我们！"

      requires_escalation: false
      confidence: 0.92
```

### 案例二：技术支持自动化

SaaS 公司使用 OpenClaw 处理技术支持请求：

```yaml
name: tech-support-automation

triggers:
  - type: webhook
    path: "/support/ticket-created"

steps:
  - name: analyze_ticket
    agent: tech-support
    prompt: |
      分析以下技术支持工单：
      标题：{{input.ticket.subject}}
      描述：{{input.ticket.description}}
      客户等级：{{input.customer.tier}}

      请：
      1. 分类问题类型
      2. 评估紧急程度
      3. 检索相关解决方案

  - name: search_solutions
    skill: customer-service-assistant
    command: search-knowledge-base
    args:
      query: "{{input.ticket.description}}"
      category: "technical"

  - name: generate_solution
    agent: tech-support
    prompt: |
      基于以下信息生成解决方案：
      问题：{{input.ticket.description}}
      相关知识：{{steps.search_solutions.output}}
      类似案例：{{support.case_history}}

      请提供：
      1. 问题诊断步骤
      2. 解决方案
      3. 预防措施

  - name: auto_reply_if_confident
    skill: customer-service-assistant
    command: send-message
    condition: "{{steps.generate_solution.output.confidence > 0.8}}"
    args:
      ticket_id: "{{input.ticket.id}}"
      content: "{{steps.generate_solution.output.solution}}"

  - name: assign_to_engineer
    skill: customer-service-assistant
    command: create-ticket
    condition: "{{steps.generate_solution.output.confidence <= 0.8}}"
    args:
      subject: "[L{{steps.analyze_ticket.output.level}}] {{input.ticket.subject}}"
      assignee: "{{steps.analyze_ticket.output.suggested_engineer}}"
      priority: "{{steps.analyze_ticket.output.priority}}"
```

### 案例三：社交媒体自动回复

品牌使用 OpenClaw 管理社交媒体互动：

```yaml
name: social-media-auto-response

triggers:
  - type: webhook
    path: "/social/mention"

steps:
  - name: analyze_sentiment
    agent: sentiment-analyzer
    prompt: |
      分析以下社交媒体内容的情感倾向：
      平台：{{input.platform}}
      内容：{{input.content}}
      作者：{{input.author}}

      请评估：
      1. 情感极性（正面/负面/中性）
      2. 情感强度
      3. 是否需要人工介入

  - name: classify_mention_type
    agent: customer-service
    prompt: |
      分类以下提及的类型：
      {{input.content}}

      类型：
      - 产品咨询
      - 投诉反馈
      - 正面评价
      - 负面评价
      - 无关提及

  - name: generate_social_response
    agent: customer-service
    condition: "{{steps.analyze_sentiment.output.requires_response}}"
    prompt: |
      为以下社交媒体提及生成回复：
      平台：{{input.platform}}
      内容：{{input.content}}
      情感：{{steps.analyze_sentiment.output}}
      类型：{{steps.classify_mention_type.output}}

      要求：
      1. 符合平台调性
      2. 体现品牌个性
      3. 适当使用表情符号
      4. 控制字数

  - name: post_response
    skill: social-media
    command: post-reply
    condition: "{{steps.generate_social_response.output.approved}}"
    args:
      platform: "{{input.platform}}"
      post_id: "{{input.post_id}}"
      content: "{{steps.generate_social_response.output.response}}"

  - name: escalate_if_negative
    skill: notification
    command: send
    condition: "{{steps.analyze_sentiment.output.sentiment == 'negative' and steps.analyze_sentiment.output.intensity > 0.7}}"
    args:
      channel: "slack"
      recipient: "#social-media-alerts"
      title: "负面社交媒体提及"
      content: |
        平台：{{input.platform}}
        内容：{{input.content}}
        建议：立即人工介入
```

## 进阶技巧

### 多语言支持

```yaml
- name: detect_language
  skill: customer-service-assistant
  command: detect-language
  args:
    text: "{{input.message}}"

- name: translate_if_needed
  skill: translation
  command: translate
  condition: "{{steps.detect_language.output.language != 'zh'}}"
  args:
    text: "{{input.message}}"
    target_lang: "zh"

- name: generate_multilingual_response
  agent: customer-service
  prompt: |
    生成{{steps.detect_language.output.language}}语言的回复：
    {{translated_context}}
```

### 客户画像集成

```yaml
- name: fetch_customer_profile
  skill: crm
  command: get-customer
  args:
    customer_id: "{{input.customer_id}}"

- name: personalize_response
  agent: customer-service
  prompt: |
    基于客户画像生成个性化回复：
    客户等级：{{steps.fetch_customer_profile.output.tier}}
    历史订单：{{steps.fetch_customer_profile.output.order_history}}
    过往咨询：{{steps.fetch_customer_profile.output.support_history}}
    偏好：{{steps.fetch_customer_profile.output.preferences}}

    请调整回复语气和内容。
```

通过这些配置，OpenClaw 可以成为你的智能客服助手，帮助企业提供7x24小时的优质客户服务。
