# 第二部分：实战指南

---

# 安装前的准备

在开始安装OpenClaw之前，让我们先确保你的系统满足要求。

## 系统要求

### 操作系统

OpenClaw支持三大主流操作系统：

| 操作系统 | 支持版本 | 备注 |
|---------|---------|------|
| macOS | 12+ (Monterey) | 推荐Apple Silicon (M1/M2/M3) |
| Linux | Ubuntu 20.04+, Debian 11+, CentOS 8+ | 主流发行版均可 |
| Windows | Windows 10/11 + WSL2 | 不支持原生运行 |

重要提示：Windows用户必须通过WSL2运行OpenClaw，不能直接在Windows上安装。

### 运行环境

| 依赖 | 要求 | 说明 |
|-----|------|------|
| Node.js | ≥ 22 | 硬性要求，旧版本无法运行 |
| Git | 任意版本 | 用于插件安装 |
| Docker | 推荐 | 用于沙箱隔离（可选但强烈推荐） |

### 检查Node.js版本

```bash
# 检查Node.js版本
node --version

# 输出应该 ≥ v22.0.0
# 例如：v22.11.0
```

如果版本低于22，需要先升级Node.js：

```bash
# 使用nvm安装Node.js 22
nvm install 22
nvm use 22

# 或使用Homebrew (macOS)
brew install node@22
```

## 硬件配置

硬件需求取决于你是否使用本地模型。

### 基础配置（使用云端API）

如果你只使用云端API（如Claude、GPT-4），硬件要求很低：

| 配置项 | 最低要求 | 推荐配置 |
|-------|---------|---------|
| 内存 | 2GB | 4GB+ |
| CPU | 1核 | 2核+ |
| 存储 | 10GB SSD | 20GB SSD |

这意味着：
- 一台旧笔记本就能运行
- 树莓派5也可以
- 最便宜的云服务器（如2核4G）足够

### 进阶配置（使用本地模型）

如果你想在本地运行LLM（如Llama 3），硬件要求会显著提高：

| 模型大小 | 内存要求 | 推荐硬件 |
|---------|---------|---------|
| 8B参数 | 8-16GB | MacBook Air M2 16GB |
| 32B参数 | 32GB+ | MacBook Pro M3 36GB |
| 70B参数 | 64GB+ | Mac Studio 或 24GB+显存的GPU |

为什么Apple Silicon推荐？

Apple Silicon的统一内存架构让GPU和CPU共享内存，非常适合运行本地LLM。一台32GB的MacBook Pro可以流畅运行32B参数的模型，而同等能力的PC需要昂贵的独立显卡。

## Windows用户：WSL2配置

Windows用户需要先配置WSL2。这是一个一次性的设置过程。

### 安装WSL2

1. 以管理员身份打开PowerShell

2. 运行安装命令：

```powershell
wsl --install
```

这会自动安装Ubuntu发行版。

3. 重启电脑

4. 设置Ubuntu用户名和密码

### 验证WSL2

```bash
# 在Ubuntu终端中运行
uname -a
# 应该显示Linux相关输出

# 检查Node.js
node --version
# 如果没有安装，继续下一步
```

### 在WSL2中安装Node.js

```bash
# 使用nvm安装
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
source ~/.bashrc
nvm install 22
nvm use 22
```

### Windows用户的注意事项

1. 所有命令都在WSL2终端中执行，不是Windows的CMD或PowerShell
2. 文件路径不同：Windows的`C:\Users\xxx`在WSL2中是`/mnt/c/Users/xxx`
3. Docker Desktop需要启用WSL2集成

## Docker：可选但推荐

Docker用于运行沙箱环境，隔离不受信任的输入。

### 为什么需要Docker？

想象这个场景：有人在群聊中让OpenClaw执行`rm -rf /`命令。如果没有沙箱，这个命令会删除你的整个系统。

Docker沙箱会：
- 在隔离的容器中执行命令
- 限制文件系统访问
- 防止危险操作影响宿主机

### 安装Docker

macOS：
```bash
brew install --cask docker
```

Linux：
```bash
curl -fsSL https://get.docker.com | sh
sudo usermod -aG docker $USER
```

Windows：安装Docker Desktop并启用WSL2集成。

### 验证Docker

```bash
docker --version
# Docker version 24.0.0 或更高

docker run hello-world
# 应该输出 "Hello from Docker!"
```

## 网络环境

### 国内用户注意事项

如果你在中国大陆，可能需要配置网络代理：

```bash
# 设置npm代理
npm config set proxy http://127.0.0.1:7890
npm config set https-proxy http://127.0.0.1:7890

# 或使用国内镜像
npm config set registry https://registry.npmmirror.com
```

### API访问

使用云端AI模型需要稳定的国际网络连接。如果访问Claude或GPT API有问题，可以考虑：
- 使用国内模型（如通义千问、DeepSeek）
- 配置API代理
- 使用本地模型

## 准备工作清单

安装前，请确认：

- [ ] 操作系统满足要求
- [ ] Node.js ≥ 22 已安装
- [ ] Git已安装
- [ ] Docker已安装（推荐）
- [ ] 有一个AI模型的API Key（Claude/OpenAI/通义千问等）
- [ ] 网络环境可以访问所需服务

全部准备就绪？让我们开始安装。

---

**本节小结**

- 支持macOS 12+、主流Linux发行版、Windows 10/11 + WSL2
- Node.js ≥ 22是硬性要求
- 使用云端API时硬件要求低，本地模型需要更多内存
- Windows用户必须使用WSL2
- Docker用于沙箱隔离，强烈推荐安装
- 国内用户可能需要配置网络代理

---

# 三种安装方式

OpenClaw提供了三种安装方式，适合不同需求的用户。

## 方式一：一键安装脚本（推荐）

这是最简单的安装方式，适合大多数用户。

### macOS / Linux / WSL2

打开终端，运行：

```bash
curl -fsSL https://openclaw.ai/install.sh | bash
```

这个脚本会：
1. 检测你的Node.js版本
2. 如果版本过低或没有安装，自动安装Node.js 22
3. 全局安装OpenClaw CLI
4. 验证安装成功

### Windows PowerShell

```powershell
irm https://openclaw.ai/install.ps1 | iex
```

注意：这个脚本实际上会在WSL2中安装，所以你仍然需要先配置好WSL2。

### 安装过程演示

```
$ curl -fsSL https://openclaw.ai/install.sh | bash

检测系统环境...
✓ 操作系统: macOS (Darwin 24.0.0)
✓ Node.js: v22.11.0 (已安装)

安装 OpenClaw...
npm warn deprecated ...
✓ 安装完成

验证安装...
✓ openclaw version 1.0.0

安装成功！运行 'openclaw onboard' 开始配置。
```

## 方式二：NPM手动安装

如果你已经配置好Node.js环境，可以直接用npm安装：

```bash
npm install -g openclaw@latest
```

### 验证安装

```bash
openclaw --version
# 输出: 1.0.0 或更高版本

openclaw --help
# 显示所有可用命令
```

### 常见问题

**问题：npm install很慢**

解决：使用国内镜像
```bash
npm config set registry https://registry.npmmirror.com
npm install -g openclaw@latest
```

**问题：permission denied**

解决：使用sudo（不推荐）或修复npm权限
```bash
# 方案1：使用sudo
sudo npm install -g openclaw@latest

# 方案2：修复npm权限（推荐）
mkdir ~/.npm-global
npm config set prefix '~/.npm-global'
echo 'export PATH=~/.npm-global/bin:$PATH' >> ~/.bashrc
source ~/.bashrc
npm install -g openclaw@latest
```

**问题：command not found: openclaw**

解决：确保npm全局路径在PATH中
```bash
# 查看npm全局路径
npm config get prefix

# 添加到PATH（以输出为准）
export PATH="$(npm config get prefix)/bin:$PATH"
```

## 方式三：从源码安装

适合开发者或需要最新功能的用户。

### 克隆仓库

```bash
git clone https://github.com/openclaw/openclaw.git
cd openclaw
```

### 安装依赖

```bash
npm install
```

### 构建和链接

```bash
npm run build
npm link
```

### 验证

```bash
openclaw --version
```

### 源码安装的优势

- 获取最新的开发版本
- 可以本地调试和修改
- 可以贡献代码

### 源码安装的劣势

- 可能不稳定
- 需要手动更新
- 需要一定的开发知识

## 安装后初始化

无论使用哪种方式安装，接下来都需要运行初始化向导：

```bash
openclaw onboard --install-daemon
```

`--install-daemon`参数会将Gateway注册为系统服务，开机自启。

### 初始化向导步骤

#### 第一步：风险确认

```
╭──────────────────────────────────────────────────╮
│                                                  │
│  ⚠️  WARNING: RISK ACKNOWLEDGMENT                │
│                                                  │
│  OpenClaw has system-level access and can        │
│  execute commands on your computer.              │
│                                                  │
│  I understand this is powerful and inherently    │
│  risky. Continue?                                │
│                                                  │
│  > Yes                                           │
│    No                                            │
│                                                  │
╰──────────────────────────────────────────────────╯
```

选择Yes继续。

为什么要确认？

OpenClaw拥有系统级权限，可以：
- 读写你的文件
- 执行Shell命令
- 控制浏览器
- 发送邮件

这既是它的能力，也是风险所在。你需要知道自己在做什么。

#### 第二步：模式选择

```
╭──────────────────────────────────────────────────╮
│  Select onboarding mode:                         │
│                                                  │
│  > QuickStart (Recommended)                      │
│    Advanced                                      │
│                                                  │
╰──────────────────────────────────────────────────╯
```

QuickStart：快速启动，使用默认配置，适合新手
Advanced：高级模式，可以自定义所有配置

建议第一次安装选择QuickStart。

#### 第三步：模型配置

```
╭──────────────────────────────────────────────────╮
│  Select your AI model provider:                  │
│                                                  │
│  > Anthropic (Claude)                            │
│    OpenAI (GPT)                                  │
│    Google (Gemini)                               │
│    DeepSeek                                      │
│    Alibaba (Qwen)                                │
│    Local (Ollama)                                │
│    Skip for now                                  │
│                                                  │
╰──────────────────────────────────────────────────╯
```

选择你的AI模型提供商，然后输入API Key。

如果没有API Key？

选择Skip for now，稍后通过配置文件设置。

#### 第四步：渠道配置

```
╭──────────────────────────────────────────────────╮
│  Select messaging channels to configure:         │
│                                                  │
│  [ ] Telegram                                    │
│  [ ] WhatsApp                                    │
│  [ ] Discord                                     │
│  [ ] Slack                                       │
│  > Skip for now                                  │
│                                                  │
╰──────────────────────────────────────────────────╯
```

选择你想连接的消息平台。

建议：第一次可以跳过，先通过Web UI体验，稍后再配置。

#### 第五步：技能配置

```
╭──────────────────────────────────────────────────╮
│  Configure recommended skills?                   │
│                                                  │
│  > Yes, install recommended skills               │
│    No, I'll configure later                      │
│                                                  │
╰──────────────────────────────────────────────────╯
```

推荐安装基础技能，后续可以在ClawdHub安装更多。

#### 第六步：启动Web UI

```
╭──────────────────────────────────────────────────╮
│  Open Web Dashboard?                             │
│                                                  │
│  > Yes                                           │
│    No                                            │
│                                                  │
╰──────────────────────────────────────────────────╯
```

选择Yes，浏览器会自动打开`http://127.0.0.1:18789`。

## 验证安装

### 检查CLI

```bash
openclaw --version
openclaw status
```

### 检查Gateway

```bash
openclaw gateway status
```

应该输出：
```
Gateway is running
PID: 12345
Port: 18789
Uptime: 5 minutes
```

### 检查Web UI

打开浏览器访问`http://127.0.0.1:18789`，应该看到OpenClaw的Dashboard。

## 常用命令

安装完成后，你需要了解这些基本命令：

| 命令 | 功能 |
|-----|------|
| `openclaw start` | 启动服务 |
| `openclaw stop` | 停止服务 |
| `openclaw status` | 查看状态 |
| `openclaw gateway restart` | 重启Gateway |
| `openclaw config` | 打开配置文件 |
| `openclaw logs` | 查看日志 |

## 更新OpenClaw

### 使用npm更新

```bash
npm update -g openclaw@latest
```

### 使用安装脚本更新

```bash
curl -fsSL https://openclaw.ai/install.sh | bash
```

更新后记得重启服务：
```bash
openclaw gateway restart
```

## 卸载

如果需要卸载OpenClaw：

```bash
# 停止服务
openclaw stop

# 卸载npm包
npm uninstall -g openclaw

# 删除配置文件（可选）
rm -rf ~/.openclaw
```

---

**本节小结**

- 三种安装方式：一键脚本（推荐）、npm手动安装、源码安装
- 一键脚本最简单，自动处理所有依赖
- 安装后运行`openclaw onboard`进行初始化配置
- QuickStart模式适合新手，Advanced模式适合高级用户
- 常用命令：start、stop、status、restart
- 使用npm更新，更新后需要重启服务

---

# 配置Gateway和Agent

安装完成后，接下来是OpenClaw最重要的配置环节。理解配置文件结构，是掌握OpenClaw的关键。

## 配置文件位置

OpenClaw的核心配置文件位于：

```
~/.openclaw/openclaw.json
```

旧版本可能在 `~/.clawdbot/clawdbot.json`，新版已统一迁移。

### 查看和编辑配置

```bash
# 查看配置文件位置
openclaw config path

# 用编辑器打开配置文件
openclaw config

# 或直接用你喜欢的编辑器
code ~/.openclaw/openclaw.json
vim ~/.openclaw/openclaw.json
```

## 配置文件结构概览

```json
{
  "meta": { ... },        // 元信息
  "general": { ... },     // 通用设置
  "gateway": { ... },     // Gateway配置
  "agents": { ... },      // Agent配置
  "models": { ... },      // 模型配置
  "channels": { ... },    // 渠道配置
  "hooks": { ... }        // 钩子配置
}
```

下面我们逐个模块详细讲解。

## Gateway配置

Gateway是OpenClaw的核心，控制着整个系统的运行。

### 基本配置

```json
{
  "gateway": {
    "mode": "local",           // 运行模式：local 或 remote
    "bind": "loopback",        // 绑定地址
    "port": 18789,             // 监听端口
    "auth": {
      "mode": "token",
      "token": "your-secure-token"  // Web UI访问密码
    }
  }
}
```

### bind字段：重要的安全设置

| 值 | 含义 | 安全性 |
|---|------|--------|
| `loopback` | 仅本机访问（127.0.0.1） | 安全，推荐 |
| `lan` | 允许局域网访问（0.0.0.0） | 需配合防火墙 |

强烈建议：保持默认的 `loopback`，除非你明确需要局域网访问。

### Gateway命令

```bash
# 启动Gateway（后台服务）
openclaw gateway start

# 停止Gateway
openclaw gateway stop

# 重启Gateway
openclaw gateway restart

# 查看状态
openclaw gateway status

# 前台运行（调试用）
openclaw gateway --port 18789
```

### 启动参数

| 参数 | 说明 |
|-----|------|
| `--port <number>` | 覆盖默认端口 |
| `--bind <address>` | 覆盖绑定地址 |
| `--token <string>` | 覆盖认证Token |
| `--allow-unconfigured` | 允许未完全配置时启动 |

## Agent配置

Agent控制着AI助手的行为和能力。

### 基本配置

```json
{
  "agents": {
    "defaults": {
      "model": {
        "primary": "anthropic/claude-3-5-sonnet-20240620"
      },
      "workspace": "~/openclaw/workspace",
      "maxConcurrent": 4,
      "sandbox": {
        "mode": "non-main",
        "workspaceAccess": "ro"
      }
    }
  }
}
```

### workspace：工作目录

工作区存放Agent的记忆、技能和运行时数据：

```
~/openclaw/workspace/
├── MEMORY.md        // 长期记忆
├── SOUL.md          // 人设和性格
├── TOOLS.md         // 工具描述
└── skills/          // 技能目录
    ├── email/
    ├── calendar/
    └── ...
```

### sandbox：沙箱配置

沙箱是OpenClaw的重要安全特性，用于隔离不可信的输入。

```json
{
  "sandbox": {
    "mode": "non-main",           // 沙箱模式
    "image": "openclaw/sandbox:latest",
    "workspaceAccess": "ro",      // 工作区权限
    "allowedTools": ["bash", "read", "write", "python"],
    "deniedTools": ["browser", "gateway", "cron"],
    "docker": {
      "cpuShares": 512,
      "memory": "512m",
      "networkMode": "none"
    }
  }
}
```

**mode选项**：

| 值 | 说明 | 推荐场景 |
|---|------|----------|
| `non-main` | 非主会话在Docker中运行 | 推荐，平衡安全与便利 |
| `all` | 所有会话在Docker中运行 | 最安全，操作本机受限 |
| `off` | 关闭沙箱 | 不推荐 |

## 模型配置

OpenClaw支持多种AI模型，可以灵活配置和切换。

### 配置结构

```json
{
  "models": {
    "providers": {
      "anthropic": {
        "apiKey": "${ANTHROPIC_API_KEY}",
        "models": [
          { "id": "claude-3-5-sonnet-20240620", "name": "Claude 3.5 Sonnet" }
        ]
      },
      "openai": {
        "apiKey": "${OPENAI_API_KEY}",
        "models": [
          { "id": "gpt-4o-mini", "name": "GPT-4o Mini" }
        ]
      }
    }
  }
}
```

### API协议类型

OpenClaw支持两种主流API协议：

| 协议 | `api` 值 | 兼容服务 |
|-----|---------|---------|
| OpenAI | `openai-completions` | 硅基流动、DeepSeek、Moonshot、Ollama、vLLM等 |
| Anthropic | `anthropic-messages` | Anthropic、AWS Bedrock Claude等 |

> **重要**：大多数国内服务都兼容OpenAI协议，使用 `api: "openai-completions"` 即可。

### 支持的模型提供商

| 提供商 | 说明 | API协议 |
|-------|------|--------|
| Anthropic | Claude系列 | anthropic-messages |
| OpenAI | GPT系列 | openai-completions |
| Google | Gemini系列 | openai-completions |
| 硅基流动 | 多种开源模型 | openai-completions |
| DeepSeek | 国产推理模型 | openai-completions |
| 月之暗面 | Kimi系列 | openai-completions |
| 智谱AI | GLM系列 | openai-completions |
| 阿里云 | 通义千问 | openai-completions |
| 火山引擎 | 豆包系列 | openai-completions |
| Ollama | 本地模型 | openai-completions |

### 硅基流动（推荐）

硅基流动提供多种开源模型的API服务，性价比高，是国内用户的首选：

```json
{
  "env": { "SILICONFLOW_API_KEY": "sk-xxx..." },
  "agents": {
    "defaults": { "model": { "primary": "siliconflow/Qwen/Qwen2.5-72B-Instruct" } }
  },
  "models": {
    "providers": {
      "siliconflow": {
        "baseUrl": "https://api.siliconflow.cn/v1",
        "apiKey": "${SILICONFLOW_API_KEY}",
        "api": "openai-completions",
        "models": [
          { "id": "Qwen/Qwen2.5-72B-Instruct", "name": "通义千问 2.5 72B" },
          { "id": "deepseek-ai/DeepSeek-V3", "name": "DeepSeek V3" },
          { "id": "deepseek-ai/DeepSeek-R1", "name": "DeepSeek R1", "reasoning": true }
        ]
      }
    }
  }
}
```

### DeepSeek

DeepSeek官方API，支持最新的V3和R1推理模型：

```json
{
  "env": { "DEEPSEEK_API_KEY": "sk-xxx..." },
  "agents": {
    "defaults": { "model": { "primary": "deepseek/deepseek-chat" } }
  },
  "models": {
    "providers": {
      "deepseek": {
        "baseUrl": "https://api.deepseek.com/v1",
        "apiKey": "${DEEPSEEK_API_KEY}",
        "api": "openai-completions",
        "models": [
          { "id": "deepseek-chat", "name": "DeepSeek Chat" },
          { "id": "deepseek-reasoner", "name": "DeepSeek R1", "reasoning": true }
        ]
      }
    }
  }
}
```

### 月之暗面（Kimi）

超长上下文，适合处理大文档：

```json
{
  "env": { "MOONSHOT_API_KEY": "sk-xxx..." },
  "agents": {
    "defaults": { "model": { "primary": "moonshot/moonshot-v1-128k" } }
  },
  "models": {
    "providers": {
      "moonshot": {
        "baseUrl": "https://api.moonshot.cn/v1",
        "apiKey": "${MOONSHOT_API_KEY}",
        "api": "openai-completions",
        "models": [
          { "id": "moonshot-v1-8k", "name": "Moonshot 8K" },
          { "id": "moonshot-v1-32k", "name": "Moonshot 32K" },
          { "id": "moonshot-v1-128k", "name": "Moonshot 128K" }
        ]
      }
    }
  }
}
```

### 智谱AI（GLM）

```json
{
  "env": { "ZHIPU_API_KEY": "xxx..." },
  "agents": {
    "defaults": { "model": { "primary": "zhipu/glm-4-plus" } }
  },
  "models": {
    "providers": {
      "zhipu": {
        "baseUrl": "https://open.bigmodel.cn/api/paas/v4",
        "apiKey": "${ZHIPU_API_KEY}",
        "api": "openai-completions",
        "models": [
          { "id": "glm-4-plus", "name": "GLM-4 Plus" },
          { "id": "glm-4-flash", "name": "GLM-4 Flash" }
        ]
      }
    }
  }
}
```

### 通义千问（阿里云百炼）

```json
{
  "env": { "DASHSCOPE_API_KEY": "sk-xxx..." },
  "agents": {
    "defaults": { "model": { "primary": "dashscope/qwen-max" } }
  },
  "models": {
    "providers": {
      "dashscope": {
        "baseUrl": "https://dashscope.aliyuncs.com/compatible-mode/v1",
        "apiKey": "${DASHSCOPE_API_KEY}",
        "api": "openai-completions",
        "models": [
          { "id": "qwen-max", "name": "通义千问 Max" },
          { "id": "qwen-plus", "name": "通义千问 Plus" },
          { "id": "qwen-turbo", "name": "通义千问 Turbo" }
        ]
      }
    }
  }
}
```

### 火山引擎（豆包）

```json
{
  "env": { "VOLCENGINE_API_KEY": "your-api-key..." },
  "agents": {
    "defaults": { "model": { "primary": "volcengine/doubao-1-5-pro-32k-250115" } }
  },
  "models": {
    "providers": {
      "volcengine": {
        "baseUrl": "https://ark.cn-beijing.volces.com/api/v3",
        "apiKey": "${VOLCENGINE_API_KEY}",
        "api": "openai-completions",
        "models": [
          { "id": "doubao-1-5-pro-32k-250115", "name": "豆包 1.5 Pro 32K" },
          { "id": "doubao-1-5-lite-32k-250115", "name": "豆包 1.5 Lite 32K" }
        ]
      }
    }
  }
}
```

### 本地模型（Ollama）

Ollama是最简单的本地模型运行方式，OpenClaw可以自动发现本地Ollama中的模型：

```bash
# 安装Ollama
# macOS: brew install ollama
# Linux: curl -fsSL https://ollama.com/install.sh | sh

# 拉取模型
ollama pull llama3.3
ollama pull qwen2.5:32b

# 启动服务
ollama serve
```

最简配置：

```json
{
  "env": { "OLLAMA_API_KEY": "ollama-local" },
  "agents": {
    "defaults": { "model": { "primary": "ollama/llama3.3" } }
  }
}
```

> OpenClaw会自动发现本地Ollama中支持工具调用的模型。

手动配置（Ollama运行在非默认端口时）：

```json
{
  "models": {
    "providers": {
      "ollama": {
        "baseUrl": "http://192.168.1.100:11434/v1",
        "apiKey": "ollama-local",
        "api": "openai-completions",
        "models": [
          { "id": "llama3.3", "name": "Llama 3.3" },
          { "id": "qwen2.5:32b", "name": "Qwen 2.5 32B" }
        ]
      }
    }
  }
}
```

### 模型配置字段说明

| 字段 | 必填 | 说明 |
|-----|------|------|
| `baseUrl` | ✅ | API端点地址 |
| `apiKey` | ✅ | API密钥，支持 `${ENV_VAR}` 引用 |
| `api` | ✅ | API协议类型 |
| `models[].id` | ✅ | 模型ID（**不含provider前缀**） |
| `models[].name` | ❌ | 显示名称 |
| `models[].reasoning` | ❌ | 是否支持推理模式，默认false |
| `models[].contextWindow` | ❌ | 上下文窗口大小，默认200000 |

> ⚠️ **重要**：`models[].id` 字段只填写模型名称，**不要包含provider前缀**。
>
> - ✅ 正确：`"id": "qwen-max"`
> - ❌ 错误：`"id": "dashscope/qwen-max"`
>
> 系统会自动组合成完整引用（如 `dashscope/qwen-max`）。

### 模型别名配置

为常用模型设置别名，方便切换：

```json
{
  "agents": {
    "defaults": {
      "model": { "primary": "anthropic/claude-3-5-sonnet-20240620" },
      "models": {
        "anthropic/claude-3-5-sonnet-20240620": { "alias": "main" },
        "anthropic/claude-3-opus-20240229": { "alias": "smart" },
        "openai/gpt-4o-mini": { "alias": "fast" },
        "ollama/qwen2.5-coder:32b": { "alias": "local" }
      }
    }
  }
}
```

切换模型：`/model fast`、`/model local`

## Agent人设配置

通过工作区文件定义Agent的性格和行为。

### SOUL.md：人设定义

```markdown
# Agent人设

你是一个高效、专业的AI助手。

## 性格特点
- 直接、简洁
- 不啰嗦
- 主动提供解决方案

## 专业领域
- Python开发
- 系统运维
- 数据分析

## 工作风格
- 先理解问题，再行动
- 遇到不确定的，主动询问
- 完成后给出简洁总结
```

### MEMORY.md：长期记忆

Agent会自动维护这个文件，你也可以手动编辑：

```markdown
# 用户信息

## 个人偏好
- 偏好Python语言
- 使用VS Code编辑器
- 习惯中文沟通

## 工作背景
- 全栈开发者
- 主要项目：电商平台

## 重要事项
- [2024-01-15] 周五有重要会议
- [2024-01-10] 完成了订单模块的重构
```

## 环境变量配置

OpenClaw支持在配置文件中直接定义环境变量，无需额外创建文件。

### 在配置文件中定义

最新的配置方式是在 `openclaw.json` 的 `env` 字段中直接定义：

```json
{
  "env": {
    "ANTHROPIC_API_KEY": "sk-ant-xxx",
    "OPENAI_API_KEY": "sk-xxx",
    "SILICONFLOW_API_KEY": "sk-xxx",
    "DEEPSEEK_API_KEY": "sk-xxx",
    "DASHSCOPE_API_KEY": "sk-xxx"
  },
  "models": {
    "providers": {
      "siliconflow": {
        "baseUrl": "https://api.siliconflow.cn/v1",
        "apiKey": "${SILICONFLOW_API_KEY}",
        "api": "openai-completions",
        "models": [...]
      }
    }
  }
}
```

### 传统方式：env文件

也可以创建 `~/.openclaw/env` 文件：

```bash
# 国产模型API Keys
SILICONFLOW_API_KEY=sk-xxx
DEEPSEEK_API_KEY=sk-xxx
DASHSCOPE_API_KEY=sk-xxx
MOONSHOT_API_KEY=sk-xxx
ZHIPU_API_KEY=xxx

# 国际模型API Keys
ANTHROPIC_API_KEY=sk-ant-xxx
OPENAI_API_KEY=sk-xxx
```

### CLI命令管理

```bash
# 设置环境变量
openclaw config set env.SILICONFLOW_API_KEY "sk-xxx"

# 设置供应商配置
openclaw config set models.providers.siliconflow.baseUrl "https://api.siliconflow.cn/v1"
openclaw config set models.providers.siliconflow.apiKey "${SILICONFLOW_API_KEY}"
```

### 生效方式

修改环境变量后需要重启Gateway：

```bash
openclaw gateway restart
```

## 模型管理命令

### 查看模型

```bash
# 查看已配置的模型
openclaw models list

# 查看所有可用模型
openclaw models list --all

# 查看模型状态
openclaw models status
```

### 设置默认模型

```bash
# 设置主模型
openclaw models set deepseek/deepseek-chat

# 设置图像模型
openclaw models set-image openai/dall-e-3
```

### 管理回退模型

当主模型不可用时，自动切换到备用模型：

```bash
# 添加回退模型
openclaw models fallbacks add siliconflow/Qwen/Qwen2.5-72B-Instruct

# 查看回退列表
openclaw models fallbacks list

# 清空回退
openclaw models fallbacks clear
```

### 在聊天中切换模型

在Telegram/WhatsApp等渠道中：

```
/model              # 查看当前模型
/model list         # 列出可用模型
/model 1            # 选择第1个模型
/model deepseek/deepseek-chat  # 切换到指定模型
/model status       # 查看详细状态
```

## 配置验证

### 检查配置语法

```bash
openclaw config validate
```

### 查看当前配置

```bash
# 查看完整配置
openclaw config show

# 查看特定部分
openclaw config show gateway
openclaw config show models
```

## 常见配置问题

### 问题1：Gateway启动失败

检查端口是否被占用：
```bash
lsof -i :18789
```

### 问题2：模型调用失败

1. 检查API Key是否正确
2. 检查环境变量是否加载
3. 检查网络连接

### 问题3：配置不生效

1. 确认修改的是正确的配置文件
2. 重启Gateway
3. 清除缓存：`openclaw cache clear`

---

**本节小结**

- 配置文件位于 `~/.openclaw/openclaw.json`
- Gateway配置控制系统的运行方式
- Agent配置控制AI的行为和能力
- 沙箱配置是重要的安全特性
- 支持多种AI模型，可以灵活配置
- 使用环境变量保护敏感信息
- SOUL.md定义人设，MEMORY.md存储长期记忆

---

# 连接消息平台

OpenClaw的一大优势是支持多渠道接入。你可以在Telegram、WhatsApp、Discord、Slack等平台上使用同一个AI助手。

## 支持的平台

| 平台 | 支持程度 | 特点 |
|-----|---------|------|
| **Telegram** | 完善 | 最推荐，功能最全 |
| **WhatsApp** | 完善 | 用户量大，需扫码登录 |
| **Discord** | 完善 | 适合游戏/开发者社区 |
| **Slack** | 完善 | 适合企业场景 |
| **飞书** | 插件支持 | 需安装插件 |
| **钉钉** | 插件支持 | 需安装插件 |

## 通用概念：dmPolicy

在配置任何渠道之前，需要理解**dmPolicy（私信策略）**：

| 策略 | 说明 | 安全性 |
|-----|------|--------|
| `pairing` | 陌生人需输入配对码 | 推荐 |
| `allowlist` | 仅允许白名单用户 | 安全 |
| `open` | 允许所有人 | 危险 |

**强烈建议**：使用 `pairing` 或 `allowlist`，不要用 `open`。

## Telegram配置

Telegram是OpenClaw支持最完善的平台。

### 第一步：创建Bot

1. 打开Telegram，搜索 **@BotFather**
2. 发送 `/newbot`
3. 按提示设置Bot名称和用户名
4. 获得 **Bot Token**（格式：`123456789:ABCdefGHI...`）

### 第二步：获取你的User ID

1. 搜索 **@userinfobot**
2. 发送任意消息
3. 获得你的数字ID

### 第三步：配置

```json
{
  "channels": {
    "telegram": {
      "enabled": true,
      "botToken": "${TELEGRAM_BOT_TOKEN}",

      // 私信策略
      "dmPolicy": "pairing",

      // 白名单用户
      "allowFrom": [
        "123456789",
        "987654321"
      ],

      // 群组配置
      "groups": {
        "*": {
          "requireMention": true,
          "allowTools": false
        },
        "-1001234567890": {
          "requireMention": false,
          "mode": "auto"
        }
      }
    }
  }
}
```

### 群组配置说明

| 字段 | 说明 |
|-----|------|
| `requireMention` | 是否必须@机器人才能回复 |
| `allowTools` | 是否允许使用工具 |
| `mode` | `auto`=自动参与，`manual`=仅响应@ |

**建议**：
- 大群设置 `requireMention: true`，避免机器人刷屏
- 小群可以设置 `requireMention: false`

### DM Pairing流程

当陌生人给Bot发消息时：

```
陌生人: 你好
Bot: 🔐 配对请求已发送给管理员。
     请输入6位配对码以继续。

管理员收到通知:
📱 新用户 @stranger 请求配对
   [批准] [拒绝]

管理员批准后:
Bot: ✅ 配对成功！你现在可以使用我了。
```

## WhatsApp配置

WhatsApp不需要创建Bot，直接用你的账号。

### 配置

```json
{
  "channels": {
    "whatsapp": {
      "enabled": true,
      "dmPolicy": "allowlist",
      "allowFrom": ["8613800138000"]
    }
  }
}
```

### 登录

```bash
openclaw channels login whatsapp
```

会显示二维码，用WhatsApp扫码登录。

### 注意事项

- WhatsApp账号有被封禁的风险
- 不要发送过多消息
- 建议使用专门的号码

## Discord配置

### 第一步：创建应用

1. 访问 [Discord Developer Portal](https://discord.com/developers/applications)
2. 点击 **New Application**
3. 设置名称，创建应用

### 第二步：创建Bot

1. 左侧菜单选择 **Bot**
2. 点击 **Add Bot**
3. 复制 **Token**
4. **重要**：开启 **Message Content Intent**

### 第三步：邀请Bot

1. 左侧菜单选择 **OAuth2** > **URL Generator**
2. 勾选 **bot** 和 `applications.commands`
3. 选择权限：`Read Messages`、`Send Messages`、`Read Message History`
4. 复制生成的链接，在浏览器打开
5. 选择服务器，授权Bot

### 配置

```json
{
  "channels": {
    "discord": {
      "enabled": true,
      "token": "${DISCORD_BOT_TOKEN}",
      "applicationId": "123456789012345678",

      // 限制服务器
      "guilds": ["555555555555555555"],

      // 私信策略
      "dm": {
        "policy": "allowlist",
        "allowFrom": ["USER_ID_1"]
      },

      // 媒体限制
      "mediaMaxMb": 10,

      // 斜杠命令
      "commands": {
        "native": true
      }
    }
  }
}
```

### 注意事项

- 必须开启 **Message Content Intent**，否则Bot无法读取消息内容
- `guilds` 限制可以提高安全性

## Slack配置

Slack推荐使用 **Socket Mode**，无需公网IP。

### 第一步：创建Slack App

1. 访问 [Slack API](https://api.slack.com/apps)
2. 点击 **Create New App**
3. 选择 **From scratch**
4. 设置名称和Workspace

### 第二步：配置权限

在 **OAuth & Permissions** 中添加：

**Bot Token Scopes**：
- `app_mentions:read`
- `channels:history`
- `chat:write`
- `groups:history`
- `im:history`
- `mpim:history`

### 第三步：启用Socket Mode

1. 左侧选择 **Socket Mode**
2. 启用Socket Mode
3. 生成 **App-Level Token**（需要 `connections:write` 权限）
4. 复制生成的Token（以 `xapp-` 开头）

### 第四步：安装App

1. 左侧选择 **Install App**
2. 点击 **Install to Workspace**
3. 复制 **Bot User OAuth Token**（以 `xoxb-` 开头）

### 配置

```json
{
  "channels": {
    "slack": {
      "enabled": true,
      "mode": "socket",

      "botToken": "${SLACK_BOT_TOKEN}",
      "appToken": "${SLACK_APP_TOKEN}",

      "userTokenReadOnly": true,

      "groupPolicy": "allowlist",
      "channels": {
        "clawdbot-testing": {
          "allow": true,
          "requireMention": false
        }
      }
    }
  }
}
```

### 邀请Bot到频道

在Slack中，进入目标频道，输入 `/invite @YourBotName`

## 飞书/钉钉配置

这些平台需要通过插件支持。

### 安装插件

```bash
# 飞书
openclaw plugin install @openclaw/feishu

# 钉钉
openclaw plugin install @openclaw/dingtalk
```

### 配置

```json
{
  "channels": {
    "feishu": {
      "enabled": true,
      "appId": "${FEISHU_APP_ID}",
      "appSecret": "${FEISHU_APP_SECRET}",
      "connectionMode": "websocket"
    }
  }
}
```

**建议**：使用 `websocket` 模式，免去配置公网回调地址。

## 多渠道同时使用

OpenClaw支持同时配置多个渠道：

```json
{
  "channels": {
    "telegram": {
      "enabled": true,
      "botToken": "${TELEGRAM_BOT_TOKEN}",
      "dmPolicy": "pairing"
    },
    "discord": {
      "enabled": true,
      "token": "${DISCORD_BOT_TOKEN}"
    },
    "slack": {
      "enabled": true,
      "mode": "socket",
      "botToken": "${SLACK_BOT_TOKEN}",
      "appToken": "${SLACK_APP_TOKEN}"
    }
  }
}
```

所有渠道共享同一个Agent，记忆和技能也共享。

## 管理命令

```bash
# 查看渠道状态
openclaw channels status

# 登录渠道（WhatsApp等）
openclaw channels login whatsapp

# 登出渠道
openclaw channels logout whatsapp

# 重新加载配置
openclaw channels reload
```

## 渠道安全最佳实践

### 1. 使用环境变量

不要把Token写在JSON中：

```bash
# ~/.openclaw/env
TELEGRAM_BOT_TOKEN=xxx
DISCORD_BOT_TOKEN=xxx
```

### 2. 限制白名单

```json
{
  "dmPolicy": "allowlist",
  "allowFrom": ["123456789"]
}
```

### 3. 群组限制工具使用

```json
{
  "groups": {
    "*": {
      "allowTools": false
    }
  }
}
```

### 4. 启用沙箱

确保沙箱开启，防止恶意命令：

```json
{
  "agents": {
    "defaults": {
      "sandbox": {
        "mode": "non-main"
      }
    }
  }
}
```

---

**本节小结**

- 支持Telegram、WhatsApp、Discord、Slack等主流平台
- dmPolicy控制私信权限：推荐使用pairing
- Telegram配置最简单，功能最全
- Slack推荐使用Socket Mode，无需公网IP
- 飞书/钉钉通过插件支持
- 多渠道可同时使用，共享Agent记忆
- 注意安全：使用环境变量、限制白名单、启用沙箱

---

# 安全配置基础

OpenClaw拥有强大的系统权限——它可以读写你的文件、执行Shell命令、控制浏览器。这既是它的能力，也是风险所在。

**安全配置不是可选项，而是必须项。**

本章将介绍OpenClaw的多层安全防御机制。

## 安全设计原则

OpenClaw遵循**零信任**原则，采用多层防御：

```
┌─────────────────────────────────────────────────────┐
│                   第一层：网络安全                    │
│           Loopback-First + Tailscale                │
├─────────────────────────────────────────────────────┤
│                   第二层：访问控制                    │
│           DM Pairing + 白名单                        │
├─────────────────────────────────────────────────────┤
│                   第三层：执行隔离                    │
│           Docker沙箱 + 会话隔离                      │
├─────────────────────────────────────────────────────┤
│                   第四层：操作审批                    │
│           Approval Gates + 工具限制                  │
├─────────────────────────────────────────────────────┤
│                   第五层：数据保护                    │
│           环境变量 + 文件权限                         │
└─────────────────────────────────────────────────────┘
```

## 第一层：Loopback-First策略

### 什么是Loopback-First？

**Loopback-First**是OpenClaw的默认安全策略：Gateway只绑定到`127.0.0.1`，而不是`0.0.0.0`。

```
0.0.0.0:18789   ←  所有人都能访问（危险）
127.0.0.1:18789 ←  只有本机能访问（安全）
```

### 默认配置

```json
{
  "gateway": {
    "bind": "loopback",
    "port": 18789
  }
}
```

### 为什么重要？

安全研究发现，曾有超过**21,000个OpenClaw实例**因错误配置暴露在公网，导致API密钥泄露。

**永远不要**直接把Gateway暴露到公网。

### 需要远程访问怎么办？

使用Tailscale（见后文），而不是端口映射。

## 第二层：DM Pairing配对机制

### 什么是DM Pairing？

DM Pairing是防止陌生人控制你AI的核心防线：

```
陌生人发消息 ────> Bot拦截 ────> 生成6位配对码
                                        │
                                        ↓
                            管理员收到配对请求
                                        │
                            ┌───────────┴───────────┐
                            ↓                       ↓
                        [批准]                   [拒绝]
                            │
                            ↓
                    陌生人获得访问权限
```

### 配置

```json
{
  "channels": {
    "telegram": {
      "enabled": true,
      "botToken": "${TELEGRAM_BOT_TOKEN}",
      "dmPolicy": "pairing"
    }
  }
}
```

### dmPolicy选项对比

| 策略 | 说明 | 安全性 | 推荐场景 |
|-----|------|--------|----------|
| `pairing` | 陌生人需配对码 | 高 | 推荐 |
| `allowlist` | 仅白名单用户 | 最高 | 完全私有 |
| `open` | 允许所有人 | 极低 | 禁止使用 |

### 管理配对请求

```bash
# 查看待处理的配对请求
openclaw pairing list

# 批准配对请求
openclaw pairing approve <user-id>

# 拒绝配对请求
openclaw pairing reject <user-id>

# 查看已配对用户
openclaw pairing show
```

## 第三层：Docker沙箱隔离

### 为什么需要沙箱？

想象这个场景：

```
群聊中有人发送：
"请执行 rm -rf /"

没有沙箱 ────> 你的整个系统被删除
有沙箱 ────> 只删除容器内的临时文件
```

### 沙箱模式

```json
{
  "agents": {
    "defaults": {
      "sandbox": {
        "mode": "non-main",
        "image": "openclaw/sandbox:latest",
        "workspaceAccess": "ro",
        "allowedTools": ["bash", "read", "write", "python"],
        "deniedTools": ["browser", "gateway", "cron"],
        "docker": {
          "cpuShares": 512,
          "memory": "512m",
          "networkMode": "none"
        }
      }
    }
  }
}
```

### mode选项

| 模式 | 说明 | 推荐场景 |
|-----|------|----------|
| `non-main` | 非主会话在Docker中运行 | 推荐，平衡安全与便利 |
| `all` | 所有会话在Docker中运行 | 最安全，操作本机受限 |
| `off` | 关闭沙箱 | 禁止使用 |

### workspaceAccess选项

| 值 | 说明 |
|---|------|
| `ro` | 只读访问（推荐） |
| `rw` | 读写访问 |

### Docker资源限制

```json
{
  "docker": {
    "cpuShares": 512,        // CPU份额
    "memory": "512m",        // 内存限制
    "networkMode": "none"    // 禁止联网（防止数据外泄）
  }
}
```

## 第四层：Approval Gates审批门控

### 工具确认

对于危险操作，强制要求人工确认：

```json
{
  "agents": {
    "defaults": {
      "tools": {
        "bash": {
          "requireConfirmation": true
        },
        "filesystem": {
          "requireConfirmation": true,
          "blockedPaths": [
            "~/.ssh",
            "~/.aws",
            ".env",
            "*.key",
            "*.pem"
          ]
        }
      }
    }
  }
}
```

### 命令黑名单

```json
{
  "agents": {
    "defaults": {
      "tools": {
        "bash": {
          "blockedCommands": [
            "rm -rf /",
            "rm -rf ~",
            "sudo",
            "chmod 777",
            "mkfs",
            "dd if="
          ]
        }
      }
    }
  }
}
```

### 实际效果

```
Agent：我需要执行以下命令：
      rm -rf ~/Downloads/old-files

      [批准] [拒绝] [修改]
```

你必须在聊天窗口点击"批准"才会执行。

## 第五层：敏感信息保护

### 环境变量

不要把API Key写在配置文件中：

```bash
# ~/.openclaw/env
ANTHROPIC_API_KEY=sk-ant-xxx
OPENAI_API_KEY=sk-xxx
TELEGRAM_BOT_TOKEN=xxx
```

在配置中引用：

```json
{
  "models": {
    "providers": {
      "anthropic": {
        "apiKey": "${ANTHROPIC_API_KEY}"
      }
    }
  }
}
```

### 文件权限

```bash
# 设置配置目录权限（仅当前用户可访问）
chmod 700 ~/.openclaw
chmod 600 ~/.openclaw/env
chmod 600 ~/.openclaw/openclaw.json
```

### Token轮换

定期更换敏感凭证：

```bash
# 更换Gateway Token
openclaw gateway token rotate

# 更换API Key（手动更新env文件后重启）
openclaw gateway restart
```

## 远程访问：Tailscale集成

如果你需要从手机或其他设备访问OpenClaw，使用Tailscale而不是端口映射。

### 什么是Tailscale？

Tailscale是一个基于WireGuard的零配置VPN，可以安全地连接你的所有设备。

### 配置

```json
{
  "gateway": {
    "bind": "loopback",
    "tailscale": {
      "mode": "serve",
      "resetOnExit": false
    }
  }
}
```

### 模式说明

| 模式 | 说明 | 安全性 |
|-----|------|--------|
| `off` | 不使用Tailscale | - |
| `serve` | 仅Tailnet内访问 | 推荐 |
| `funnel` | 允许公网访问 | 需配合密码认证 |

### 使用步骤

1. 安装Tailscale：`brew install tailscale`（macOS）
2. 登录Tailscale账号
3. 配置OpenClaw启用Tailscale
4. 在其他设备安装Tailscale并登录同一账号
5. 访问 `http://你的机器名:18789`

## 会话隔离

### 多代理路由

OpenClaw支持多个隔离的Agent实例：

```
工作Slack ────> Agent A（工作区A、记忆A）
个人Telegram ────> Agent B（工作区B、记忆B）
```

### 群组配置

在群组中，建议限制AI的行为：

```json
{
  "channels": {
    "telegram": {
      "groups": {
        "*": {
          "requireMention": true,
          "allowTools": false
        }
      }
    }
  }
}
```

这样AI不会主动读取群里的所有消息，减少信息泄露风险。

## 安全检查清单

部署OpenClaw后，请逐一检查：

- [ ] `gateway.bind` 设为 `loopback`
- [ ] `dmPolicy` 设为 `pairing` 或 `allowlist`
- [ ] `sandbox.mode` 设为 `non-main`
- [ ] 高危工具开启 `requireConfirmation`
- [ ] API Key存储在环境变量中
- [ ] 配置文件权限设为600
- [ ] 群组设置 `requireMention: true`
- [ ] 需要远程访问时使用Tailscale

## 常见安全错误

### 错误1：dmPolicy设为open

```json
// 危险！
"dmPolicy": "open"
```

**后果**：任何人都可以控制你的AI，执行命令。

### 错误2：关闭沙箱

```json
// 危险！
"sandbox": {
  "mode": "off"
}
```

**后果**：群聊中的恶意指令可以破坏你的系统。

### 错误3：Gateway暴露到公网

```json
// 危险！
"bind": "lan"
```

配合路由器端口映射，直接暴露18789端口。

**后果**：全球任何人都可以访问你的Gateway。

### 错误4：API Key明文存储

```json
// 危险！
"apiKey": "sk-ant-api03-xxx"
```

**后果**：配置文件泄露导致API Key泄露。

---

**本节小结**

- OpenClaw采用五层安全防御：网络、访问、执行、审批、数据
- Loopback-First确保Gateway不暴露到公网
- DM Pairing防止陌生人控制你的AI
- Docker沙箱隔离危险操作
- Approval Gates为高危操作增加人工确认
- 使用环境变量保护敏感信息
- 远程访问使用Tailscale，而非端口映射
- 定期检查安全配置清单

---

## 第5章：ClawdHub技能生态

---

# 发现ClawdHub

如果说Gateway是OpenClaw的"身体"，Agent是"大脑"，那么**Skills**就是它的"技能"。而**ClawdHub**就是获取这些技能的 marketplace。

## 什么是ClawdHub？

**ClawdHub**是OpenClaw的官方技能市场，类似于：
- iPhone的App Store
- Python的PyPI
- Node.js的npm

它汇集了社区贡献的各种技能包，让你可以为OpenClaw安装新能力。

### ClawdHub的价值

```
没有Skills的OpenClaw：
- 只能对话
- 基本的文件操作
- 有限的系统命令

安装Skills后的OpenClaw：
- 发送邮件
- 管理日程
- 操作GitHub
- 控制智能家居
- 处理PDF
- ...500+种能力
```

## 访问ClawdHub

### 方式一：Web浏览器

访问 **clawdhub.com** 或从官网 openclaw.ai 跳转。

你可以浏览分类、搜索关键词、查看详情。

### 方式二：OpenClaw Dashboard

1. 打开 http://127.0.0.1:18789
2. 点击左侧 **Skills** 菜单
3. 浏览、搜索、一键安装

### 方式三：命令行

```bash
# 列出可用技能
openclaw skills list

# 搜索技能
openclaw skills search "email"

# 查看技能详情
openclaw skills info gmail-manager
```

### 方式四：自然语言搜索

直接在聊天中对AI说：

```
你：我想处理PDF文件，需要什么技能？
AI：让我搜索一下...
    找到以下技能：
    1. pdf-processor - PDF处理工具
    2. pdf-to-text - PDF转文本
    要安装哪个？
```

## 内置核心能力

OpenClaw安装后自带一些核心能力（Core Tools）：

| 工具 | 功能 |
|-----|------|
| **bash/exec** | 执行Shell命令 |
| **filesystem** | 读写文件、目录操作 |
| **browser** | 控制浏览器、网页抓取 |

这些是基础能力，更多高级功能需要安装Skills。

## 热门Skills分类

### 生产力

| Skill | 功能 |
|-------|------|
| `gmail-manager` | 邮件管理 |
| `google-calendar` | 日程管理 |
| `notion` | Notion笔记操作 |
| `obsidian` | Obsidian笔记操作 |

### 开发工具

| Skill | 功能 |
|-------|------|
| `github` | GitHub PR、Issue管理 |
| `gitlab` | GitLab集成 |
| `ci-cd-monitor` | CI/CD监控 |

### 信息获取

| Skill | 功能 |
|-------|------|
| `brave-search` | 联网搜索 |
| `weather` | 天气查询 |
| `stock-monitor` | 股票监控 |

### 智能家居

| Skill | 功能 |
|-------|------|
| `philips-hue` | 飞利浦智能灯 |
| `spotify` | Spotify控制 |
| `sonos` | Sonos音响 |

### 特殊兴趣

| Skill | 功能 |
|-------|------|
| `crypto-tracker` | 加密货币追踪 |
| `youtube-downloader` | YouTube下载 |
| `recipe-finder` | 食谱搜索 |

## Skill的结构

每个Skill是一个独立的包，通常包含：

```
skill-name/
├── SKILL.md        # 核心文件：提示词定义
├── package.json    # 元数据和依赖
├── index.ts        # TypeScript脚本（可选）
├── script.py       # Python脚本（可选）
├── HEARTBEAT.md    # 定时任务定义（可选）
└── MESSAGING.md    # 消息处理定义（可选）
```

### SKILL.md：技能的灵魂

这是最重要的文件，用自然语言告诉AI：

```markdown
# Gmail Manager

## 描述
当用户需要发送邮件或读取收件箱时，使用此技能。

## 触发条件
- 用户提到"邮件"、"email"、"gmail"
- 用户想"发送"、"读取"、"搜索"邮件

## 可用操作
- send_email: 发送邮件
- read_inbox: 读取收件箱
- search_emails: 搜索邮件
- mark_read: 标记已读

## 参数
- to: 收件人地址（必需）
- subject: 邮件主题
- body: 邮件正文
```

### 脚本文件

处理实际的API调用和操作：

```typescript
// index.ts
export async function sendEmail(params: EmailParams) {
  const response = await gmail.users.messages.send({
    userId: 'me',
    requestBody: {
      raw: createRawEmail(params)
    }
  });
  return response.data;
}
```

## URL直接安装

这是OpenClaw的一个很酷的特性。

如果有人分享了一个Skill的URL（如 `https://moltbook.com/skill.md`），你可以直接在聊天中发送这个URL：

```
你：https://moltbook.com/skills/weather.md

AI：检测到一个Skill URL，正在解析...
    名称：Weather Assistant
    描述：获取天气信息

    是否安装？[是] [否]
```

无需敲命令，一键安装。

## 社区生态

### 快速增长

ClawdHub生态发展迅猛：

- **500+** 社区贡献的Skills
- 覆盖各个领域
- 每周新增技能

### Moltbook：AI社交网络

**Moltbook**是一个完全基于Skill构建的"AI社交网络"。用户可以：
- 分享自己的Skill
- 发现他人创建的Skill
- 构建个人AI助手档案

### awesome-openclaw-skills

社区维护了一个精选仓库，收集优质Skill：

```bash
git clone https://github.com/community/awesome-openclaw-skills
```

## 安全警告

ClawdHub是一个开放的社区平台，**存在安全风险**。

### ClawHavoc事件

安全研究发现，ClawdHub上曾存在**341个恶意Skill**（占比超过10%）：

- 伪装成加密货币工具
- 伪装成YouTube下载器
- 实际包含恶意脚本（如Atomic macOS Stealer）
- 窃取SSH密钥、浏览器密码、钱包私钥

### 安全建议

安装Skill前，务必：

1. **检查来源**：谁开发的？有声誉吗？
2. **阅读代码**：检查SKILL.md和脚本内容
3. **查看评价**：其他用户的反馈
4. **沙箱测试**：先在沙箱环境中测试

**不要**随意安装来路不明的Skill，尤其是在存有敏感资产的电脑上。

## 发现Skills的技巧

### 按需搜索

不要一次性安装很多Skill，根据实际需求搜索：

```
你：我需要管理我的Google日历
AI：建议安装 google-calendar 技能
```

### 查看依赖

安装前查看Skill的依赖：

```bash
openclaw skills info google-calendar --deps
```

### 版本检查

安装最新版本：

```bash
openclaw skills install google-calendar@latest
```

---

**本节小结**

- ClawdHub是OpenClaw的技能市场，类似于App Store
- 可通过Web、Dashboard、CLI、自然语言搜索访问
- 内置核心能力：bash、filesystem、browser
- 500+社区Skills覆盖生产力、开发、家居等领域
- Skill核心是SKILL.md（提示词）+ 脚本文件
- 支持URL直接安装
- 注意安全：检查来源、阅读代码、沙箱测试

---

# 安装第一个Skill

让我们通过实际操作，安装你的第一个Skill。我们选择一个简单实用的技能：**天气查询**。

## 准备工作

在安装任何Skill之前，建议：

1. **确保Gateway运行**
```bash
openclaw gateway status
```

2. **更新ClawdHub索引**
```bash
openclaw skills update
```

3. **检查已安装的Skills**
```bash
openclaw skills list --installed
```

## 选择一个Skill

### 搜索

```bash
openclaw skills search weather
```

输出：
```
Found 5 skills matching "weather":

1. weather-assistant
   描述: 获取任意城市的天气信息
   作者: openclaw-official
   下载量: 12,345

2. weather-forecast
   描述: 7天天气预报
   作者: community-dev
   下载量: 3,456

3. weather-alerts
   描述: 极端天气预警
   作者: safety-team
   下载量: 1,234
```

### 查看详情

```bash
openclaw skills info weather-assistant
```

输出：
```
名称: weather-assistant
版本: 2.1.0
作者: openclaw-official
描述: 获取任意城市的实时天气信息

功能:
- 获取当前天气
- 获取未来3天预报
- 支持中英文城市名

依赖:
- 无

评分: ⭐ 4.8/5.0 (234 reviews)
```

## 安装方式

### 方式一：命令行安装（推荐）

```bash
openclaw skills install weather-assistant
```

输出：
```
📦 Installing weather-assistant@2.1.0...
✓ Downloading...
✓ Validating...
✓ Installing dependencies...
✓ Registering with Agent...

✅ Successfully installed weather-assistant!
   Run 'openclaw skills test weather-assistant' to verify.
```

### 方式二：Dashboard安装

1. 打开 http://127.0.0.1:18789
2. 点击 **Skills** > **Browse**
3. 搜索 "weather-assistant"
4. 点击 **Install** 按钮
5. 确认安装

### 方式三：自然语言安装

直接在聊天中说：

```
你：帮我安装天气查询技能
AI：搜索到 weather-assistant，这是一个天气查询技能。
    功能：获取任意城市的实时天气
    要安装吗？
你：是的
AI：✅ 已安装 weather-assistant
    你现在可以问我任何城市的天气了。
```

## 验证安装

### 检查安装状态

```bash
openclaw skills list --installed
```

输出：
```
Installed Skills:

✓ weather-assistant (2.1.0)
  安装时间: 2024-01-15 10:30
  状态: 活跃
```

### 测试Skill

```bash
openclaw skills test weather-assistant
```

输出：
```
Testing weather-assistant...

Test 1: 获取北京天气
✓ 通过

Test 2: 获取纽约天气
✓ 通过

All tests passed!
```

### 实际使用

现在你可以在聊天中使用这个技能了：

```
你：北京今天天气怎么样？
AI：让我查一下...
    北京今天：
    - 天气：晴
    - 温度：-2°C 到 8°C
    - 风力：北风3级
    - 空气质量：良

    建议穿厚外套出门。
```

## Skill配置

有些Skill需要配置，比如API Key或自定义参数。

### 查看配置选项

```bash
openclaw skills config weather-assistant --show
```

输出：
```
weather-assistant 配置选项:

temperature_unit:
  描述: 温度单位
  默认值: celsius
  选项: celsius, fahrenheit

language:
  描述: 返回语言
  默认值: zh-CN
  选项: zh-CN, en-US
```

### 设置配置

```bash
openclaw skills config weather-assistant set temperature_unit fahrenheit
```

或编辑配置文件：

```json
// ~/.openclaw/workspace/skills/weather-assistant/config.json
{
  "temperature_unit": "celsius",
  "language": "zh-CN"
}
```

## 安装更多Skills

让我们再安装几个常用的Skills：

### GitHub集成

```bash
openclaw skills install github
```

需要配置GitHub Token：

```bash
# 设置环境变量
echo "GITHUB_TOKEN=ghp_xxx" >> ~/.openclaw/env

# 重启Gateway
openclaw gateway restart
```

使用：

```
你：帮我查看 fangchen/openclaw-guide 仓库的最新Issue
AI：让我查一下...
    找到3个未关闭的Issue：
    1. #42 - 文档错别字修正
    2. #41 - 请求添加安装视频教程
    3. #40 - 兼容性问题报告
```

### 邮件管理

```bash
openclaw skills install gmail-manager
```

需要OAuth认证：

```bash
openclaw skills auth gmail-manager
```

会打开浏览器进行Google登录授权。

### 智能搜索

```bash
openclaw skills install brave-search
```

需要Brave Search API Key：

```bash
echo "BRAVE_SEARCH_API_KEY=xxx" >> ~/.openclaw/env
openclaw gateway restart
```

使用：

```
你：搜索一下最新的AI新闻
AI：正在搜索...
    找到以下相关新闻：

    1. OpenAI发布GPT-5预览版
       来源: TechCrunch
       摘要: OpenAI今天宣布...

    2. Claude 4性能基准测试结果
       来源: The Verge
       摘要: Anthropic发布...
```

## 批量安装

如果你有多个Skill要安装，可以创建一个安装列表：

```bash
# 创建安装列表
cat > ~/skills-to-install.txt << EOF
weather-assistant
github
brave-search
gmail-manager
EOF

# 批量安装
xargs -I {} openclaw skills install {} < ~/skills-to-install.txt
```

## 从URL安装

如果有人分享了一个Skill的URL：

```bash
openclaw skills install https://example.com/skills/my-skill.md
```

或直接在聊天中发送URL：

```
你：https://raw.githubusercontent.com/user/weather-skill/main/SKILL.md
AI：检测到Skill URL，正在解析...
    名称: Custom Weather
    描述: 自定义天气技能
    要安装吗？
```

## 安装失败怎么办？

### 错误1：网络超时

```bash
# 使用代理
export HTTP_PROXY=http://127.0.0.1:7890
openclaw skills install weather-assistant
```

### 错误2：依赖缺失

```bash
# 手动安装依赖
cd ~/.openclaw/workspace/skills/weather-assistant
npm install
```

### 错误3：权限问题

```bash
# 修复权限
chmod -R 755 ~/.openclaw/workspace/skills
```

### 错误4：版本冲突

```bash
# 安装特定版本
openclaw skills install weather-assistant@2.0.0
```

## 查看安装日志

```bash
openclaw skills logs weather-assistant
```

输出：
```
[2024-01-15 10:30:15] Installing weather-assistant@2.1.0...
[2024-01-15 10:30:16] Downloaded 245KB
[2024-01-15 10:30:17] Validating checksum...
[2024-01-15 10:30:18] Installing to ~/.openclaw/workspace/skills/weather-assistant
[2024-01-15 10:30:19] Registering with Agent...
[2024-01-15 10:30:20] Installation complete!
```

---

**本节小结**

- 安装前先更新索引、检查状态
- 三种安装方式：命令行、Dashboard、自然语言
- 安装后验证：检查状态、运行测试、实际使用
- 部分Skill需要配置API Key或OAuth认证
- 支持从URL直接安装
- 遇到问题查看日志排查

---

# Skill的配置与管理

安装Skill只是第一步，掌握配置和管理技巧，才能让Skills发挥最大效用。

## Skill的目录结构

每个安装的Skill都在独立目录中：

```
~/.openclaw/workspace/skills/
├── weather-assistant/
│   ├── SKILL.md          # 技能定义
│   ├── config.json       # 用户配置
│   ├── index.ts          # 执行脚本
│   ├── package.json      # 依赖信息
│   └── node_modules/     # 依赖包
│
├── github/
│   ├── SKILL.md
│   ├── config.json
│   └── ...
│
└── gmail-manager/
    └── ...
```

## 配置管理

### 查看配置

```bash
# 查看所有已安装Skills的配置
openclaw skills config list

# 查看特定Skill的配置
openclaw skills config show github
```

输出：
```json
{
  "token": "${GITHUB_TOKEN}",
  "defaultBranch": "main",
  "autoFork": false
}
```

### 修改配置

**方式一：命令行**

```bash
openclaw skills config set github defaultBranch develop
```

**方式二：编辑文件**

```bash
code ~/.openclaw/workspace/skills/github/config.json
```

**方式三：Dashboard**

1. 打开 http://127.0.0.1:18789
2. Skills > Installed > github > Settings
3. 修改配置并保存

### 配置优先级

配置的优先级从高到低：

1. **命令行参数** - 一次性使用
2. **config.json** - Skill级别
3. **环境变量** - 全局共享
4. **默认值** - Skill内置

## 环境变量管理

Skills通常需要API Key等敏感信息，使用环境变量是最佳实践。

### 配置方式

```bash
# 编辑环境变量文件
vim ~/.openclaw/env
```

```bash
# ~/.openclaw/env
GITHUB_TOKEN=ghp_xxx
GOOGLE_API_KEY=AIza-xxx
BRAVE_SEARCH_API_KEY=xxx
OPENWEATHER_API_KEY=xxx
```

### 在配置中引用

```json
{
  "token": "${GITHUB_TOKEN}",
  "apiKey": "${GOOGLE_API_KEY}"
}
```

### 生效方式

```bash
openclaw gateway restart
```

## Skill更新

### 检查更新

```bash
# 检查所有Skills的更新
openclaw skills outdated

# 检查特定Skill
openclaw skills outdated github
```

输出：
```
Checking for updates...

github
  当前版本: 1.2.0
  最新版本: 1.3.0
  更新内容:
    - 新增 PR review 功能
    - 修复 Issue 列表排序问题
```

### 更新Skill

```bash
# 更新单个Skill
openclaw skills update github

# 更新所有Skills
openclaw skills update --all
```

### 锁定版本

如果你想锁定特定版本：

```bash
# 安装特定版本
openclaw skills install github@1.2.0

# 锁定不更新
openclaw skills pin github
```

## Skill禁用与启用

### 禁用Skill

临时禁用某个Skill（不卸载）：

```bash
openclaw skills disable github
```

### 启用Skill

```bash
openclaw skills enable github
```

### 查看状态

```bash
openclaw skills list --installed
```

输出：
```
Installed Skills:

✓ weather-assistant (2.1.0) - 活跃
○ github (1.3.0) - 已禁用
✓ gmail-manager (1.0.0) - 活跃
```

## Skill卸载

### 卸载单个Skill

```bash
openclaw skills uninstall github
```

输出：
```
⚠️  确定要卸载 github 吗？
    这将删除所有相关配置。

[y/N] y

✓ 已卸载 github
```

### 保留配置卸载

如果想保留配置：

```bash
openclaw skills uninstall github --keep-config
```

### 清理残留文件

```bash
# 清理未使用的依赖
openclaw skills prune

# 清理所有缓存
openclaw skills clean
```

## Skill调试

### 查看日志

```bash
# 实时查看日志
openclaw skills logs github --follow

# 查看最近日志
openclaw skills logs github --tail 50
```

输出：
```
[2024-01-15 10:30:15] [INFO] GitHub Skill initialized
[2024-01-15 10:30:16] [DEBUG] API call: repos/list
[2024-01-15 10:30:17] [INFO] Found 23 repositories
```

### 调试模式

```bash
# 启用调试模式
openclaw skills debug github

# 测试特定功能
openclaw skills test github --case "list-repos"
```

### 常见问题排查

**问题1：Skill无响应**

```bash
# 检查Skill状态
openclaw skills status github

# 重启Skill
openclaw skills restart github
```

**问题2：配置不生效**

```bash
# 验证配置
openclaw skills config validate github

# 重新加载
openclaw skills reload github
```

**问题3：依赖冲突**

```bash
# 检查依赖
openclaw skills deps github

# 重新安装依赖
cd ~/.openclaw/workspace/skills/github
rm -rf node_modules
npm install
```

## Skill权限管理

### 查看权限

```bash
openclaw skills permissions github
```

输出：
```
github 技能权限:

✓ filesystem.read - 读取文件
✓ network.request - 网络请求
✗ filesystem.write - 写入文件（未授权）
✗ system.exec - 执行命令（未授权）
```

### 修改权限

```bash
# 授予权限
openclaw skills permissions grant github filesystem.write

# 撤销权限
openclaw skills permissions revoke github filesystem.write
```

### 权限配置文件

```json
// ~/.openclaw/workspace/skills/github/permissions.json
{
  "filesystem": {
    "read": true,
    "write": false
  },
  "network": {
    "request": true,
    "domains": ["api.github.com"]
  },
  "system": {
    "exec": false
  }
}
```

## Skill依赖管理

### 查看依赖

```bash
openclaw skills deps github
```

输出：
```
github 依赖:

Production:
├── @octokit/rest@19.0.0
├── dotenv@16.0.0
└── node-fetch@2.6.0

Development:
├── jest@29.0.0
└── typescript@4.9.0
```

### 更新依赖

```bash
# 更新单个依赖
openclaw skills deps update github @octokit/rest

# 更新所有依赖
openclaw skills deps update github --all
```

### 审计依赖

检查依赖的安全问题：

```bash
openclaw skills audit github
```

输出：
```
Scanning dependencies...

⚠️  发现 1 个安全漏洞:

lodash@4.17.15
  严重程度: 高
  漏洞: CVE-2020-8203
  建议: 升级到 4.17.21
```

## 批量管理

### 导出已安装列表

```bash
openclaw skills export > installed-skills.json
```

输出：
```json
{
  "skills": [
    { "name": "weather-assistant", "version": "2.1.0" },
    { "name": "github", "version": "1.3.0" },
    { "name": "gmail-manager", "version": "1.0.0" }
  ]
}
```

### 批量导入

在新机器上恢复：

```bash
openclaw skills import installed-skills.json
```

### 同步配置

如果你有多台机器，可以同步Skills配置：

```bash
# 导出配置
openclaw skills config export > skills-config.json

# 导入配置
openclaw skills config import skills-config.json
```

---

**本节小结**

- Skill配置存储在 `~/.openclaw/workspace/skills/<skill>/config.json`
- 敏感信息使用环境变量，通过 `${VAR}` 引用
- 支持禁用/启用、更新、卸载操作
- 调试时查看日志，启用调试模式
- 权限管理控制Skill能做什么
- 依赖管理确保Skill正常运行
- 支持批量导出/导入，方便迁移

---

# 创建自定义Skill

当ClawdHub上没有你需要的技能时，你可以创建自己的Skill。这是OpenClaw最强大的扩展方式。

## Skill开发概述

### 两种开发模式

| 模式 | 说明 | 适用场景 |
|-----|------|----------|
| **组合式** | 仅用SKILL.md编排现有工具 | 简单任务，无需编程 |
| **代码式** | 编写新的工具函数 | 需要自定义API调用 |

### 标准目录结构

```
my-skill/
├── SKILL.md           # 核心：提示词定义
├── package.json       # 元数据与依赖
├── HEARTBEAT.md       # (可选) 定时任务定义
├── src/
│   └── index.ts       # TypeScript代码
└── scripts/
    └── task.py        # Python脚本(可选)
```

## 第一步：创建SKILL.md

SKILL.md是Skill的"灵魂"，告诉AI何时以及如何使用这个技能。

### 基本结构

```markdown
# Skill名称

## Capability
简要描述这个技能能做什么。

## When to use
明确告诉AI在什么情况下应该激活此技能。

## Instructions
详细的执行步骤。

## Tools
提供的工具列表和参数说明。
```

### 完整示例：股票查询Skill

```markdown
# Stock Price Checker

## Capability
此技能允许你查询实时股票价格和市场信息。

## When to use
当用户询问以下问题时，请使用此技能：
- 某只股票的当前价格
- 股票涨跌幅
- 市场行情查询

## Instructions
1. 首先识别用户提到的股票代码（如 AAPL, TSLA, 0700.HK）。
2. 如果用户只说了公司名（如"苹果"、"腾讯"），尝试推断股票代码。
3. 调用 `get_stock_price` 工具获取数据。
4. 如果工具返回数据，用简洁的语言回答，包含：
   - 当前价格
   - 涨跌幅和涨跌额
   - 更新时间
5. 如果工具报错或代码无效，礼貌地询问用户正确的代码。

## Examples

用户：苹果股价多少？
助手：让我查一下...
      [调用 get_stock_price("AAPL")]
      AAPL 当前价格：$178.50
      涨跌：+$2.30 (+1.31%)
      更新时间：2024-01-15 10:30:00 EST

用户：腾讯今天表现怎么样？
助手：[调用 get_stock_price("0700.HK")]
      腾讯控股 (0700.HK)：
      当前价格：HK$298.40
      涨跌：-$5.60 (-1.84%)
      今日表现偏弱，跑输恒生指数。

## Tools

### get_stock_price
获取指定股票代码的实时价格。

参数：
- `symbol` (string, 必需): 股票代码，如 "AAPL", "0700.HK"

返回：
- `price`: 当前价格
- `change`: 涨跌额
- `changePercent`: 涨跌幅百分比
- `timestamp`: 更新时间
```

### SKILL.md最佳实践

1. **触发条件要具体**
```markdown
❌ 差：用户想查股票时使用
✅ 好：当用户提到"股价"、"股票代码"、公司名+价格时使用
```

2. **提供Few-Shot示例**
```markdown
## Examples
用户：[输入示例]
助手：[期望的响应]
```

3. **处理边界情况**
```markdown
如果用户提供的代码无效，不要重复调用工具，
而是询问用户是否指的是其他代码。
```

## 第二步：编写工具代码

### TypeScript方式（推荐）

```typescript
// src/index.ts
import { z } from 'zod';

// 定义参数Schema
const StockPriceSchema = z.object({
  symbol: z.string().describe('股票代码，如 AAPL, 0700.HK'),
});

// 定义工具
export const getStockPriceTool = {
  name: 'get_stock_price',
  description: '获取股票实时价格',
  parameters: StockPriceSchema,

  // 执行函数
  execute: async ({ args, context }) => {
    const { symbol } = args;

    try {
      // 调用外部API
      const response = await fetch(
        `https://api.finance.com/quote?symbol=${symbol}`
      );
      const data = await response.json();

      return {
        content: {
          price: data.price,
          change: data.change,
          changePercent: data.changePercent,
          timestamp: new Date().toISOString(),
        },
      };
    } catch (error) {
      return {
        content: { error: `获取股价失败: ${error.message}` },
      };
    }
  },
};

// 导出插件入口
export default {
  tools: [getStockPriceTool],
};
```

### Python方式（通过Shell调用）

```python
# scripts/stock_price.py
import sys
import requests
import json

def get_stock_price(symbol):
    """获取股票价格"""
    try:
        url = f"https://api.finance.com/quote?symbol={symbol}"
        response = requests.get(url, timeout=10)
        data = response.json()

        result = {
            "symbol": symbol,
            "price": data.get("price"),
            "change": data.get("change"),
            "changePercent": data.get("changePercent"),
        }

        print(json.dumps(result, ensure_ascii=False))

    except Exception as e:
        print(json.dumps({"error": str(e)}, ensure_ascii=False))
        sys.exit(1)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(json.dumps({"error": "请提供股票代码"}))
        sys.exit(1)

    get_stock_price(sys.argv[1])
```

在SKILL.md中指示AI使用bash工具调用：

```markdown
## Instructions
当需要获取股价时，使用 bash 工具执行：
python ~/.openclaw/workspace/skills/stock-checker/scripts/stock_price.py <symbol>
```

## 第三步：创建package.json

```json
{
  "name": "openclaw-skill-stock-checker",
  "version": "1.0.0",
  "description": "股票价格查询技能",
  "main": "dist/index.js",
  "scripts": {
    "build": "tsc",
    "test": "jest"
  },
  "openclaw": {
    "type": "skill",
    "displayName": "股票查询",
    "permissions": {
      "network": ["api.finance.com"]
    }
  },
  "dependencies": {
    "zod": "^3.22.0"
  },
  "devDependencies": {
    "typescript": "^5.0.0",
    "@types/node": "^20.0.0"
  }
}
```

## 第四步：添加定时任务（可选）

如果你想创建一个定时执行的Skill，添加HEARTBEAT.md：

```markdown
# Stock Price Monitor

## 触发条件
当满足以下任一条件时执行：
1. 当前时间是工作日上午 9:30（美股开盘时间）
2. 当前时间是工作日下午 4:00（美股收盘时间）
3. 用户明确要求开启监控模式后，每隔 1 小时

## 执行动作
1. 从配置文件读取用户关注的股票列表
2. 逐个调用 get_stock_price 获取价格
3. 如果任何股票跌幅超过 5%：
   - 立即发送警报消息给用户
   - 包含股票代码、当前价格、跌幅
4. 否则：
   - 记录日志
   - 不打扰用户

## 示例警报消息
🚨 股价警报

AAPL 跌幅超过 5%！
当前价格：$168.50
跌幅：-5.2%
建议关注市场动态。
```

## 调试与测试

### 本地安装

将Skill放到正确位置：

```bash
mkdir -p ~/.openclaw/workspace/skills/stock-checker
cp -r my-skill/* ~/.openclaw/workspace/skills/stock-checker/
```

### 重新加载

```bash
openclaw gateway restart
```

### 查看加载日志

```bash
openclaw logs | grep "skill"
```

输出：
```
[INFO] Loading skill: stock-checker
[INFO] Loaded tool: get_stock_price
[INFO] Skill stock-checker initialized successfully
```

### 交互式测试

```bash
openclaw tui
```

```
你：苹果股价多少？
[DEBUG] Detected intent: stock-price
[DEBUG] Calling tool: get_stock_price("AAPL")
[DEBUG] Tool result: {"price": 178.50, "change": 2.30}
助手：AAPL 当前价格：$178.50，涨跌：+$2.30 (+1.31%)
```

### CLI快速测试

```bash
openclaw agent --message "查询AAPL股价" --verbose
```

### 测试特定工具

```bash
openclaw skills test stock-checker --tool get_stock_price --args '{"symbol":"AAPL"}'
```

## 发布到ClawdHub

### 1. 准备发布

确保代码中没有敏感信息：

```bash
# 检查硬编码的API Key
grep -r "api.key\|API_KEY\|secret" .

# 检查本地路径
grep -r "/Users/\|/home/" .
```

### 2. 托管到GitHub

```bash
git init
git add .
git commit -m "Initial commit: Stock Price Checker skill"
git remote add origin https://github.com/yourname/openclaw-skill-stock-checker
git push -u origin main
```

### 3. 测试URL安装

在另一台机器上测试：

```bash
openclaw skills install https://raw.githubusercontent.com/yourname/openclaw-skill-stock-checker/main/SKILL.md
```

### 4. 提交到ClawdHub

Fork官方Skills索引仓库，添加你的Skill信息，提交Pull Request。

```json
// 在索引文件中添加
{
  "name": "stock-checker",
  "displayName": "股票价格查询",
  "description": "查询实时股票价格和市场信息",
  "repository": "https://github.com/yourname/openclaw-skill-stock-checker",
  "version": "1.0.0",
  "author": "yourname",
  "tags": ["finance", "stock", "market"]
}
```

## 完整示例：组合式Skill

如果只需要组合现有工具，无需写代码：

```markdown
# Daily News Briefing

## Capability
每天早上自动获取新闻并发送摘要。

## When to use
- 用户说"开始每日新闻简报"
- 用户想设置定时新闻推送

## Instructions
1. 使用 browser 工具访问 https://news.ycombinator.com
2. 提取前5条新闻的标题和链接
3. 使用 AI 总结每条新闻（不超过50字）
4. 使用 file 工具将结果保存到 ~/Documents/news/daily-{{date}}.md
5. 告知用户已完成

## 示例
用户：开始每日新闻简报
助手：好的，正在获取今日新闻...
      [使用 browser 访问 Hacker News]
      [提取并总结前5条新闻]
      [保存到文件]
      ✅ 已完成！新闻摘要保存在 ~/Documents/news/daily-2024-01-15.md

## 定时执行
在 HEARTBEAT.md 中添加：
"每天早上 8:00，自动执行每日新闻简报流程"
```

## 补充：MCP工具

除了自定义Skill，OpenClaw还支持**MCP (Model Context Protocol)**——Anthropic推出的工具协议。MCP的优势是跨平台兼容，同一个配置可用于Claude和OpenClaw。

常用MCP服务器：filesystem、github、slack、postgres。配置方式：

```json
{
  "mcp": {
    "servers": {
      "github": {
        "command": "npx",
        "args": ["-y", "@modelcontextprotocol/server-github"],
        "env": { "GITHUB_TOKEN": "${GITHUB_TOKEN}" }
      }
    }
  }
}
```

**选择建议**：官方工具有MCP就用MCP，自定义流程用Skill。

---

**本节小结**

- Skill开发有两种模式：组合式（无需编程）和代码式（编写工具函数）
- SKILL.md是核心，定义触发条件和执行步骤
- TypeScript使用Zod定义参数Schema，实现AgentTool接口
- Python通过Shell调用，适合快速原型
- HEARTBEAT.md定义定时任务
- 使用openclaw tui和--verbose参数调试
- 发布前检查敏感信息，托管到GitHub后提交ClawdHub
- MCP是跨平台工具协议，适合使用官方工具（GitHub、Slack等）

---

## 第6章：Lobster工作流自动化

---

# 创建第一个Lobster工作流

在第一部分我们介绍了Lobster引擎的概念。现在让我们动手创建一个实际的工作流。

## 工作流文件位置

Lobster工作流存放在：

```
~/.openclaw/workspace/lobster/
├── daily-news.yaml        # 每日新闻
├── weekly-report.yaml     # 周报生成
├── email-cleanup.yaml     # 邮件清理
└── ...
```

## 创建简单工作流

### 示例：每日新闻简报

```yaml
# ~/.openclaw/workspace/lobster/daily-news.yaml

name: daily-news-briefing

# 输入参数
args:
  news_url: "https://news.ycombinator.com"
  output_path: "~/Documents/daily-news"

# 执行步骤
steps:
  # 步骤1：获取网页内容
  - name: fetch-news
    tool: shell
    args: ["curl", "-s", "{{news_url}}"]

  # 步骤2：AI提取和总结
  - name: summarize
    tool: python
    script: |
      import json
      import os

      # 获取上一步的输出
      html_content = """{{fetch-news.output}}"""

      # 使用AI模型处理（通过环境变量调用）
      # 这里调用OpenClaw的Agent进行AI处理
      result = os.popen(f'''
        openclaw agent ask "从以下内容中提取前5条新闻标题，并为每条生成50字摘要：

        {html_content[:5000]}

        输出格式：
        1. [标题] - 摘要
        2. ..."
      ''').read()

      print(result)

  # 步骤3：保存到文件
  - name: save
    tool: shell
    args: ["bash", "-c", "echo '{{summarize.output}}' > {{output_path}}/{{date}}.md"]
```

### 运行工作流

```bash
openclaw lobster run daily-news
```

输出：
```
🦞 Running workflow: daily-news-briefing

Step 1/3: fetch-news
  Tool: shell
  Status: ✓ 完成 (2.3s)

Step 2/3: summarize
  Tool: python
  Status: ✓ 完成 (4.1s)

Step 3/3: save
  Tool: shell
  Status: ✓ 完成 (0.1s)

✅ Workflow completed in 6.5s
   Output: ~/Documents/daily-news/2024-01-15.md
```

## 工作流语法详解

### 基本结构

```yaml
name: workflow-name        # 工作流名称（必需）

args:                      # 输入参数（可选）
  param1: default-value

steps:                     # 执行步骤（必需）
  - name: step-name
    tool: tool-name
    # ... 其他配置
```

### 支持的工具

| 工具 | 说明 | 示例 |
|-----|------|------|
| `shell` | 执行Shell命令 | `args: ["ls", "-la"]` |
| `python` | 执行Python脚本 | `script: "print('hello')"` |

### 步骤字段

| 字段 | 说明 | 必需 |
|-----|------|------|
| `name` | 步骤名称（用于引用输出） | 是 |
| `tool` | 使用的工具（shell/python） | 是 |
| `args` | Shell命令参数（tool: shell时） | 部分 |
| `script` | Python脚本（tool: python时） | 部分 |
| `approval` | 是否需要审批 | 否 |
| `condition` | 执行条件 | 否 |
| `retry` | 重试配置 | 否 |

### 模板变量

使用 `{{}}` 语法引用变量：

```yaml
# 引用输入参数
url: "{{news_url}}"

# 引用其他步骤的输出
content: "{{fetch-news.output}}"

# 内置变量
path: "{{output_path}}/{{date}}.md"      # 日期
path: "{{output_path}}/{{timestamp}}.md" # 时间戳
path: "~/{{env.HOME}}/Documents"         # 环境变量
```

## 更多示例

### 示例1：文件备份

```yaml
name: backup-documents

args:
  source: "~/Documents"
  backup: "~/Backups"

steps:
  - name: list-files
    tool: shell
    args: ["find", "{{source}}", "-type", "f", "-mtime", "-1"]

  - name: create-backup-dir
    tool: shell
    args: ["mkdir", "-p", "{{backup}}/{{date}}"]

  - name: copy-files
    tool: shell
    args: ["cp", "-r", "{{source}}", "{{backup}}/{{date}}/"]

  - name: report
    tool: python
    script: |
      import os

      source = "{{source}}"
      backup_path = "{{backup}}/{{date}}"
      file_list = """{{list-files.output}}"""

      print(f"备份报告：")
      print(f"- 源目录：{source}")
      print(f"- 备份位置：{backup_path}")
      print(f"- 文件数量：{len(file_list.strip().split(chr(10)))}")
```

### 示例2：邮件整理

```yaml
name: email-cleanup

args:
  action: "archive-read-older-than-30-days"

steps:
  # 使用Python脚本调用邮件API
  - name: list-emails
    tool: python
    script: |
      import subprocess
      import json

      # 调用邮件技能查询邮件
      result = subprocess.run(
        ["openclaw", "skill", "email", "search", "is:read older_than:30d"],
        capture_output=True, text=True
      )
      print(result.stdout)

  # AI分类处理
  - name: categorize
    tool: python
    script: |
      import os

      emails = """{{list-emails.output}}"""

      # 调用AI进行分类
      prompt = f'''
      将这些邮件分类：
      {emails}

      返回JSON格式：
      {{
        "archive": [...],
        "delete": [...],
        "keep": [...]
      }}
      '''

      result = os.popen(f'openclaw agent ask "{prompt}"').read()
      print(result)

  # 执行归档操作（需要审批）
  - name: archive-emails
    tool: shell
    args: ["echo", "归档操作需要手动确认后执行"]
    approval: required

  # 生成摘要
  - name: summary
    tool: python
    script: |
      import json

      # 解析分类结果
      categorize_result = """{{categorize.output}}"""

      # 简单统计（实际应解析JSON）
      lines = categorize_result.split('\n')
      print("整理摘要：")
      print(f"- 已处理邮件数量：{len(lines)}")
      print("- 请查看详细分类结果")
```

### 示例3：GitHub Issue同步

```yaml
name: sync-github-issues

args:
  repo: "myorg/myapp"
  project: "My Project"

steps:
  - name: fetch-issues
    tool: shell
    args: ["gh", "issue", "list", "--repo", "{{repo}}", "--state", "open", "--json", "number,title"]

  - name: fetch-project-items
    tool: shell
    args: ["gh", "project", "item-list", "{{project}}", "--format", "json"]

  - name: find-missing
    tool: python
    script: |
      import json

      issues = """{{fetch-issues.output}}"""
      project_items = """{{fetch-project-items.output}}"""

      # 解析并比较
      try:
        issue_list = json.loads(issues)
        project_list = json.loads(project_items)

        issue_numbers = {str(i['number']) for i in issue_list}
        project_numbers = {str(p['content']['number']) for p in project_list if 'number' in p.get('content', {})}

        missing = issue_numbers - project_numbers
        print(json.dumps(list(missing)))
      except:
        print("[]")

  - name: add-to-project
    tool: shell
    args: ["echo", "需要将以下Issue添加到项目：{{find-missing.output}}"]
    approval: required
```

## 条件执行

### 条件判断

```yaml
steps:
  - name: check-condition
    tool: shell
    args: ["test", "-f", "{{file_path}}"]

  - name: process-if-exists
    tool: shell
    args: ["cat", "{{file_path}}"]
    condition: "{{check-condition.success}}"

  - name: create-if-not-exists
    tool: shell
    args: ["bash", "-c", "echo 'New file' > {{file_path}}"]
    condition: "{{not check-condition.success}}"
```

### 循环处理

```yaml
steps:
  - name: list-items
    tool: shell
    args: ["ls", "{{directory}}"]

  # 使用Python实现循环处理
  - name: process-each
    tool: python
    script: |
      import os

      items = """{{list-items.output}}"""
      directory = "{{directory}}"

      for item in items.strip().split('\n'):
        item_path = os.path.join(directory, item)
        if os.path.isfile(item_path):
          # 处理每个文件
          with open(item_path, 'r') as f:
            content = f.read()
          print(f"处理文件：{item}，大小：{len(content)} 字节")
```

## 错误处理

### 重试配置

```yaml
steps:
  - name: api-call
    tool: shell
    args: ["curl", "-s", "https://api.example.com/data"]
    retry:
      maxAttempts: 3
      delay: 5s
      backoff: exponential
```

### 错误回退

```yaml
steps:
  - name: primary-action
    tool: shell
    args: ["curl", "-s", "https://primary-api.com/data"]
    fallback:
      tool: shell
      args: ["curl", "-s", "https://backup-api.com/data"]
```

### 跳过失败

```yaml
steps:
  - name: optional-step
    tool: shell
    args: ["some-command"]
    continueOnError: true
```

## 调度执行

### Cron配置

在 `openclaw.json` 中配置定时执行：

```json
{
  "crons": {
    "daily-news": {
      "schedule": "0 8 * * *",
      "workflow": "daily-news-briefing"
    },
    "weekly-report": {
      "schedule": "0 9 * * 1",
      "workflow": "weekly-report"
    }
  }
}
```

### 管理定时任务

```bash
# 列出所有定时任务
openclaw cron list

# 启用/禁用
openclaw cron enable daily-news
openclaw cron disable daily-news

# 手动触发
openclaw cron trigger daily-news
```

## 工作流管理命令

```bash
# 列出所有工作流
openclaw lobster list

# 查看工作流详情
openclaw lobster show daily-news

# 运行工作流
openclaw lobster run daily-news

# 验证工作流语法
openclaw lobster validate daily-news

# 查看执行历史
openclaw lobster history daily-news

# 查看执行日志
openclaw lobster logs daily-news --last
```

---

**本节小结**

- 工作流存放在 `~/.openclaw/workspace/lobster/`
- 使用YAML定义工作流，包含args和steps
- 只支持 `tool: shell` 和 `tool: python` 两种工具
- 步骤间通过 `{{step-name.output}}` 传递数据
- 使用 `args` 定义shell命令参数，使用 `script` 定义Python代码
- 支持条件执行、错误处理
- 通过cron配置定时执行
- 使用 `openclaw lobster` 命令管理工作流

---

# Approval Gates的使用

Approval Gates（审批门控）是Lobster最重要的安全特性，用于保护敏感操作。

## 为什么需要Approval Gates？

### 问题场景

```
你让AI帮你自动处理邮件...

AI决定：这封邮件看起来像垃圾邮件，删除它
      [执行删除]

问题：那其实是一封重要的客户邮件
结果：邮件被永久删除，不可恢复
```

### 解决方案

```
AI决定：这封邮件看起来像垃圾邮件
      [请求审批]

你收到通知：AI想删除邮件"来自CEO的紧急通知"
你选择：[批准] [拒绝] [修改]

结果：你掌控最终决定权
```

## 基本用法

### 在步骤中添加审批

```yaml
steps:
  - name: send-email
    tool: shell
    args: ["mail", "-s", "{{subject}}", "boss@company.com"]
    input: "{{body}}"
    approval: required  # 关键配置
```

### 审批级别

| 级别 | 说明 |
|-----|------|
| `required` | 必须审批 |
| `optional` | 可选审批（默认不触发） |
| `none` | 不需要审批（默认） |

### 配置审批消息

```yaml
steps:
  - name: delete-files
    tool: shell
    args: ["rm", "-rf", "{{directory}}"]
    approval:
      required: true
      message: |
        ⚠️ 危险操作

        即将删除目录：{{directory}}
        文件数量：{{file-count}}
        总大小：{{total-size}}

        此操作不可恢复！
```

## 审批流程

### 流程图

```
工作流执行 ────> 遇到approval: required的步骤
                            │
                            ↓
                    暂停工作流执行
                            │
                            ↓
                    生成恢复令牌 (Resume Token)
                            │
                            ↓
                    通知用户审批
                            │
                ┌───────────┴───────────┐
                ↓                       ↓
            [批准]                   [拒绝]
                │                       │
                ↓                       ↓
        继续执行下一步              终止工作流
```

### 审批通知

当工作流需要审批时，你会收到通知：

```
🔔 工作流审批请求

工作流: email-cleanup
步骤: delete-emails
描述: 删除已分类的垃圾邮件

详情:
- 待删除邮件: 23 封
- 预计释放空间: 15.3 MB

审批令牌: ABC123

[批准] [拒绝] [查看详情]
```

## 审批方式

### 方式一：聊天中审批

```
你：批准删除邮件
AI：已批准 delete-emails 步骤
    工作流继续执行...
```

### 方式二：命令行审批

```bash
# 查看待审批项
openclaw lobster pending

# 批准
openclaw lobster approve ABC123

# 拒绝
openclaw lobster reject ABC123
```

### 方式三：Dashboard审批

1. 打开 http://127.0.0.1:18789
2. 进入 Lobster > Pending
3. 点击 Approve 或 Reject

## 高级配置

### 审批超时

```yaml
steps:
  - name: critical-action
    tool: shell
    args: ["./deploy.sh"]
    approval:
      required: true
      timeout: 1h        # 1小时后自动拒绝
      onTimeout: reject  # 或 continue（继续执行）
```

### 审批通知渠道

```yaml
steps:
  - name: send-money
    tool: shell
    args: ["./payment.sh", "--amount", "{{amount}}"]
    approval:
      required: true
      notify:
        - telegram       # 发送到Telegram
        - slack:#alerts  # 发送到Slack频道
        - email:user@company.com
```

### 多人审批

```yaml
steps:
  - name: deploy-production
    tool: shell
    args: ["./deploy.sh", "production"]
    approval:
      required: true
      approvers:
        - user-1  # 用户1
        - user-2  # 用户2
      minApprovals: 2  # 需要至少2人批准
```

## 何时使用Approval Gates

### 需要审批的操作

| 操作类型 | 示例 | 原因 |
|---------|------|------|
| 产生副作用 | 发送邮件、发帖 | 不可撤销 |
| 涉及资金 | 支付、转账 | 风险高 |
| 破坏性操作 | 删除文件 | 不可恢复 |
| 修改配置 | 修改系统设置 | 影响范围大 |
| 外部交互 | 调用外部API | 不可控 |

### 不需要审批的操作

| 操作类型 | 示例 | 原因 |
|---------|------|------|
| 只读操作 | 读取文件、查询 | 无副作用 |
| 本地处理 | 数据转换 | 风险低 |
| 临时操作 | 创建临时文件 | 可恢复 |

## 实战示例

### 邮件发送审批

```yaml
name: send-report

steps:
  - name: generate-report
    tool: python
    script: |
      import openai

      response = openai.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": "生成周报..."}]
      )

      print(response.choices[0].message.content)

  - name: send-email
    tool: shell
    args: ["mail", "-s", "本周周报", "team@company.com"]
    input: "{{generate-report.output}}"
    approval:
      required: true
      message: |
        📧 邮件发送确认

        收件人: team@company.com
        主题: 本周周报

        请确认邮件内容无误后发送。
```

### 文件删除审批

```yaml
name: cleanup-downloads

steps:
  - name: list-old-files
    tool: shell
    args: ["find", "~/Downloads", "-mtime", "+30"]

  - name: confirm-delete
    tool: python
    script: |
      import subprocess

      files = """{{list-old-files.output}}"""
      file_list = [f for f in files.split('\n') if f]

      # 统计文件数量和总大小
      count = len(file_list)
      total_size = 0
      for f in file_list:
        try:
          size = subprocess.check_output(["stat", "-f%z", f]).decode().strip()
          total_size += int(size)
        except:
          pass

      import json
      print(json.dumps({"count": count, "size": f"{total_size / 1024 / 1024:.1f} MB"}))

  - name: delete-files
    tool: shell
    args: ["rm", "-rf", "{{list-old-files.output}}"]
    approval:
      required: true
      message: |
        🗑️ 文件删除确认

        将删除 {{confirm-delete.output.count}} 个文件
        释放空间：{{confirm-delete.output.size}}

        此操作不可恢复！
```

### 生产部署审批

```yaml
name: deploy-production

steps:
  - name: run-tests
    tool: shell
    args: ["npm", "test"]

  - name: deploy
    tool: shell
    args: ["./deploy.sh", "production"]
    approval:
      required: true
      timeout: 2h
      approvers:
        - tech-lead
        - ops-manager
      minApprovals: 1
      message: |
        🚀 生产环境部署请求

        分支: main
        提交: {{git-commit}}
        测试: ✓ 通过

        请确认部署到生产环境。
```

---

**本节小结**

- Approval Gates为敏感操作增加人工确认
- 使用 `approval: required` 启用审批
- 可通过聊天、命令行、Dashboard审批
- 支持超时、多渠道通知、多人审批
- 产生副作用的操作都应该启用审批

---

# 混合执行模式

Lobster的核心优势是支持**硬编码工具**和**AI推理**的混合执行。

## 两种执行模式

### 硬编码工具

```yaml
steps:
  - name: list-files
    tool: shell
    args: ["ls", "-la", "~/Documents"]
```

特点：
- 确定性：每次执行结果相同
- 快速：无LLM调用延迟
- 可靠：不会产生幻觉
- 局限：只能做预定义的操作

### AI推理

```yaml
steps:
  - name: summarize
    tool: python
    script: |
      import openai

      content = """{{input}}"""

      response = openai.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": f"总结以下内容：{content}"}]
      )

      print(response.choices[0].message.content)
```

特点：
- 灵活：处理各种非结构化输入
- 智能：理解语义、分类、总结
- 创造性：生成内容
- 局限：可能出错，不确定

## 混合模式的优势

```
┌─────────────────────────────────────────────────────────┐
│ 硬编码工具擅长                                           │
│ - 读取文件、目录操作                                     │
│ - 执行Shell命令                                         │
│ - API调用、数据库查询                                    │
│ - 精确的字符串处理                                       │
├─────────────────────────────────────────────────────────┤
│ AI推理擅长                                              │
│ - 理解语义                                              │
│ - 分类、总结                                            │
│ - 处理模糊输入                                          │
│ - 生成内容                                              │
├─────────────────────────────────────────────────────────┤
│ 混合模式                                                │
│ 硬编码工具 ──获取数据──> AI推理 ──处理──> 硬编码工具 ──执行──> 完成 │
└─────────────────────────────────────────────────────────┘
```

## 实战示例

### 示例1：智能文件整理

```yaml
name: smart-file-organizer

args:
  source_dir: "~/Downloads"

steps:
  # 步骤1：硬编码工具获取文件列表
  - name: list-files
    tool: shell
    args: ["ls", "-la", "{{source_dir}}"]

  # 步骤2：Python调用AI进行分类
  - name: classify
    tool: python
    script: |
      import json
      import openai

      files = """{{list-files.output}}"""

      response = openai.chat.completions.create(
        model="gpt-4",
        messages=[{
          "role": "user",
          "content": f"""将以下文件分类到 work, personal, media, other 四个类别：

{files}

返回JSON格式：
{{
  "work": ["file1.pdf", "file2.docx"],
  "personal": ["photo.jpg"],
  "media": ["video.mp4"],
  "other": ["unknown.bin"]
}}"""
        }]
      )

      print(response.choices[0].message.content)

  # 步骤3：硬编码工具执行移动
  - name: move-files
    tool: shell
    args: |
      for file in {{classify.output.work}}; do
        mv "{{source_dir}}/$file" "~/Documents/Work/"
      done
      for file in {{classify.output.personal}}; do
        mv "{{source_dir}}/$file" "~/Documents/Personal/"
      done
```

### 示例2：智能邮件处理

```yaml
name: email-triage

steps:
  # 硬编码：获取邮件列表
  - name: fetch-emails
    tool: shell
    args: ["mail", "-u", "user@company.com", "-f", "INBOX", "-s", "Subject"]

  # AI：优先级分类
  - name: prioritize
    tool: python
    script: |
      import json
      import openai

      emails = """{{fetch-emails.output}}"""

      response = openai.chat.completions.create(
        model="gpt-4",
        messages=[{
          "role": "user",
          "content": f"""分析这些邮件，按优先级分类：

{emails}

分类标准：
- urgent: 来自老板/客户，提到紧急/截止日期
- important: 工作相关，需要回复
- low: 订阅邮件、通知

返回JSON：
{{
  "urgent": [...],
  "important": [...],
  "low": [...]
}}"""
        }]
      )

      print(response.choices[0].message.content)

  # 硬编码：发送通知到Slack
  - name: notify
    tool: shell
    args: |
      curl -X POST https://slack.com/api/chat.postMessage \
        -H "Authorization: Bearer $SLACK_TOKEN" \
        -H "Content-Type: application/json" \
        -d '{
          "channel": "#notifications",
          "text": "📬 新邮件摘要\n\n{{prioritize.output}}"
        }'
```

### 示例3：代码审查

```yaml
name: code-review

args:
  repo: "myorg/myapp"
  pr_number: 123

steps:
  # 硬编码：获取PR变更
  - name: get-diff
    tool: shell
    args: |
      curl -s -H "Authorization: token $GITHUB_TOKEN" \
        https://api.github.com/repos/{{repo}}/pulls/{{pr_number}}/files

  # AI：审查代码
  - name: review
    tool: python
    script: |
      import openai

      diff = """{{get-diff.output}}"""

      response = openai.chat.completions.create(
        model="gpt-4",
        messages=[{
          "role": "user",
          "content": f"""审查以下代码变更，检查：
1. 潜在的bug
2. 性能问题
3. 安全漏洞
4. 代码风格

代码变更：
{diff}

返回格式：
- 问题列表
- 严重程度
- 建议修改"""
        }]
      )

      print(response.choices[0].message.content)

  # AI：生成评论
  - name: format-comment
    tool: python
    script: |
      import openai

      review_result = """{{review.output}}"""

      response = openai.chat.completions.create(
        model="gpt-4",
        messages=[{
          "role": "user",
          "content": f"""将以下审查结果格式化为友好的PR评论：

{review_result}

使用Markdown格式，包含emoji。"""
        }]
      )

      print(response.choices[0].message.content)

  # 硬编码：发布评论
  - name: post-comment
    tool: shell
    args: |
      curl -s -X POST \
        -H "Authorization: token $GITHUB_TOKEN" \
        -H "Content-Type: application/json" \
        https://api.github.com/repos/{{repo}}/issues/{{pr_number}}/comments \
        -d '{{"body": "{{format-comment.output}}"}}'
```

## 混合模式最佳实践

### 1. 用硬编码工具做数据获取

```yaml
# ✓ 正确
- name: fetch-data
  tool: shell
  args: ["curl", "-s", "https://api.example.com/data"]

# ✗ 不推荐
- name: fetch-data
  tool: python
  script: |
    # 不推荐：让AI通过API访问URL（效率低且不可靠）
    import openai
    response = openai.chat.completions.create(
      model="gpt-4",
      messages=[{"role": "user", "content": "访问 https://api.example.com/data 并告诉我结果"}]
    )
    print(response.choices[0].message.content)
```

### 2. 用AI处理非结构化数据

```yaml
# ✓ 正确
- name: classify
  tool: python
  script: |
    import openai

    emails = """{{emails}}"""

    response = openai.chat.completions.create(
      model="gpt-4",
      messages=[{"role": "user", "content": f"分类这些邮件：{emails}"}]
    )

    print(response.choices[0].message.content)

# ✗ 不推荐
- name: classify
  tool: shell
  args: ["./classify-emails.sh", "{{emails}}"]  # 需要预先编写复杂脚本
```

### 3. 用硬编码工具执行精确操作

```yaml
# ✓ 正确
- name: move-files
  tool: shell
  args: ["mv", "{{source}}", "{{dest}}"]

# ✗ 不推荐
- name: move-files
  tool: python
  script: |
    # AI不能直接操作文件系统，需要调用shell命令
    import subprocess
    subprocess.run(["mv", "{{source}}", "{{dest}}"])
```

### 4. 用AI生成内容

```yaml
# ✓ 正确
- name: write-report
  tool: python
  script: |
    import openai

    data = """{{data}}"""

    response = openai.chat.completions.create(
      model="gpt-4",
      messages=[{"role": "user", "content": f"根据以下数据生成报告：{data}"}]
    )

    print(response.choices[0].message.content)

# ✗ 不推荐
- name: write-report
  tool: shell
  args: ["./generate-report.sh", "{{data}}"]  # 模板化，缺乏灵活性
```

## 混合模式的边界

| 场景 | 推荐工具 |
|-----|---------|
| 读取文件 | 硬编码 |
| 写入文件 | 硬编码 |
| API调用 | 硬编码 |
| 数据解析 | 硬编码（结构化）/ AI（非结构化） |
| 语义理解 | AI |
| 内容生成 | AI |
| 分类决策 | AI |
| 精确操作 | 硬编码 |

---

**本节小结**

- 硬编码工具：确定性、快速、可靠
- AI推理：灵活、智能、创造性
- 混合模式发挥各自优势
- 硬编码做数据获取和精确操作
- AI做语义理解和内容生成

---

# 工作流调试技巧

工作流开发过程中难免遇到问题。掌握调试技巧，能帮你快速定位和解决问题。

## 常见问题类型

### 1. 语法错误

```yaml
# 错误示例
steps:
  - name: fetch
    tool: shell
    args: ["curl", "-s", "{{news_url}}"]  # 缺少args字段
```

### 2. 变量引用错误

```yaml
# 错误示例
steps:
  - name: step1
    tool: shell
    args: ["echo", "hello"]

  - name: step2
    tool: python
    script: |
      # 错误：应该是 {{step1.output}} 而不是 {{step1.result}}
      result = """{{step1.result}}"""
      print(result)
```

### 3. 工具调用失败

```yaml
# 可能失败
steps:
  - name: api-call
    tool: shell
    args: ["curl", "-s", "https://api.example.com/data"]
    # 网络问题、API限流、认证失败等
```

### 4. AI输出格式错误

```yaml
# AI返回格式不符合预期
steps:
  - name: classify
    tool: python
    script: |
      import openai

      response = openai.chat.completions.create(
        model="gpt-4",
        messages=[{
          "role": "user",
          "content": '返回JSON格式：{"category": "..."}'
        }]
      )

      # AI可能返回：The category is work.（不是JSON）
      print(response.choices[0].message.content)
```

## 调试工具

### 验证工作流语法

```bash
openclaw lobster validate daily-news
```

输出：
```
Validating daily-news.yaml...

❌ Error at line 15:
  Missing required field 'args' for tool 'shell'

Suggestion:
  Add 'args: ["curl", "-s", "URL"]' to the step configuration
```

### 单步调试

```bash
# 运行到指定步骤
openclaw lobster run daily-news --step fetch-news

# 查看步骤输出
openclaw lobster run daily-news --step fetch-news --verbose
```

输出：
```
🦞 Running step: fetch-news

Tool: shell
Args: ["curl", "-s", "https://news.ycombinator.com"]

Output:
  Status: 200
  Content-Type: text/html
  Size: 45.2KB

  Preview:
  <!DOCTYPE html>
  <html>
  ...
```

### 查看执行日志

```bash
# 查看最近一次执行日志
openclaw lobster logs daily-news --last

# 实时查看日志
openclaw lobster logs daily-news --follow

# 查看特定步骤的日志
openclaw lobster logs daily-news --step summarize
```

输出：
```
[2024-01-15 10:30:15] Starting workflow: daily-news-briefing
[2024-01-15 10:30:15] Step 1/3: fetch-news
[2024-01-15 10:30:17] ✓ fetch-news completed (2.1s)
[2024-01-15 10:30:17] Output size: 45.2KB
[2024-01-15 10:30:17] Step 2/3: summarize
[2024-01-15 10:30:21] ✓ summarize completed (4.2s)
[2024-01-15 10:30:21] AI model: claude-3-5-sonnet
[2024-01-15 10:30:21] Tokens used: 1,234 input, 456 output
[2024-01-15 10:30:21] Step 3/3: save
[2024-01-15 10:30:21] ✓ save completed (0.1s)
[2024-01-15 10:30:21] ✅ Workflow completed (6.4s)
```

## 调试模式

### 启用详细输出

```bash
openclaw lobster run daily-news --verbose
```

### 启用调试模式

```bash
openclaw lobster run daily-news --debug
```

输出包含：
- 变量解析过程
- 工具调用详情
- AI请求和响应
- 执行时间分析

### 交互式调试

```bash
openclaw lobster debug daily-news
```

进入交互式调试界面：

```
🦞 Lobster Debugger: daily-news-briefing

Current step: fetch-news (1/3)

> show args
news_url: https://news.ycombinator.com
output_path: ~/Documents/daily-news

> run step
Executing fetch-news...
✓ Completed

> show output
<!DOCTYPE html>
...

> next
Moving to step: summarize (2/3)

> edit prompt
> summarize the content in 5 bullet points

> run step
Executing summarize with modified prompt...
✓ Completed

> continue
Executing remaining steps...
✅ Workflow completed
```

## 常见问题解决

### 问题1：变量未解析

**症状**：
```
Error: Variable 'fetch-news.output' not found
```

**原因**：步骤名称错误或步骤未执行

**解决**：
```bash
# 检查步骤名称
openclaw lobster show daily-news

# 确保步骤正确执行
openclaw lobster logs daily-news --step fetch-news
```

### 问题2：AI返回格式错误

**症状**：
```
Error: Failed to parse AI output as JSON
```

**解决**：改进prompt，明确输出格式

```yaml
# 改进前
- name: classify
  tool: python
  script: |
    import openai
    response = openai.chat.completions.create(
      model="gpt-4",
      messages=[{"role": "user", "content": "分类这些文件"}]
    )
    print(response.choices[0].message.content)

# 改进后
- name: classify
  tool: python
  script: |
    import openai

    response = openai.chat.completions.create(
      model="gpt-4",
      messages=[{
        "role": "user",
        "content": """分类这些文件，返回严格的JSON格式。

示例输出：
{"work": ["file1.pdf"], "personal": ["file2.jpg"]}

只返回JSON，不要其他解释。"""
      }]
    )

    print(response.choices[0].message.content)
```

### 问题3：网络超时

**症状**：
```
Error: Request timeout after 30s
```

**解决**：增加超时时间

```yaml
steps:
  - name: fetch
    tool: shell
    args: ["curl", "-s", "--max-time", "60", "https://slow-api.com/data"]
```

### 问题4：权限被拒绝

**症状**：
```
Error: Permission denied: /root/secret
```

**解决**：检查沙箱配置

```json
{
  "agents": {
    "defaults": {
      "sandbox": {
        "workspaceAccess": "rw"
      }
    }
  }
}
```

## 测试技巧

### 单元测试步骤

```bash
# 测试单个工具
openclaw lobster test-tool shell --args '["curl", "-s", "https://example.com"]'

# 测试Python脚本
openclaw lobster test-tool python --script 'print("Hello World")'
```

### 模拟数据

```yaml
steps:
  - name: mock-fetch
    tool: shell
    args: ["cat", "mock-news.html"]

  - name: process
    tool: python
    script: |
      import openai

      content = """{{mock-fetch.output}}"""

      response = openai.chat.completions.create(
        model="gpt-4",
        messages=[{"role": "user", "content": f"Process: {content}"}]
      )

      print(response.choices[0].message.content)
```

### 环境隔离

```bash
# 使用测试配置
openclaw lobster run daily-news --config test-config.yaml

# 使用测试环境变量
openclaw lobster run daily-news --env-file .env.test
```

## 性能分析

### 执行时间分析

```bash
openclaw lobster analyze daily-news
```

输出：
```
Workflow Performance Analysis: daily-news-briefing

Step              Time    % Total   Status
─────────────────────────────────────────────
fetch-news        2.3s    35%       ✓
summarize         4.1s    63%       ✓
save              0.1s    2%        ✓
─────────────────────────────────────────────
Total             6.5s    100%

Bottleneck: summarize (63% of time)

Suggestion: Consider using a faster model for simple summarization
```

### Token使用分析

```bash
openclaw lobster tokens daily-news
```

输出：
```
Token Usage Analysis: daily-news-briefing

Step              Input    Output    Cost
─────────────────────────────────────────────
summarize         1,234    456       $0.02
─────────────────────────────────────────────
Total             1,234    456       $0.02

Suggestions:
- Reduce input size by truncating HTML
- Use faster model for simple tasks
```

## 日志配置

### 日志级别

```json
{
  "lobster": {
    "logging": {
      "level": "debug",  // debug, info, warn, error
      "file": "~/.openclaw/lobster.log"
    }
  }
}
```

### 日志格式

```bash
# 查看JSON格式日志
openclaw lobster logs daily-news --format json

# 导出日志
openclaw lobster logs daily-news --export lobster-debug.log
```

---

**本节小结**

- 使用 `validate` 检查语法错误
- 使用 `--verbose` 和 `--debug` 获取详细信息
- 使用 `lobster debug` 进入交互式调试
- 改进AI prompt确保输出格式正确
- 使用mock数据隔离测试
- 使用 `analyze` 和 `tokens` 分析性能
- 配置日志级别获取详细日志

