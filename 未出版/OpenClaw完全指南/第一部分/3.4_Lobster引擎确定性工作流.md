---
section_id: 3.4
title: Lobster引擎确定性工作流
status: draft
target_words: 2000
word_count: 2200
---

# Lobster引擎：确定性工作流

在前面介绍Agent时，我们提到它的一个局限性：不确定性。同样的输入，LLM可能产生不同的输出。

这对于闲聊没问题，但对于关键操作，我们需要确定性——每次执行都严格按预定的步骤进行。

这就是Lobster引擎存在的意义。

## 为什么需要Lobster？

### LLM的"跑偏"问题

想象这个场景：

你让AI帮你发送一封重要的邮件给老板。AI开始思考：

```
LLM思考中...
"用户要发邮件给老板，让我先查一下老板的邮箱地址..."
"哦，我需要确认一下邮件内容..."
"对了，用户可能还想要抄送给其他人..."
"要不我先草拟一下邮件内容..."
"等等，我是不是应该先检查一下附件..."
```

5分钟后，邮件还没发出去，AI还在"思考"。

这就是LLM的概率性导致的——它可能会"跑偏"，可能会过度思考，可能会遗漏步骤。

### 确定性 vs 概率性

| 特性 | LLM（概率性） | Lobster（确定性） |
|-----|-------------|-----------------|
| 执行步骤 | 可能变化 | 严格固定 |
| 响应时间 | 不可预测 | 可预测 |
| 结果一致性 | 可能不同 | 每次相同 |
| Token消耗 | 不可控 | 可控 |
| 适用场景 | 创造性任务 | 重复性任务 |

### Lobster的设计理念

Lobster的设计目标很明确：

将任务编排从LLM的"思考"中剥离出来，放入确定性的运行时中。

```
传统Agent：
LLM思考 → 决定步骤 → 执行 → 思考 → 决定下一步 → 执行 → ...

Lobster：
预定义步骤 → 严格按步骤执行 → 完成
（没有LLM的"思考"参与执行过程）
```

## Lobster是什么？

Lobster是OpenClaw的原生工作流外壳（Shell），被定义为一个"类型化、本地优先的宏引擎（Macro Engine）"。

你可以把它理解为：
- Shell脚本的AI增强版
- 工作流引擎的简化版
- 低代码工具的代码版

### 核心特性

1. 确定性执行：工作流按YAML定义的步骤严格执行
2. 类型安全：步骤间传递结构化数据，避免格式错误
3. 混合模式：硬编码工具和AI推理可以混合使用
4. 审批门控：敏感操作需要人工确认
5. 本地优先：不依赖云端服务

## YAML工作流定义

Lobster使用YAML（或JSON）定义工作流。

### 基本结构

```yaml
# 工作流名称
name: weekly-review

# 输入参数定义
args:
  vault_path: ~/Documents/brain

# 执行步骤链
steps:
  - name: step-1
    tool: 工具名称
    args: 参数

  - name: step-2
    tool: 工具名称
    args: 参数
```

### 完整示例：周报审查

```yaml
name: weekly-review

args:
  vault_path: ~/Documents/brain

steps:
  # 步骤1: 调用硬编码工具获取数据
  - name: scan-inbox
    tool: brain-cli
    args: ["inbox", "list", "--json"]

  # 步骤2: 调用Python进行AI逻辑处理
  - name: categorize
    tool: python
    script: |
      import json
      import os

      # 获取输入数据
      inbox_items = """{{scan-inbox.output}}"""

      # 调用AI API进行分类（使用环境变量中的API密钥）
      import openai
      response = openai.chat.completions.create(
        model="gpt-4",
        messages=[{
          "role": "user",
          "content": f"Categorize these inbox items into work, personal, urgent: {inbox_items}"
        }]
      )

      # 输出分类结果
      print(response.choices[0].message.content)

  # 步骤3: 执行操作（需要审批）
  - name: move-items
    tool: shell
    args: ["brain-cli", "inbox", "move", "{{categorize.output}}"]
    approval: required

  # 步骤4: 生成总结
  - name: generate-summary
    tool: python
    script: |
      import openai

      inbox_items = """{{scan-inbox.output}}"""

      response = openai.chat.completions.create(
        model="gpt-4",
        messages=[{
          "role": "user",
          "content": f"Create weekly summary from these inbox items: {inbox_items}"
        }]
      )

      print(response.choices[0].message.content)
```

### 数据流转

注意上面的`{{scan-inbox.output}}`语法——这是模板变量。

```
步骤1输出 ────> {{scan-inbox.output}} ────> 步骤2输入
步骤2输出 ────> {{categorize.output}} ────> 步骤3输入
```

这种设计让数据在步骤间流转，形成流水线。

## 混合执行模式

Lobster的强大之处在于：硬编码工具和AI推理可以混合使用。

### 硬编码工具 vs AI

| 类型 | 负责什么 | 优势 | 劣势 |
|-----|---------|------|------|
| 硬编码工具 | 数据获取、精确操作 | 快速、可靠、无幻觉 | 不灵活 |
| AI推理 | 语义理解、分类、总结 | 灵活、理解模糊输入 | 可能出错 |

### 混合模式工作流

```
1. 硬编码工具：读取文件列表 ────> 输出JSON
                         │
                         ↓
2. AI推理：分类这些文件   ────> 输出分类结果
                         │
                         ↓
3. 硬编码工具：按分类移动文件 ────> 完成整理
```

**为什么这样设计？**

- 让硬编码工具做它擅长的事（读取、移动文件）
- 让AI做它擅长的事（理解语义、分类）
- 各司其职，发挥优势

### 代码示例

```yaml
name: smart-file-organizer

args:
  source_dir: ~/Downloads

steps:
  # 步骤1: 硬编码工具获取文件列表
  - name: list-files
    tool: shell
    args: ["ls", "-la", "{{source_dir}}"]

  # 步骤2: Python调用AI进行分类
  - name: classify
    tool: python
    script: |
      import json
      import openai

      files = """{{list-files.output}}"""

      response = openai.chat.completions.create(
        model="gpt-4",
        messages=[{
          "role": "user",
          "content": f"Classify these files into categories (work, personal, media, other):\n{files}\nReturn JSON format: {{\"work\": [...], \"personal\": [...], ...}}"
        }]
      )

      print(response.choices[0].message.content)

  # 步骤3: 硬编码工具执行移动
  - name: move-files
    tool: shell
    args: ["./organize.sh", "{{classify.output}}"]
```

## Approval Gates：审批门控

这是Lobster最重要的安全特性。

### 问题场景

你让AI帮你自动处理邮件。AI决定删除一封"看起来像垃圾邮件"的邮件。

问题是：那其实是一封重要的客户邮件。

AI做出了不可逆的操作，而且错了。

### Approval Gates的解决方案

对于敏感操作，Lobster会暂停执行，等待人工确认。

```yaml
steps:
  - name: send-email
    tool: shell
    args: ["mail", "-s", "{{subject}}", "boss@company.com"]
    input: "{{body}}"
    approval: required  # ← 关键：需要审批
```

### 工作流程

```
Lobster执行到 approval: required 的步骤
           │
           ↓
    暂停工作流
           │
           ↓
    生成恢复令牌 (Resume Token)
           │
           ↓
    通知用户："需要确认：发送邮件给老板"
           │
           ↓
    用户确认：批准 / 拒绝
           │
           ↓
    如果批准：继续执行
    如果拒绝：终止工作流
```

### 什么时候需要Approval Gates？

| 操作类型 | 示例 | 建议 |
|---------|------|------|
| 产生副作用 | 发送邮件、发帖 | 需要审批 |
| 涉及资金 | 购买商品、转账 | 需要审批 |
| 破坏性操作 | 删除文件 | 需要审批 |
| 只读操作 | 读取文件、查询 | 无需审批 |

## Lobster vs Pi Agent

你可能会问：既然有了Agent，为什么还需要Lobster？

### 分工明确

```
Pi Agent：决策者
- 理解用户意图
- 决定调用哪个工作流
- 处理非结构化输入

Lobster：执行者
- 按预定义步骤执行
- 确保操作确定性
- 管理审批流程
```

### 协作模式

```
用户："帮我整理这周的收件箱"
        │
        ↓
Pi Agent分析意图：
"用户想要整理邮件，匹配到 email-cleanup 工作流"
        │
        ↓
Pi Agent调用Lobster：
启动 email-cleanup.yaml
        │
        ↓
Lobster执行工作流：
步骤1 → 步骤2 → (遇到审批) → 等待用户确认 → 步骤3 → 完成
        │
        ↓
Lobster返回结果给Pi Agent
        │
        ↓
Pi Agent回复用户：
"已完成邮件整理，处理了47封邮件，3封需要您关注"
```

### 选择指南

| 场景 | 使用什么 |
|-----|---------|
| 一次性、简单任务 | 直接用Agent |
| 重复性、多步骤任务 | 封装成Lobster工作流 |
| 涉及敏感操作 | Lobster + Approval Gates |
| 需要确定性结果 | Lobster |
| 需要灵活性 | Agent |

## 实战：创建你的第一个工作流

### 场景：每日新闻简报

我们想每天早上自动：
1. 获取新闻网站的头条
2. 用AI总结成300字简报
3. 保存到文件

### 创建工作流文件

```yaml
# ~/openclaw/workspace/lobster/daily-news.yaml

name: daily-news-briefing

args:
  news_url: "https://news.ycombinator.com"

steps:
  # 步骤1: 获取网页内容
  - name: fetch-news
    tool: shell
    args: ["curl", "-s", "{{news_url}}"]

  # 步骤2: Python调用AI提取和总结
  - name: summarize
    tool: python
    script: |
      import openai

      content = """{{fetch-news.output}}"""

      response = openai.chat.completions.create(
        model="gpt-4",
        messages=[{
          "role": "user",
          "content": f"Extract the top 5 headlines from this content:\n{content}\n\nThen create a 300-word summary of the main tech trends."
        }]
      )

      print(response.choices[0].message.content)

  # 步骤3: 保存到文件
  - name: save-briefing
    tool: shell
    args: ["tee", "~/Documents/daily-news/{{date}}.md"]
    input: "{{summarize.output}}"
```

### 配置定时执行

```json
// openclaw.json
{
  "crons": {
    "daily-news": {
      "schedule": "0 8 * * *",
      "workflow": "daily-news-briefing"
    }
  }
}
```

每天早上8点，Lobster会自动执行这个工作流。

## Lobster的局限

Lobster很强大，但不是万能的：

### 1. 需要预先定义

工作流需要提前写好，不能像Agent那样灵活应对未知情况。

**解决方案**：复杂场景用Agent，成熟流程用Lobster。

### 2. 调试成本

如果工作流出错，需要检查YAML定义、工具调用、数据流转。

**解决方案**：Lobster提供详细的执行日志。

### 3. 学习曲线

需要学习YAML语法和Lobster的工作流定义规范。

**解决方案**：从简单工作流开始，逐步学习高级特性。

---

**本节小结**

- Lobster是确定性的工作流引擎，解决LLM的不确定性问题
- 使用YAML定义工作流，步骤间可传递数据
- 支持硬编码工具和AI推理的混合执行
- Approval Gates保护敏感操作，需人工确认
- 与Pi Agent分工协作：Agent决策，Lobster执行
- 适用于重复性、多步骤、需要确定性的任务
