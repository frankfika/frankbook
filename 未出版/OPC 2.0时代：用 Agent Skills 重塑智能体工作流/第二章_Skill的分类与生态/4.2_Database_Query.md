---
section_id: "4.2"
title: "Database Query - 数据库查询助手"
status: draft
word_count: 2550
target_words: 2500
---

# 4.2 Database Query - 数据库查询助手

## 为什么需要Database Query

数据库是大多数应用的核心，但编写高效的SQL查询并不是一件容易的事。复杂的JOIN操作、性能优化、索引选择——这些都需要对数据库原理有深入理解。对于非数据库专家来说，面对复杂的数据需求时往往感到力不从心。

Database Query是一个社区开发的Skill，它将自然语言转换为优化的SQL查询。不需要记忆复杂的SQL语法，不需要纠结索引选择，只需要用日常语言描述你想要的数据，Claude就能帮你生成正确的查询语句。它是你随叫随到的数据库专家，让数据查询变得简单高效。

## Database Query包含什么

Database Query是一套智能数据库交互工具，涵盖查询全生命周期：

**自然语言查询**：
- 中文/英文描述转SQL
- 支持多表JOIN的复杂查询
- 聚合函数和分组统计
- 子查询和CTE表达式

**查询优化**：
- 执行计划分析
- 索引使用建议
- 慢查询诊断
- 性能瓶颈定位

**数据库管理**：
- 表结构查看
- 索引管理
- 数据导出导入
- 备份建议

**多数据库支持**：
- MySQL / MariaDB
- PostgreSQL
- SQLite
- MongoDB（NoSQL查询）

## 安装方法

```bash
# 安装Database Query
帮我安装 skill，地址是 https://github.com/community-skills/database-query
```

安装完成后，你可以直接通过自然语言与数据库交互。

## 实战应用

### 场景1：快速数据查询

**背景**：你需要从复杂的电商数据库中查询特定数据。

**传统做法**：
1. 查看表结构了解字段
2. 编写SQL语句
3. 调试JOIN条件
4. 优化查询性能

**使用Database Query**：

```
用户：查询2024年Q1销售额Top 10的商品，包含商品名称、销售额和订单数

Claude：我来帮你生成这个查询。
[Database Query分析表结构]

表结构分析：
- products: id, name, price, category_id
- orders: id, user_id, created_at, status
- order_items: id, order_id, product_id, quantity, price

生成的SQL：
```sql
SELECT
    p.name AS 商品名称,
    SUM(oi.quantity * oi.price) AS 销售额,
    COUNT(DISTINCT o.id) AS 订单数
FROM products p
JOIN order_items oi ON p.id = oi.product_id
JOIN orders o ON oi.order_id = o.id
WHERE o.created_at >= '2024-01-01'
  AND o.created_at < '2024-04-01'
  AND o.status = 'completed'
GROUP BY p.id, p.name
ORDER BY 销售额 DESC
LIMIT 10;
```

查询性能：
- 预计扫描行数：~15,000
- 建议使用索引：orders(created_at, status)
- 预计执行时间：< 100ms

需要我执行这个查询吗？[Y/n]
```

### 场景2：复杂数据分析

**背景**：你需要分析用户留存率和LTV（用户生命周期价值）。

**使用Database Query**：

```
用户：计算过去6个月每月新增用户的30天留存率

Claude：我来生成留存率分析查询。
[分析需求]

这是一个典型的留存分析查询，需要用到窗口函数：

```sql
WITH user_cohorts AS (
    -- 确定每个用户的注册月份
    SELECT
        id AS user_id,
        DATE_TRUNC('month', created_at) AS cohort_month
    FROM users
    WHERE created_at >= DATE_TRUNC('month', NOW() - INTERVAL '6 months')
),
user_activity AS (
    -- 计算每个用户的首次登录日期
    SELECT
        user_id,
        DATE_TRUNC('month', MIN(created_at)) AS first_login_month,
        COUNT(DISTINCT DATE(login_date)) AS active_days
    FROM user_logins
    GROUP BY user_id
)
SELECT
    uc.cohort_month AS 注册月份,
    COUNT(DISTINCT uc.user_id) AS 新增用户数,
    COUNT(DISTINCT CASE
        WHEN ua.first_login_month <= uc.cohort_month + INTERVAL '30 days'
        THEN ua.user_id
    END) AS 30天活跃用户数,
    ROUND(
        COUNT(DISTINCT CASE
            WHEN ua.first_login_month <= uc.cohort_month + INTERVAL '30 days'
            THEN ua.user_id
        END) * 100.0 / COUNT(DISTINCT uc.user_id),
        2
    ) AS 留存率_百分比
FROM user_cohorts uc
LEFT JOIN user_activity ua ON uc.user_id = ua.user_id
GROUP BY uc.cohort_month
ORDER BY uc.cohort_month;
```

查询说明：
1. user_cohorts: 确定用户注册的月份群组
2. user_activity: 统计用户的活跃情况
3. 主查询: 计算每个群组的留存率

建议索引：
```sql
CREATE INDEX idx_users_created_at ON users(created_at);
CREATE INDEX idx_logins_user_date ON user_logins(user_id, login_date);
```
```

### 场景3：查询性能优化

**背景**：你有一个运行缓慢的查询需要优化。

**使用Database Query**：

```
用户：优化这个慢查询：
SELECT * FROM orders WHERE YEAR(created_at) = 2024

Claude：我来分析并优化这个查询。
[查询分析]

=== 原查询问题 ===
1. 函数作用于列上 (YEAR(created_at))，导致索引失效
2. SELECT * 获取了所有列，增加了I/O
3. 缺少LIMIT，可能返回大量数据

=== 执行计划分析 ===
扫描类型：全表扫描
扫描行数：1,250,000行
使用索引：无
执行时间：2.3秒

=== 优化建议 ===

**方案1：改写查询（推荐）**
```sql
SELECT
    id, order_no, user_id, total_amount, status, created_at
FROM orders
WHERE created_at >= '2024-01-01'
  AND created_at < '2025-01-01'
ORDER BY created_at DESC
LIMIT 1000;
```
- 使用范围查询，可以利用索引
- 只选择需要的列
- 添加分页限制

**方案2：创建函数索引**（如果必须使用YEAR函数）
```sql
CREATE INDEX idx_orders_year ON orders((YEAR(created_at)));
```

**方案3：分区表**（如果数据量持续增长）
```sql
-- 按年分区
ALTER TABLE orders PARTITION BY RANGE (YEAR(created_at)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p_future VALUES LESS THAN MAXVALUE
);
```

=== 优化后效果 ===
扫描行数：45,000行（减少97%）
使用索引：idx_orders_created_at
执行时间：45ms（提升50倍）
```

### 场景4：数据导出与报表

**背景**：你需要生成一份月度销售报表并导出。

**使用Database Query**：

```
用户：生成2024年6月的销售报表，包含按地区和产品类别的统计

Claude：我来生成这个报表查询。
[构建报表SQL]

```sql
WITH monthly_sales AS (
    SELECT
        u.region AS 地区,
        p.category AS 产品类别,
        SUM(oi.quantity) AS 销售数量,
        SUM(oi.quantity * oi.price) AS 销售金额,
        COUNT(DISTINCT o.id) AS 订单数,
        COUNT(DISTINCT o.user_id) AS 购买用户数
    FROM orders o
    JOIN users u ON o.user_id = u.id
    JOIN order_items oi ON o.id = oi.order_id
    JOIN products p ON oi.product_id = p.id
    WHERE o.created_at >= '2024-06-01'
      AND o.created_at < '2024-07-01'
      AND o.status = 'completed'
    GROUP BY u.region, p.category
)
SELECT
    地区,
    产品类别,
    销售数量,
    ROUND(销售金额, 2) AS 销售金额,
    订单数,
    购买用户数,
    ROUND(销售金额 / 订单数, 2) AS 客单价
FROM monthly_sales
ORDER BY 销售金额 DESC;
```

导出选项：
1. CSV格式（适合Excel分析）
2. JSON格式（适合程序处理）
3. Markdown表格（适合文档嵌入）
4. 直接生成可视化图表

生成的报表预览：
| 地区 | 产品类别 | 销售数量 | 销售金额 | 订单数 | 购买用户数 | 客单价 |
|------|----------|----------|----------|--------|------------|--------|
| 华东 | 电子产品 | 1,234 | ¥456,789 | 567 | 423 | ¥805.62 |
| 华南 | 服装 | 2,345 | ¥345,678 | 789 | 567 | ¥437.93 |
| ... | ... | ... | ... | ... | ... | ... |

需要导出为哪种格式？[csv/json/markdown/chart]
```

### 场景5：数据库健康检查

**背景**：你想定期检查数据库的健康状况。

**使用Database Query**：

```
用户：检查数据库健康状况

Claude：我来执行数据库健康检查。
[健康检查中]

=== 表大小分析 ===
表名              行数      数据大小    索引大小    总大小
orders            1.2M      245 MB      89 MB       334 MB
users             456K      67 MB       23 MB       90 MB
products          12K       5 MB        2 MB        7 MB
order_items       3.4M      412 MB      156 MB      568 MB

=== 慢查询分析（过去24小时） ===
发现3个慢查询：
1. SELECT * FROM orders WHERE user_id = ?
   平均耗时：2.3s
   建议：添加复合索引 (user_id, created_at)

2. SELECT COUNT(*) FROM order_items WHERE ...
   平均耗时：1.8s
   建议：考虑使用汇总表

=== 索引使用情况 ===
未使用索引：
- idx_orders_old_column (从未使用，建议删除)

缺失索引建议：
- orders(user_id, created_at)
- order_items(order_id, product_id)

=== 表碎片分析 ===
高度碎片化的表：
- logs: 67% 碎片率，建议OPTIMIZE
- sessions: 45% 碎片率，建议OPTIMIZE

=== 连接状态 ===
当前连接数：45/100
活跃查询：12
慢查询：2（>1s）

=== 健康评分 ===
综合评分：78/100（良好）

优化建议优先级：
🔴 高：添加缺失索引
🟡 中：清理表碎片
🟢 低：删除未使用索引
```

## 技术实现原理

Database Query背后的核心技术：

**SQL生成引擎**：
- 基于LLM的自然语言理解
- 结合数据库schema的上下文
- 支持多种SQL方言转换

**查询分析**：
- EXPLAIN分析执行计划
- 统计信息解读
- 成本模型估算

**优化建议**：
- 索引选择算法
- 查询重写规则
- 反模式检测

## 最佳实践

### 1. 查询安全

使用Database Query时的安全注意事项：
- 不要在生产环境直接执行生成的查询
- 先审查SQL，确认无DELETE/UPDATE风险
- 使用只读账号进行查询测试

### 2. 性能意识

养成关注性能的习惯：
- 总是要求解释执行计划
- 大表查询务必添加LIMIT
- 定期检查和优化慢查询

### 3. 迭代优化

复杂查询的优化流程：
- 先用自然语言描述需求
- 生成并审查初始SQL
- 根据执行计划优化
- 测试并验证结果正确性

## 与其他Skill的协作

**配合PPTX Generator**：
```
用户：查询销售数据并生成汇报PPT

Claude：
1. [Database Query] 查询销售数据
2. [PPTX Generator] 生成数据可视化PPT
3. 输出：包含图表的汇报材料
```

**配合Document Skills**：
```
用户：导出数据库文档

Claude：
1. [Database Query] 获取表结构和关系
2. [Document Skills] 生成数据库文档
3. 输出：Markdown格式的数据库文档
```

## 小结

Database Query是数据查询的智能助手，它将复杂的SQL编写简化为自然语言描述：

**核心价值**：
- 自然语言生成SQL
- 自动查询优化建议
- 数据库健康诊断
- 降低数据库使用门槛

**适用场景**：
- 复杂数据分析
- 报表生成
- 性能优化
- 数据库维护

**使用技巧**：
- 清晰描述数据需求
- 关注执行计划建议
- 生产环境谨慎执行

对于需要频繁操作数据库的开发者来说，Database Query相当于一位7x24小时在线的数据库专家，帮你写出高效正确的SQL，让数据工作事半功倍。
