---
section_id: "1.3"
title: "实战案例：视频下载Skill"
status: draft
word_count: 5180
target_words: 5000
---

# 1.3 实战案例：视频下载Skill

## 案例背景

视频下载是一个常见但复杂的需求。不同的平台（YouTube、Bilibili、抖音等）有不同的技术方案，视频格式、清晰度、字幕等选项也各不相同。开发一个通用的视频下载Skill，既可以解决实际问题，又能展示完整的Skill开发流程。

本案例将带你从零开始，开发一个功能完善、易于使用的视频下载Skill。

## 需求分析

### 用户故事

作为内容创作者，我想要：
- 下载参考视频进行学习
- 备份有价值的教程视频
- 提取视频中的音频制作播客
- 批量下载系列课程内容

### 功能需求

**核心功能**：
1. 支持主流视频平台（YouTube、Bilibili、抖音等）
2. 可选视频清晰度（1080p、720p、480p等）
3. 支持下载字幕（如果有）
4. 支持仅提取音频

**进阶功能**：
1. 批量下载播放列表
2. 下载进度显示
3. 自动命名和分类
4. 格式转换（MP4、MKV、MP3等）

### 技术调研

GitHub搜索关键词：`video downloader`、`youtube-dl`、`yt-dlp`

经过调研，选择 **yt-dlp** 作为核心工具：
- 是youtube-dl的活跃分支，维护更及时
- 支持1000+视频网站
- 功能丰富，更新频繁（MIT许可证）
- 社区活跃，文档完善

## Skill设计与实现

### 第一步：创建目录结构

```bash
mkdir -p ~/.claude/skills/video-downloader/scripts
mkdir -p ~/.claude/skills/video-downloader/references
cd ~/.claude/skills/video-downloader
```

### 第二步：编写核心脚本

创建 `scripts/download.py`：

```python
#!/usr/bin/env python3
"""
视频下载脚本 - 基于yt-dlp
"""

import sys
import json
import subprocess
from pathlib import Path
from urllib.parse import urlparse

def get_platform(url):
    """识别视频平台"""
    domain = urlparse(url).netloc.lower()
    if 'bilibili' in domain:
        return 'bilibili'
    elif 'youtube' in domain or 'youtu.be' in domain:
        return 'youtube'
    elif 'douyin' in domain:
        return 'douyin'
    elif 'tiktok' in domain:
        return 'tiktok'
    return 'unknown'

def download_video(url, output_dir, quality='best', audio_only=False, subtitle=False):
    """
    下载视频

    Args:
        url: 视频URL
        output_dir: 输出目录
        quality: 视频质量 (best, 1080p, 720p, 480p, worst)
        audio_only: 是否仅下载音频
        subtitle: 是否下载字幕
    """
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    # 构建yt-dlp命令
    cmd = ['yt-dlp', url]

    # 设置输出模板
    cmd.extend(['-o', str(output_path / '%(title)s.%(ext)s')])

    # 格式选择
    if audio_only:
        cmd.extend(['-f', 'bestaudio', '-x', '--audio-format', 'mp3'])
    else:
        if quality == 'best':
            cmd.extend(['-f', 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best'])
        elif quality == '1080p':
            cmd.extend(['-f', 'bestvideo[height<=1080][ext=mp4]+bestaudio[ext=m4a]/best[height<=1080]'])
        elif quality == '720p':
            cmd.extend(['-f', 'bestvideo[height<=720][ext=mp4]+bestaudio[ext=m4a]/best[height<=720]'])
        elif quality == '480p':
            cmd.extend(['-f', 'bestvideo[height<=480][ext=mp4]+bestaudio[ext=m4a]/best[height<=480]'])

    # 字幕选项
    if subtitle and not audio_only:
        cmd.extend(['--write-subs', '--sub-lang', 'zh-CN,zh-TW,en', '--embed-subs'])

    # 添加进度条和元数据
    cmd.extend(['--newline', '--add-metadata'])

    # 执行下载
    try:
        result = subprocess.run(cmd, capture_output=True, text=True)

        if result.returncode == 0:
            # 解析输出，获取文件名
            for line in result.stderr.split('\n'):
                if 'Destination:' in line:
                    filename = line.split('Destination:')[-1].strip()
                    return {'success': True, 'file': filename}
            return {'success': True, 'message': 'Download completed'}
        else:
            return {'success': False, 'error': result.stderr}

    except Exception as e:
        return {'success': False, 'error': str(e)}

def batch_download(urls_file, output_dir, **kwargs):
    """批量下载"""
    results = []
    with open(urls_file, 'r') as f:
        urls = [line.strip() for line in f if line.strip()]

    for i, url in enumerate(urls, 1):
        print(f"Downloading {i}/{len(urls)}: {url}")
        result = download_video(url, output_dir, **kwargs)
        results.append({'url': url, **result})

    return results

if __name__ == '__main__':
    if len(sys.argv) < 3:
        print("Usage: download.py <url> <output_dir> [quality] [audio_only] [subtitle]")
        sys.exit(1)

    url = sys.argv[1]
    output_dir = sys.argv[2]
    quality = sys.argv[3] if len(sys.argv) > 3 else 'best'
    audio_only = sys.argv[4].lower() == 'true' if len(sys.argv) > 4 else False
    subtitle = sys.argv[5].lower() == 'true' if len(sys.argv) > 5 else False

    result = download_video(url, output_dir, quality, audio_only, subtitle)
    print(json.dumps(result, indent=2, ensure_ascii=False))
```

### 第三步：编写SKILL.md

```markdown
---
name: video-downloader
description: Download videos from YouTube, Bilibili, and other platforms
user-invocable: true
allowed-tools:
  - Read
  - Bash
  - Write
  - Glob
---

# Video Downloader

Download videos from popular platforms with customizable options.

## When to Use

Activate this skill when the user wants to:
- Download videos from YouTube, Bilibili, Douyin, or other supported platforms
- Extract audio from videos (e.g., for podcasts)
- Download subtitles along with videos
- Batch download videos from a playlist

## Parameters

- **URL**: The video URL to download
- **Output Directory**: Where to save the downloaded file (default: ~/Downloads/videos/)
- **Quality**: Video quality (best, 1080p, 720p, 480p, worst)
- **Audio Only**: Extract audio only (MP3 format)
- **Subtitles**: Download and embed subtitles (if available)

## Execution Steps

### 1. Validate Prerequisites

Check if yt-dlp is installed:

```bash
which yt-dlp || pip3 install yt-dlp
```

### 2. Parse User Request

Extract parameters from the user's request:
- URL (required)
- Quality preference (default: best)
- Audio only mode (default: false)
- Subtitle download (default: false)

### 3. Determine Output Directory

```bash
OUTPUT_DIR="${HOME}/Downloads/videos/$(date +%Y-%m)"
mkdir -p "$OUTPUT_DIR"
```

### 4. Execute Download

Use the download script:

```bash
python3 ~/.claude/skills/video-downloader/scripts/download.py \
  "{{URL}}" \
  "$OUTPUT_DIR" \
  "{{QUALITY}}" \
  "{{AUDIO_ONLY}}" \
  "{{SUBTITLES}}"
```

### 5. Verify and Report

Check the download result:
- If successful, report the file path and size
- If failed, analyze the error and suggest solutions

## Examples

### Download a YouTube video in best quality

User: "Download this video: https://youtube.com/watch?v=xxxxx"

Claude:
1. Extract URL from user input
2. Set quality to "best"
3. Execute download
4. Report: "Downloaded to ~/Downloads/videos/2024-01/Video Title.mp4"

### Download audio only for a podcast

User: "Extract the audio from this Bilibili video: https://b23.tv/xxxxx"

Claude:
1. Set audio_only to true
2. Execute download
3. Report: "Audio extracted to ~/Downloads/videos/2024-01/Title.mp3"

### Batch download a playlist

User: "Download all videos from this playlist: https://youtube.com/playlist?list=xxxxx"

Claude:
1. Use yt-dlp's playlist support
2. Download each video sequentially
3. Report progress for each item

## Error Handling

### Common Issues

**"URL not supported"**
- Check if the platform is supported by yt-dlp
- Suggest alternative tools if needed

**"Video is age-restricted"**
- Ask user to provide authentication cookies
- Or suggest alternative sources

**"Network error"**
- Retry with different network settings
- Suggest using proxy if needed

**"Disk space insufficient"**
- Check available space
- Suggest clearing old downloads

## Supported Platforms

- YouTube (including playlists)
- Bilibili (B站)
- Douyin (抖音)
- TikTok
- And 1000+ more sites supported by yt-dlp

## Notes

- Always respect copyright and terms of service
- Some platforms may require authentication for certain videos
- Download speed depends on network connection and platform
```

### 第四步：添加参考文档

创建 `references/troubleshooting.md`：

```markdown
# 视频下载故障排除

## 常见问题

### Q: 下载速度慢怎么办？
A: 尝试以下方法：
1. 检查网络连接
2. 使用代理（如果需要）
3. 选择较低的视频质量
4. 避开网络高峰期

### Q: 如何下载需要登录的视频？
A: 使用cookies文件：
```bash
yt-dlp --cookies-from-browser chrome "URL"
```

### Q: 如何批量下载？
A: 创建URL列表文件，每行一个URL，然后使用：
```bash
python3 scripts/download.py urls.txt output_dir
```

### Q: 支持的格式有哪些？
A: 默认下载MP4视频和MP3音频。可以通过yt-dlp参数自定义。

## 平台特定说明

### YouTube
- 支持播放列表下载
- 支持 age-restricted 视频（需要cookies）
- 支持自动字幕下载

### Bilibili
- 支持1080P高清（登录状态下）
- 支持弹幕下载（使用额外参数）
- 支持分P视频批量下载

### 抖音/TikTok
- 无水印下载
- 支持用户主页批量下载
```

## 测试与优化

### 测试用例

**测试1：基本下载**
```bash
python3 scripts/download.py "https://www.youtube.com/watch?v=dQw4w9WgXcQ" /tmp/test best false false
```
预期结果：成功下载视频文件

**测试2：音频提取**
```bash
python3 scripts/download.py "https://www.youtube.com/watch?v=dQw4w9WgXcQ" /tmp/test best true false
```
预期结果：成功提取MP3音频

**测试3：Bilibili下载**
```bash
python3 scripts/download.py "https://www.bilibili.com/video/BV1xx411c7mD" /tmp/test 1080p false true
```
预期结果：下载视频并嵌入中文字幕

### 性能优化

**添加并发下载支持**：

```python
from concurrent.futures import ThreadPoolExecutor

def batch_download_parallel(urls, output_dir, max_workers=3, **kwargs):
    """并行批量下载"""
    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        futures = []
        for url in urls:
            future = executor.submit(download_video, url, output_dir, **kwargs)
            futures.append((url, future))

        results = []
        for url, future in futures:
            try:
                result = future.result(timeout=300)  # 5分钟超时
                results.append({'url': url, **result})
            except Exception as e:
                results.append({'url': url, 'success': False, 'error': str(e)})

    return results
```

**添加下载缓存**：

```python
import hashlib
import pickle

CACHE_DIR = Path.home() / '.cache' / 'video-downloader'

def get_cache_key(url, **kwargs):
    """生成缓存键"""
    content = f"{url}:{json.dumps(kwargs, sort_keys=True)}"
    return hashlib.md5(content.encode()).hexdigest()

def check_cached(url, **kwargs):
    """检查是否有缓存的下载记录"""
    cache_key = get_cache_key(url, **kwargs)
    cache_file = CACHE_DIR / f"{cache_key}.json"
    if cache_file.exists():
        with open(cache_file, 'r') as f:
            return json.load(f)
    return None

def save_cache(url, result, **kwargs):
    """保存下载记录到缓存"""
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    cache_key = get_cache_key(url, **kwargs)
    cache_file = CACHE_DIR / f"{cache_key}.json"
    with open(cache_file, 'w') as f:
        json.dump(result, f)
```

## 使用示例

### 场景1：下载教程视频学习

```
用户：帮我下载这个Python教程视频 https://www.youtube.com/watch?v=xxxxx

Claude: 我来帮你下载这个教程视频。
[执行下载]

正在识别视频信息...
视频标题：Python Tutorial for Beginners - Full Course
平台：YouTube
可用清晰度：1080p, 720p, 480p

开始下载（1080p）...
进度：25%... 50%... 75%... 100%

下载完成！
文件位置：~/Downloads/videos/2024-01/Python Tutorial for Beginners - Full Course.mp4
文件大小：1.2GB
时长：3小时45分钟
```

### 场景2：提取音频制作播客

```
用户：把这个演讲视频转成音频，我想在通勤时听
URL: https://b23.tv/xxxxx

Claude: 我来提取音频。
[执行下载]

正在提取音频...
视频标题：2024 AI发展趋势演讲
转换为MP3格式（128kbps）

转换完成！
文件位置：~/Downloads/videos/2024-01/2024 AI发展趋势演讲.mp3
文件大小：45MB
时长：52分钟
```

### 场景3：批量下载课程

```
用户：下载这个播放列表的所有视频 https://www.youtube.com/playlist?list=xxxxx

Claude: 我来批量下载这个播放列表。
[分析播放列表]

播放列表：Machine Learning Course
视频数量：12个
开始批量下载...

[1/12] 01 - Introduction to ML ✓
[2/12] 02 - Linear Regression ✓
[3/12] 03 - Logistic Regression ✓
...
[12/12] 12 - Neural Networks ✓

全部下载完成！
文件保存在：~/Downloads/videos/2024-01/Machine Learning Course/
```

## 进阶扩展

### 添加Webhook通知

下载完成后发送通知：

```python
import requests

def notify_webhook(url, result):
    """发送Webhook通知"""
    webhook_url = os.environ.get('VIDEO_DOWNLOAD_WEBHOOK')
    if webhook_url:
        requests.post(webhook_url, json={
            'url': url,
            'status': 'success' if result['success'] else 'failed',
            'file': result.get('file'),
            'error': result.get('error')
        })
```

### 添加云存储上传

自动上传到云存储：

```python
def upload_to_cloud(local_path, cloud_provider='s3'):
    """上传到云存储"""
    if cloud_provider == 's3':
        import boto3
        s3 = boto3.client('s3')
        bucket = os.environ.get('S3_BUCKET')
        key = f"videos/{Path(local_path).name}"
        s3.upload_file(local_path, bucket, key)
        return f"s3://{bucket}/{key}"
```

## 小结

通过这个实战案例，我们学习了：

1. **完整的需求分析**。明确用户故事、功能需求和技术方案。
2. **GitHub工具选择**。选择yt-dlp作为核心工具，避免重复造轮子。
3. **脚本开发**。编写健壮的Python脚本，处理各种参数和错误。
4. **Skill文档**。编写清晰的SKILL.md，包含使用说明和示例。
5. **测试优化**。设计测试用例，添加并发和缓存优化。
6. **实际应用**。展示多种使用场景，验证Skill的实用价值。

这个视频下载Skill展示了如何将强大的开源工具封装成易用的AI Skill，让复杂的视频下载任务变得简单高效。
