---
section_id: "2.2.3"
title: "触发与权限控制"
status: draft
word_count: 0
target_words: 2500
---

# 2.2.3 触发与权限控制

## Skill的触发机制

理解Skill何时被激活，是正确使用Skill的关键。

### 自动触发 vs 手动触发

Agent Skills支持两种触发方式：

**自动触发**：AI根据用户输入的语义，自动判断是否激活某个Skill。

**手动触发**：用户明确输入斜杠命令（如`/code-reviewer`）来调用Skill。

这两种方式通过YAML Frontmatter中的字段控制：

```yaml
---
name: code-reviewer
user-invocable: true          # 允许手动触发
disable-model-invocation: false  # 允许自动触发
---
```

### 自动触发的原理

当用户输入一个请求时，Claude会执行以下步骤：

1. **语义解析**：分析用户输入的意图和关键词
2. **Skill匹配**：与所有已安装Skill的description进行语义匹配
3. **置信度计算**：计算每个Skill的匹配置信度（0-100%）
4. **阈值判断**：只有当置信度超过阈值（通常70%）时才激活
5. **冲突处理**：如果有多个Skill都超过阈值，选择置信度最高的

**示例**：

用户输入："帮我看看这段代码有没有问题"

Claude分析：
- 关键词："代码"、"看看"、"问题"
- 意图：代码审查

匹配Skill：
- code-reviewer（置信度：95%）→ 匹配
- test-writer（置信度：40%）→ 不匹配
- doc-generator（置信度：20%）→ 不匹配

结果：激活code-reviewer Skill

### 手动触发的优先级

当用户明确使用斜杠命令时，自动匹配的流程被跳过：

1. 用户输入：`/code-reviewer`
2. 直接查找name为`code-reviewer`的Skill
3. 如果找到，立即激活
4. 如果未找到，提示Skill不存在

这种方式的优势：
- **确定性**：不会有误判
- **速度**：不需要语义匹配
- **精确性**：可以传递特定参数

## 触发控制字段详解

### user-invocable字段

控制是否允许用户通过斜杠命令手动触发。

```yaml
user-invocable: true   # 用户可以通过 /skill-name 调用
user-invocable: false  # 只能通过AI自动触发（默认）
```

**何时设置为true**：
- Skill是高频使用的工具（如`/commit`、`/test`）
- 用户需要精确控制何时调用
- Skill有明确的单一职责

**何时设置为false**：
- Skill是后台辅助性的
- 需要根据上下文自动判断
- 用户不需要知道Skill的存在

### disable-model-invocation字段

控制是否允许AI自动触发。

```yaml
disable-model-invocation: false  # AI可以自动触发（默认）
disable-model-invocation: true   # 必须用户手动触发
```

**何时设置为true**：
- 操作具有风险（如删除数据、部署到生产环境）
- 需要用户明确确认
- 操作成本较高（消耗大量Token或时间）

**典型场景**：

```yaml
---
name: deploy-production
description: When user wants to deploy application to production
user-invocable: true
disable-model-invocation: true  # 必须用户明确输入/deploy-production
---
```

### 组合使用

这两个字段可以组合出四种行为模式：

| user-invocable | disable-model-invocation | 行为 |
|---------------|-------------------------|------|
| true | false | 自动触发 + 手动触发（最灵活） |
| true | true | 仅手动触发（最安全） |
| false | false | 仅自动触发（最透明） |
| false | true | 无法触发（禁用状态） |

**最常用组合**：

**自动+手动（true + false）**：
```yaml
# 代码审查Skill
# 平时自动识别代码相关问题
# 也可以手动输入 /code-reviewer 精确调用
user-invocable: true
disable-model-invocation: false
```

**仅手动（true + true）**：
```yaml
# 部署Skill
# 避免AI误触发导致生产事故
# 必须用户明确输入 /deploy-production
user-invocable: true
disable-model-invocation: true
```

**仅自动（false + false）**：
```yaml
# 文档格式化Skill
# 用户不需要知道它的存在
# AI自动识别文档相关请求并调用
user-invocable: false
disable-model-invocation: false
```

## 权限控制：allowed-tools

allowed-tools字段是Skill的"能力边界"声明。

### 为什么需要权限控制

想象一下，如果没有权限控制：
- 一个文档生成的Skill，理论上可以删除你的代码
- 一个数据分析的Skill，可以修改你的系统配置
- 任何一个Skill都可能造成意外破坏

allowed-tools通过"最小权限原则"限制每个Skill的能力范围。

### allowed-tools的使用

```yaml
---
name: doc-reader
allowed-tools:
  - Read        # 只能读取文件
  - Grep        # 可以搜索文件内容
---
```

这个Skill只能读取和搜索文件，不能修改文件、不能执行命令。

### 常见工具及其用途

**文件操作工具**：
- `Read`：读取文件内容
- `Write`：写入/修改文件
- `Edit`：编辑文件特定部分
- `Grep`：搜索文件内容

**命令执行工具**：
- `Bash`：执行Bash命令
- `Python`：执行Python代码

**MCP工具**：
- `mcp-{name}/{tool}`：特定的MCP工具，如`mcp-postgres/query`

### 权限配置示例

**只读分析Skill**：
```yaml
allowed-tools:
  - Read
  - Grep
# 可以：读取文件、分析内容
# 不能：修改文件、执行命令
```

**代码生成Skill**：
```yaml
allowed-tools:
  - Read
  - Write
  - Edit
  - Bash  # 用于运行测试
# 可以：读取、写入、修改文件，运行测试命令
# 不能：执行任意的系统命令
```

**数据库操作Skill**：
```yaml
allowed-tools:
  - Read
  - mcp-postgres/query
# 可以：读取文件，查询数据库
# 不能：修改数据库结构（除非显式添加）
```

### 安全最佳实践

**1. 最小权限原则**

只授予Skill完成任务所需的最小权限：

```yaml
# 好：只授予必要的权限
allowed-tools:
  - Read
  - Grep

# 差：授予过多权限
allowed-tools:
  - Read
  - Write
  - Edit
  - Bash
  - Python
```

**2. 高风险操作需要确认**

对于具有破坏性的操作，添加禁用自动触发：

```yaml
---
name: database-cleanup
allowed-tools:
  - Bash
  - mcp-postgres/query
disable-model-invocation: true  # 必须用户明确触发
---
```

**3. 敏感操作添加钩子检查**

使用`preToolUse`钩子进行额外的安全检查：

```yaml
---
name: git-push
allowed-tools:
  - Bash
hooks:
  preToolUse: |
    # 检查是否为force push
    if echo "$1" | grep -q "force"; then
      echo "Warning: Force push detected. Require explicit confirmation."
      exit 1
    fi
---
```

## 生命周期钩子：更精细的控制

Claude Code 2.1引入了生命周期钩子，允许Skill在特定时刻执行自定义逻辑。

### onLoad钩子

Skill加载时触发，用于初始化。

```yaml
---
name: project-analyzer
hooks:
  onLoad: |
    # 检查是否在项目根目录
    if [ ! -f "package.json" ] && [ ! -f "requirements.txt" ]; then
      echo "Error: Not in a recognized project directory"
      exit 1
    fi
---
```

### preToolUse钩子

工具调用前触发，用于权限检查和日志记录。

```yaml
---
name: secure-executor
allowed-tools:
  - Bash
  - Write
hooks:
  preToolUse: |
    # 记录工具调用
    echo "[$(date)] Tool: $TOOL_NAME, Args: $TOOL_ARGS" >> skill.log

    # 检查危险操作
    if [ "$TOOL_NAME" = "Write" ]; then
      # 禁止写入系统目录
      if echo "$TOOL_ARGS" | grep -qE "^/(etc|bin|sbin)/"; then
        echo "Error: Cannot write to system directories"
        exit 1
      fi
    fi
---
```

### onError钩子

执行出错时触发，用于错误处理和恢复。

```yaml
---
name: robust-deployer
hooks:
  onError: |
    # 记录错误
    echo "Error occurred: $ERROR_MESSAGE" >> error.log

    # 发送通知（如果有配置）
    if [ -n "$NOTIFICATION_URL" ]; then
      curl -X POST "$NOTIFICATION_URL" -d "Deployment failed: $ERROR_MESSAGE"
    fi

    # 尝试回滚
    if [ -f ".rollback.sh" ]; then
      echo "Attempting rollback..."
      bash .rollback.sh
    fi
---
```

## 实际案例：安全与便利的平衡

让我们看一个完整的权限控制案例。

**场景**：代码格式化Skill

需求：
- 可以自动格式化代码
- 但不能格式化系统配置文件
- 格式化前最好有确认（重要项目）

实现：

```yaml
---
name: code-formatter
description: When user asks to format code or when detecting unformatted code
user-invocable: true
disable-model-invocation: false
allowed-tools:
  - Read
  - Write
  - Edit
  - Bash
context: fork
hooks:
  preToolUse: |
    # 检查是否为系统文件
    if echo "$FILE_PATH" | grep -qE "^/(etc|usr|bin|sbin)/"; then
      echo "Error: Cannot modify system files: $FILE_PATH"
      exit 1
    fi

    # 检查是否为.git目录
    if echo "$FILE_PATH" | grep -q "/.git/"; then
      echo "Error: Cannot modify Git internal files"
      exit 1
    fi
---

## 触发条件

当用户需要格式化代码时激活：
- "格式化这个文件"
- "帮我整理代码"
- "代码风格检查"

## 执行步骤

1. **识别语言**
   - 根据文件扩展名确定编程语言
   - Python (.py): 使用black
   - JavaScript/TypeScript (.js/.ts): 使用prettier
   - Go (.go): 使用gofmt

2. **检查配置**
   - 查找项目根目录的配置文件（如pyproject.toml、.prettierrc）
   - 如果有配置，使用配置；如果没有，使用默认配置

3. **确认操作（重要项目）**
   - 如果检测到是Git仓库且有未提交的修改
   - 提示用户："将格式化文件，是否继续？"
   - 等待用户确认

4. **执行格式化**
   ```bash
   black {{file_path}}  # Python示例
   ```

5. **显示结果**
   - 显示修改前后的对比
   - 报告修改的行数

## 输出格式

```
## 格式化报告

**文件**：{{file_path}}
**语言**：Python
**工具**：black

**修改统计**：
- 修改行数：12
- 主要是：缩进调整、空行规范化

**示例修改**：
```diff
- def  my_function(x,y):
+ def my_function(x, y):
```
```
```

这个案例展示了：
- 允许自动触发，提供便利
- 限制可修改的文件范围（通过preToolUse钩子）
- 重要操作前确认（通过执行步骤中的条件）
- 最小权限（只允许Read、Write、Edit、Bash）

## 小结

触发与权限控制是Skill安全使用的核心：

**触发控制**：
- `user-invocable`：是否允许手动触发
- `disable-model-invocation`：是否允许自动触发
- 组合使用可以实现不同的交互模式

**权限控制**：
- `allowed-tools`：声明Skill可以使用的工具
- 遵循最小权限原则
- 高风险操作需要额外的确认机制

**生命周期钩子**：
- `onLoad`：初始化检查
- `preToolUse`：工具调用前的权限检查
- `onError`：错误处理和恢复

合理配置这些机制，可以在便利性和安全性之间取得平衡。
