---
section_id: "2.1"
title: "核心组成架构"
status: draft
word_count: 0
target_words: 3500
---

# 2.1 核心组成架构

## 一个典型的Skill长什么样

在深入了解Skill的编写方法之前，让我们先看看一个完整的Skill是什么样子。

假设你安装了一个名为`code-reviewer`的Skill，它的目录结构如下：

```
code-reviewer/
├── SKILL.md              # 核心定义文件
├── scripts/              # 辅助脚本目录
│   ├── complexity.py     # 代码复杂度分析脚本
│   ├── security_check.py # 安全检查脚本
│   └── format_report.py  # 报告格式化脚本
├── references/           # 参考文档目录
│   ├── python-style.md   # Python编码规范
│   ├── js-style.md       # JavaScript编码规范
│   └── security-rules.md # 安全规则手册
└── config.yaml           # 配置文件（可选）
```

这个结构展示了Skill的四个核心组成部分：

1. **SKILL.md**：定义Skill的元数据和行为
2. **scripts/**：存放辅助脚本
3. **references/**：存放参考文档
4. **config.yaml**：可选的配置文件

让我们逐一详细了解每个部分。

## SKILL.md：Skill的心脏

SKILL.md是Skill的核心文件，它定义了Skill的"身份"和"行为"。

一个典型的SKILL.md包含两部分：

### YAML Frontmatter

文件顶部用`---`包围的部分是YAML Frontmatter，用于定义元数据：

```yaml
---
name: code-reviewer
description: When user asks to review code for quality, security, or best practices
type: skill
disabled: false
user-invocable: true
disable-model-invocation: false
allowed-tools:
  - Read
  - Grep
  - Bash
  - Edit
context: fork
model: claude-4-opus
---
```

这些字段控制了Skill的基本行为：

- **name**：Skill的唯一标识符，也是调用时的名称
- **description**：触发条件描述，告诉AI什么时候使用这个Skill
- **type**：Skill类型，通常是`skill`
- **disabled**：是否禁用
- **user-invocable**：用户是否可以通过斜杠命令调用
- **disable-model-invocation**：是否禁止AI自动调用（需要用户手动触发）
- **allowed-tools**：该Skill可以使用的工具列表
- **context**：执行上下文，`fork`表示在独立环境中执行
- **model**：指定使用哪个模型运行

### Markdown正文

YAML之后的Markdown部分定义了Skill的具体行为：

```markdown
## 触发条件

当用户要求以下任一操作时激活：
- 审查代码质量
- 检查代码安全问题
- 评估代码是否符合最佳实践
- 代码走查（code review）

## 执行步骤

1. **收集上下文**
   - 读取待审查的文件
   - 识别编程语言和技术栈
   - 加载对应的编码规范

2. **静态分析**
   - 运行complexity.py检查代码复杂度
   - 运行security_check.py扫描安全漏洞
   - 检查代码风格和规范遵循情况

3. **生成报告**
   - 汇总所有发现的问题
   - 按严重程度分类（错误/警告/建议）
   - 提供具体的修复建议

4. **输出结果**
   - 使用format_report.py格式化输出
   - 生成Markdown格式的审查报告

## 输出格式

审查报告应包含以下部分：

### 概述
- 审查的文件数量和类型
- 发现的问题总数和分布
- 整体质量评分（A/B/C/D）

### 详细发现
对于每个问题：
- 位置（文件路径和行号）
- 严重程度（🔴错误/🟡警告/🟢建议）
- 问题描述
- 修复建议
- 参考链接（如有）

### 总结
- 优先级最高的3个问题
- 整体改进建议
- 下次审查的重点
```

正文通常包含三个层次：

1. **触发条件**：明确说明什么时候使用这个Skill
2. **执行步骤**：详细描述Skill的工作流程
3. **输出规范**：定义输出结果的格式和内容

## scripts/：能力的延伸

scripts目录存放Skill执行过程中需要的辅助脚本。这些脚本可以是Python、Bash、JavaScript等任何可执行文件。

### 为什么要用脚本

你可能会有疑问：既然AI可以直接生成代码，为什么还要用脚本？

答案在于**确定性与效率**的平衡。

**适合用脚本的情况**：

1. **确定性任务**：如解析特定格式的文件、计算复杂度指标
2. **重复性计算**：如统计代码行数、分析依赖关系
3. **外部工具调用**：如运行linter、执行测试套件
4. **数据处理**：如格式化输出、生成图表

**适合用AI的情况**：

1. **需要判断的任务**：如评估代码可读性、判断设计合理性
2. **创意性任务**：如生成改进建议、撰写文档
3. **模糊性任务**：如识别代码异味、评估架构质量

### 脚本示例

让我们看看code-reviewer Skill中的complexity.py脚本：

```python
#!/usr/bin/env python3
"""
代码复杂度分析器
使用radon库计算圈复杂度
"""

import sys
import json
from radon.visitors import ComplexityVisitor
from radon.complexity import sorted_results

def analyze_complexity(file_path):
    """分析单个文件的复杂度"""
    with open(file_path, 'r', encoding='utf-8') as f:
        code = f.read()

    try:
        visitor = ComplexityVisitor.from_code(code)
        results = sorted_results(visitor.functions + visitor.classes)

        # 转换结果为JSON格式
        output = []
        for item in results:
            output.append({
                'name': item.name,
                'complexity': item.complexity,
                'rank': item.rank,
                'lineno': item.lineno
            })

        return json.dumps(output, indent=2)
    except Exception as e:
        return json.dumps({'error': str(e)})

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: complexity.py <file_path>", file=sys.stderr)
        sys.exit(1)

    print(analyze_complexity(sys.argv[1]))
```

这个脚本使用radon库计算Python代码的圈复杂度，输出JSON格式的结果。

### 在Skill中调用脚本

SKILL.md中通过Bash工具调用脚本：

```markdown
## 执行步骤

1. **分析复杂度**
   ```bash
   python3 scripts/complexity.py {{file_path}}
   ```
   解析输出结果，标记复杂度超过10的函数

2. **安全检查**
   ```bash
   python3 scripts/security_check.py {{file_path}}
   ```
   解析安全问题报告
```

使用脚本的好处是：
- **精确性**：计算结果是确定的，不受AI随机性影响
- **效率**：脚本执行比AI推理快得多
- **复用性**：脚本可以被其他Skill复用
- **可测试性**：脚本可以独立测试和验证

## references/：知识的仓库

references目录存放Skill需要参考的文档。这些文档按需加载，不会一直占用上下文空间。

### 什么应该放在references

适合放在references目录的内容：

1. **编码规范文档**：如Python PEP 8、Google JavaScript Style Guide
2. **API参考手册**：如REST API文档、SDK参考
3. **最佳实践指南**：如安全编码指南、性能优化建议
4. **示例代码库**：如常见模式的实现示例
5. **配置选项说明**：如工具的配置参数详解

不适合放在references的内容：

1. **Skill的核心逻辑**：应该放在SKILL.md正文
2. **简短的示例**：可以直接写在SKILL.md中
3. **频繁变动的信息**：应该通过API获取或脚本计算

### 参考文档的结构

一个良好的reference文档应该有清晰的结构：

```markdown
# Python编码规范

## 命名规范

### 变量命名
- 使用小写加下划线：snake_case
- 避免单字母变量名（循环变量除外）
- 布尔变量使用is_或has_前缀

### 函数命名
- 使用动词开头：get_data, calculate_sum
- 避免过于笼统的名称：process, handle

## 代码布局

### 缩进
- 使用4个空格缩进
- 不要使用Tab

### 行长度
- 最大行长度：88字符（Black格式化器默认）
- 对于长字符串，使用括号隐式连接

## 常见问题

### 问题1：什么时候使用类？
当需要封装状态和行为时……

### 问题2：如何处理异常？
使用具体的异常类型，避免裸except……
```

### 按需加载机制

Skill不会一次性加载所有reference文档。相反，它根据当前需要，选择性地加载相关部分。

例如，当审查Python文件时：

```markdown
## 执行步骤

1. **识别语言**
   确定待审查文件是Python文件

2. **加载规范**
   读取references/python-style.md中的相关章节

3. **对照检查**
   将代码与规范逐条对比
```

这种按需加载机制确保：
- 只加载必要的文档，节省Token
- 可以包含大量参考资料而不影响性能
- 不同场景可以加载不同的参考文档

## config.yaml：可选的配置

config.yaml是可选的配置文件，用于存储Skill的设置参数。

### 配置文件的作用

config.yaml主要用于：

1. **环境配置**：如API端点、数据库连接信息
2. **行为调整**：如阈值设置、开关选项
3. **个性化设置**：如输出格式偏好、语言选择
4. **凭据管理**：如API密钥（推荐使用环境变量）

### 配置文件示例

```yaml
# config.yaml

# 分析设置
analysis:
  complexity_threshold: 10  # 圈复杂度阈值
  max_line_length: 88       # 最大行长度
  min_test_coverage: 80     # 最小测试覆盖率

# 检查项开关
checks:
  security: true
  performance: true
  style: true
  documentation: false      # 默认不检查文档

# 输出设置
output:
  format: markdown          # 输出格式：markdown/html/json
  language: zh-CN           # 输出语言
  include_examples: true    # 是否包含修复示例

# 外部工具路径
tools:
  pylint: /usr/local/bin/pylint
  mypy: /usr/local/bin/mypy
  bandit: /usr/local/bin/bandit
```

### 在Skill中读取配置

SKILL.md中可以通过变量引用配置：

```markdown
## 执行步骤

1. **加载配置**
   读取config.yaml中的分析设置

2. **复杂度检查**
   使用阈值{{analysis.complexity_threshold}}判断复杂度是否超标

3. **安全检查**
   {% if checks.security %}
   运行安全扫描
   {% endif %}
```

使用配置文件的好处：
- **灵活性**：用户可以自定义Skill的行为
- **环境适应**：不同环境可以使用不同配置
- **版本管理**：配置与代码分离，便于管理

## 目录结构最佳实践

让我们总结一些目录结构的最佳实践。

### 最小化原则

一个Skill应该只包含必要的文件：

```
minimal-skill/
└── SKILL.md              # 必需
```

只有当你确实需要scripts或references时，才添加这些目录。

### 命名规范

- Skill目录名使用小写和连字符：`code-reviewer`
- 脚本文件使用描述性名称：`analyze_complexity.py`
- Reference文档按主题命名：`python-style.md`
- 避免使用空格和特殊字符

### 文件组织

按功能组织文件，而不是按类型：

```
good-example/
├── SKILL.md
├── scripts/
│   ├── analyze/          # 分析类脚本
│   │   ├── complexity.py
│   │   └── security.py
│   └── report/           # 报告类脚本
│       ├── format.py
│       └── chart.py
└── references/
    ├── languages/        # 编程语言规范
    │   ├── python.md
    │   └── javascript.md
    └── frameworks/       # 框架特定规范
        ├── django.md
        └── react.md
```

### 依赖管理

如果scripts需要外部依赖，应该在Skill目录中包含依赖说明：

```
skill-with-deps/
├── SKILL.md
├── scripts/
│   └── analyzer.py
├── requirements.txt      # Python依赖
└── README.md             # 安装说明
```

README.md中应该包含：

```markdown
## 安装依赖

```bash
pip install -r requirements.txt
```

## 依赖列表

- radon: 代码复杂度分析
- bandit: 安全漏洞扫描
- pylint: 代码风格检查
```

## 完整示例：文档生成Skill

让我们通过一个完整的例子，看看所有组成部分如何协同工作。

### 目录结构

```
doc-generator/
├── SKILL.md
├── scripts/
│   ├── extract_api.py      # 从代码提取API文档
│   ├── generate_toc.py     # 生成目录
│   └── format_code.py      # 格式化代码示例
├── references/
│   ├── api-templates/      # API文档模板
│   │   ├── rest.md
│   │   └── graphql.md
│   └── style-guides/       # 文档风格指南
│       ├── technical.md
│       └── tutorial.md
└── config.yaml
```

### SKILL.md

```yaml
---
name: doc-generator
description: When user needs to generate documentation from code or create technical documents
type: skill
context: fork
allowed-tools:
  - Read
  - Write
  - Bash
---

## 触发条件

当用户需要以下任一操作时激活：
- 从代码生成API文档
- 创建技术文档
- 生成README文件
- 创建教程或指南

## 执行步骤

1. **分析需求**
   - 确定文档类型：API文档/技术文档/教程
   - 确定目标读者：开发者/最终用户/管理员
   - 确定输出格式：Markdown/HTML/PDF

2. **收集素材**
   - 读取源代码文件（如果是API文档）
   - 读取现有的文档片段
   - 收集示例代码

3. **生成内容**
   - 根据文档类型加载对应的reference模板
   - 使用scripts/extract_api.py提取API信息（如需要）
   - 生成文档的各个章节

4. **格式化输出**
   - 使用scripts/generate_toc.py生成目录
   - 使用scripts/format_code.py格式化代码示例
   - 应用风格指南

5. **输出结果**
   - 将生成的文档写入指定路径
   - 提供预览链接（如适用）

## 输出规范

生成的文档应包含：

- 清晰的标题和概述
- 完整的目录
- 代码示例（带有语法高亮）
- 必要的图表或截图占位符
- 相关链接和参考资料
```

### config.yaml

```yaml
documentation:
  default_format: markdown
  code_theme: monokai
  include_toc: true
  max_toc_depth: 3

languages:
  - python
  - javascript
  - typescript
  - go

output:
  directory: ./docs
  naming_pattern: "{title}-{date}"
```

## 小结

Skill的目录结构遵循清晰的分层原则：

- **SKILL.md**：定义Skill的身份和行为，是必需的
- **scripts/**：存放辅助脚本，实现确定性任务
- **references/**：存放参考文档，按需加载
- **config.yaml**：可选的配置文件，提供灵活性

理解每个部分的作用和设计原则，是编写高质量Skill的基础。

在接下来几节，我们将深入探讨SKILL.md的编写细节，包括Frontmatter字段的完整说明、Markdown正文的编写技巧、以及触发机制和权限控制的配置方法。
