---
section_id: "2.2.4"
title: "高级配置：model、context、agent"
status: draft
word_count: 0
target_words: 2500
---

# 2.2.4 高级配置：model、context、agent

## 为什么需要高级配置

在前面的章节中，我们已经了解了Skill的基本配置字段。但对于复杂的生产环境，这些基础配置可能不够用。

想象一下这些场景：
- 一个复杂的架构设计Skill需要最强的推理能力
- 一个只需要格式化输出的Skill不需要昂贵的Opus模型
- 一个长时间运行的任务需要避免污染主对话
- 一个Skill需要特定的Subagent配置来执行

这就是高级配置字段存在的意义：让Skill能够根据具体需求，精细化控制执行环境。

## model字段：选择合适的AI模型

Claude系列提供了多个模型，各有特点：

| 模型 | 能力 | 速度 | 成本 | 适用场景 |
|------|------|------|------|----------|
| claude-4-opus | 最强 | 较慢 | 最高 | 复杂推理、架构设计 |
| claude-4-sonnet | 强 | 中等 | 中等 | 通用任务、代码生成 |
| claude-4-haiku | 良好 | 快 | 低 | 简单任务、格式化 |

### 如何配置model字段

```yaml
---
name: architecture-designer
model: claude-4-opus  # 复杂架构需要强推理
---
```

```yaml
---
name: json-formatter
model: claude-4-haiku  # 简单格式化用Haiku就够了
---
```

如果不指定model字段，使用系统默认模型（通常是claude-4-sonnet）。

### 模型选择的实践建议

**使用Opus的场景**：
- 系统架构设计
- 复杂算法实现
- 跨领域的综合分析
- 需要深度推理的任务

**使用Sonnet的场景（默认）**：
- 日常代码生成
- 文档撰写
- 数据分析
- 大多数常规任务

**使用Haiku的场景**：
- 数据格式转换
- 简单的文本处理
- 模板填充
- 快速响应类任务

**成本考量**：

假设一个Skill每天被调用100次：
- 使用Opus：每次$0.02，每天$2，每年$730
- 使用Sonnet：每次$0.006，每天$0.6，每年$219
- 使用Haiku：每次$0.001，每天$0.1，每年$36.5

对于简单的格式化任务，使用Haiku可以节省95%的成本。

## context字段：控制执行环境

context字段决定Skill在哪个上下文中执行。

### 两种context模式

**inline（内联模式）**：
```yaml
context: inline  # 在主对话上下文中执行（默认）
```

- Skill和主对话共享同一个上下文
- 执行过程中产生的信息保留在对话中
- 适合简单、快速的任务

**fork（分叉模式）**：
```yaml
context: fork  # 在独立的上下文中执行
```

- Skill在一个全新的上下文中执行
- 执行完成后，只有结果返回主对话
- 中间过程不影响主对话
- 适合复杂、长时间运行的任务

### 对比与选择

| 特性 | inline | fork |
|------|--------|------|
| 上下文隔离 | 无 | 完全隔离 |
| 执行速度 | 快（无fork开销） | 稍慢（有fork开销） |
| 上下文污染 | 可能 | 不会 |
| 并发执行 | 不支持 | 支持 |
| 适用场景 | 简单快速任务 | 复杂长时间任务 |

**inline模式适用场景**：

```yaml
---
name: quick-formatter
context: inline
---
# 简单的格式化任务，快速完成
```

**fork模式适用场景**：

```yaml
---
name: project-analyzer
context: fork
---
# 需要分析整个项目，可能耗时较长
# 隔离执行避免污染主对话
```

### context: fork的进阶用法

当使用`context: fork`时，还可以配合`agent`字段指定由哪个Subagent执行：

```yaml
---
name: frontend-code-generator
context: fork
agent: frontend-specialist
---
```

这表示：
1. 创建一个fork的上下文
2. 在这个上下文中加载`frontend-specialist` Subagent
3. 让这个Subagent执行本Skill

这种方式适合复杂的项目协作，不同Skill由专门的Subagent处理。

## agent字段：指定执行代理

agent字段用于指定执行Skill的Subagent。这需要配合`context: fork`使用。

### 基本用法

```yaml
---
name: database-optimizer
context: fork
agent: database-expert
---
```

### 多级Subagent架构

在复杂的AI应用中，可以构建多级Subagent架构：

**主Agent**：接收用户请求，决定调用哪个Skill

**领域Subagent**：专门处理某个领域的任务

```yaml
# database-expert Subagent配置
name: database-expert
type: subagent
expertise:
  - SQL优化
  - 索引设计
  - 查询分析
```

**Skill**：定义具体的执行流程

```yaml
# database-optimizer Skill
---
name: database-optimizer
context: fork
agent: database-expert
---
## 执行步骤
1. 分析慢查询日志
2. 识别性能瓶颈
3. 提供优化建议
```

### agent字段的使用场景

**1. 专业化分工**

不同的任务由专门的Subagent处理：

```yaml
# 前端任务
name: react-component-generator
agent: frontend-expert

# 后端任务
name: api-endpoint-designer
agent: backend-expert

# 数据库任务
name: schema-designer
agent: database-expert
```

**2. 多语言支持**

不同语言的代码由专门的Subagent处理：

```yaml
name: python-code-reviewer
agent: python-expert

name: golang-code-reviewer
agent: golang-expert
```

**3. 安全隔离**

敏感操作由受控的Subagent执行：

```yaml
name: production-deployer
agent: ops-expert  # 具有生产环境权限的Subagent
disable-model-invocation: true
```

## 完整配置示例

让我们看几个完整的配置示例。

### 示例1：复杂架构设计Skill

```yaml
---
name: system-architect
model: claude-4-opus  # 需要最强推理能力
context: fork         # 复杂任务，隔离执行
agent: architecture-expert  # 由架构专家Subagent执行
allowed-tools:
  - Read
  - Write
  - Bash
  - mcp-diagram/draw  # 可以调用绘图MCP
user-invocable: true
disable-model-invocation: false
---

## 触发条件

当用户需要设计系统架构时激活，包括：
- 设计微服务架构
- 选择技术栈
- 设计数据模型
- 规划部署架构

## 执行步骤

1. **需求分析**
   - 理解功能需求
   - 识别非功能需求（性能、可用性、扩展性）
   - 确定约束条件

2. **架构设计**
   - 设计整体架构
   - 选择技术组件
   - 设计数据流

3. **可视化**
   - 使用mcp-diagram绘制架构图
   - 生成技术文档

4. **输出交付**
   - 架构设计文档
   - 技术选型报告
   - 实施路线图
```

### 示例2：快速格式化Skill

```yaml
---
name: json-formatter
model: claude-4-haiku  # 简单任务，用Haiku节省成本
context: inline        # 简单快速，不需要隔离
allowed-tools:
  - Read
  - Write
user-invocable: true
---

## 触发条件

当用户需要格式化JSON时激活。

## 执行步骤

1. 读取用户提供的JSON
2. 格式化（美化输出）
3. 保存或显示结果
```

### 示例3：安全敏感的数据处理Skill

```yaml
---
name: sensitive-data-processor
model: claude-4-opus
context: fork
agent: security-officer  # 由安全专员Subagent执行
allowed-tools:
  - Read
  - mcp-secure-db/query  # 只能访问安全数据库
user-invocable: true
disable-model-invocation: true  # 必须用户明确触发
hooks:
  preToolUse: |
    # 记录所有数据库查询
    echo "[$(date)] Query: $1" >> audit.log

    # 检查是否有敏感字段
    if echo "$1" | grep -qi "password\|secret\|token"; then
      echo "Error: Cannot query sensitive fields directly"
      exit 1
    fi
---

## 触发条件

处理敏感数据的操作，必须用户明确请求。

## 执行步骤

1. **身份验证**
   - 确认用户有权限访问请求的数据

2. **数据处理**
   - 执行查询
   - 脱敏处理（如果需要）

3. **审计记录**
   - 记录操作日志
   - 生成审计报告
```

## 高级配置的性能影响

不同的配置组合对性能有显著影响。

### model选择的性能影响

| 模型 | 平均响应时间 | 每小时成本（100次调用） |
|------|-------------|----------------------|
| Opus | 5-10秒 | $2 |
| Sonnet | 2-5秒 | $0.6 |
| Haiku | <2秒 | $0.1 |

### context选择的性能影响

**inline模式**：
- 启动时间：0ms（直接使用现有上下文）
- 内存占用：低（共享上下文）
- 适用：简单任务

**fork模式**：
- 启动时间：200-500ms（创建新上下文）
- 内存占用：中等（独立上下文）
- 适用：复杂任务

### 配置优化建议

**1. 成本优先**
- 默认使用Haiku
- 只在需要复杂推理时使用Opus
- 缓存Opus的结果，避免重复调用

**2. 速度优先**
- 使用inline context
- 使用Haiku或Sonnet
- 简化Skill的执行步骤

**3. 质量优先**
- 使用Opus
- 使用fork context隔离
- 允许多轮迭代优化

## 小结

高级配置字段让Skill能够精细化控制执行环境：

**model字段**：
- 选择合适的AI模型
- 在能力、速度、成本间取得平衡
- Opus用于复杂推理，Haiku用于简单任务

**context字段**：
- inline：快速，共享上下文
- fork：隔离，支持并发
- 根据任务复杂度选择

**agent字段**：
- 指定执行Skill的Subagent
- 实现专业化分工
- 适合复杂项目架构

合理使用这些高级配置，可以显著提升Skill的性能、安全性和用户体验。
