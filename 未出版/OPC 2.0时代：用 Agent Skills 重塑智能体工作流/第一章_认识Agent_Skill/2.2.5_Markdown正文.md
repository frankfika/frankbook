---
section_id: "2.2.5"
title: "Markdown正文：三个层次"
status: draft
word_count: 2650
target_words: 2500
---

# 2.2.5 Markdown正文：三个层次

## 为什么需要三层结构

YAML Frontmatter定义了Skill的"身份"和"权限"，但真正让Skill发挥作用的是Markdown正文。一个好的Markdown正文需要回答三个核心问题：

1. **什么时候做？** —— 触发条件
2. **怎么做？** —— 执行步骤
3. **做成什么样？** —— 输出规范

这三个问题对应着Markdown正文的三个层次。这种结构化的设计不是随意的，而是基于AI执行任务的认知规律。

想象一下你教一个新员工做某件事情：
- 首先你要告诉他什么情况下需要做这件事（触发条件）
- 然后详细说明具体的操作步骤（执行步骤）
- 最后明确交付物的标准（输出规范）

缺少任何一层都会导致执行偏差：
- 没有触发条件：不知道什么时候该做
- 没有执行步骤：不知道具体怎么做
- 没有输出规范：不知道做成什么样算完成

## 第一层：触发条件

触发条件层解决"什么时候激活这个Skill"的问题。

### 触发条件的本质

触发条件不是简单的关键词匹配，而是语义层面的条件声明。它需要帮助AI理解：

- 用户请求的意图是否与这个Skill匹配
- 当前场景是否适合使用这个Skill
- 有没有其他Skill更适合处理这个请求

### 编写好的触发条件

**原则1：覆盖主要场景**

一个触发条件应该覆盖所有合理的激活场景：

```markdown
## 触发条件

当用户需要以下任一操作时激活：
- 审查代码质量
- 检查代码安全问题
- 评估代码是否符合最佳实践
- 请求代码改进建议
```

**原则2：包含关键词提示**

列出用户可能使用的关键词，帮助AI识别：

```markdown
**触发关键词**：
- "帮我看看这段代码"
- "检查这个函数"
- "代码有没有问题"
- "审查一下"
```

**原则3：明确边界**

说明哪些情况不应该触发：

```markdown
**不触发场景**：
- 用户只是询问编程概念（如"什么是递归"）
- 用户要求直接修改代码而非审查
- 用户询问的是配置或环境问题
```

### 触发条件的实践案例

**案例1：代码审查Skill**

```markdown
## 触发条件

当用户需要审查代码时激活，包括：
- 代码质量评估
- 安全检查
- 性能分析
- 风格规范审查

**触发示例**：
- "帮我审查这段Python代码"
- "检查这个函数有没有安全问题"
- "这段代码写得怎么样"
- "看看有没有优化空间"

**不触发场景**：
- 用户只是粘贴代码片段询问"这是什么意思"
- 用户要求"帮我修改这个bug"（应该使用debug Skill）
```

**案例2：周报生成Skill**

```markdown
## 触发条件

当用户需要生成工作周报时激活：
- 基于Git提交记录生成周报
- 汇总本周完成的任务
- 生成下周工作计划

**触发示例**：
- "生成本周周报"
- "帮我写周报"
- "总结一下这周做了什么"
- "看看这周提交了哪些代码"

**不触发场景**：
- 用户询问"周报应该怎么写"（这是咨询，不是生成）
- 用户要求"修改上周的周报"（应该使用edit Skill）
```

## 第二层：执行步骤

执行步骤层是Skill的核心，详细描述如何完成任务。

### 步骤设计原则

**原则1：原子化**

每个步骤应该是不可分割的最小操作单元：

```markdown
## 执行步骤

1. **读取文件**
   - 使用Read工具读取用户指定的文件
   - 验证文件格式是否正确
   - 如果文件不存在，提示用户提供正确路径

2. **分析内容**
   - 识别文件类型和结构
   - 提取关键信息
   - 标记需要关注的部分
```

**原则2：可验证**

每个步骤应该有明确的完成标准：

```markdown
3. **运行检查**
   - 执行代码检查工具
   - 收集输出结果
   - ✓ 完成标准：获得工具输出的完整结果
```

**原则3：可恢复**

考虑失败情况的处理：

```markdown
4. **处理结果**
   - 如果检查通过：生成"无问题"报告
   - 如果发现问题：
     - 按严重程度分类
     - 生成修复建议
     - 提供示例代码
```

### 步骤中的条件判断

执行步骤经常需要条件判断，应该明确说明：

```markdown
## 执行步骤

1. **环境检查**
   - 检查必要的工具是否已安装
   - 如果未安装：
     - 询问用户是否允许自动安装
     - 或提供手动安装指南

2. **文件处理**
   - 如果用户提供了文件路径：直接使用
   - 如果没有提供：
     - 列出当前目录下的相关文件
     - 询问用户要处理哪个文件

3. **深度分析（可选）**
   - 如果用户要求详细分析：执行完整检查流程
   - 如果只是快速检查：只执行基础检查
```

### 工具调用的明确说明

当步骤涉及工具调用时，应该明确说明：

```markdown
## 执行步骤

1. **代码分析**
   - 使用Read工具读取目标文件
   - 使用Grep工具搜索相关函数定义
   - 使用Bash工具运行代码检查命令：
     ```bash
     pylint {{file_path}}
     ```

2. **结果解析**
   - 解析pylint的输出
   - 提取错误和警告信息
   - 按文件和行号组织

3. **报告生成**
   - 使用Write工具生成报告文件
   - 或使用Edit工具在现有文档中添加审查结果
```

### 执行步骤的长度控制

执行步骤不宜过长或过短：

- **太短**：步骤过于笼统，AI不知道如何执行
- **太长**：步骤过于琐碎，限制AI的灵活性

**推荐长度**：
- 简单Skill：3-5个步骤
- 中等Skill：5-8个步骤
- 复杂Skill：8-12个步骤

如果步骤过多，考虑拆分成多个Skill，或使用子任务模式。

## 第三层：输出规范

输出规范层定义Skill应该产生什么样的结果。

### 输出规范的重要性

没有输出规范，AI可能会：
- 输出格式不统一
- 遗漏关键信息
- 提供过多或过少的内容
- 使用不合适的表达方式

### 输出规范的内容

**1. 格式要求**

```markdown
## 输出格式

审查报告应使用以下结构：

### 1. 概述
- 审查的文件数量
- 发现的问题统计
- 整体质量评级（A/B/C/D）

### 2. 详细发现
对于每个问题：
- **位置**：文件路径和行号
- **严重程度**：错误/警告/建议
- **描述**：问题说明
- **修复建议**：具体的修改方法

### 3. 总结
- 优先级最高的3个问题
- 后续改进建议
```

**2. 内容要求**

```markdown
## 输出内容

报告必须包含：
- ✓ 具体的文件路径和行号
- ✓ 可操作的修复建议
- ✓ 优先级排序

报告可选包含：
- ○ 代码示例
- ○ 参考链接
- ○ 最佳实践说明

报告不应包含：
- ✗ 与问题无关的背景介绍
- ✗ 过于笼统的建议（如"代码需要改进"）
- ✗ 技术细节过深的解释（除非用户要求）
```

**3. 长度要求**

```markdown
## 输出长度

- **简短模式**（默认）：只报告最严重的前5个问题
- **详细模式**（用户要求时）：报告所有发现的问题
- **总结长度**：不超过3句话的简短总结
- **详细描述**：每个问题100-200字的说明
```

### 输出示例的价值

提供具体的输出示例，帮助AI理解期望的格式：

```markdown
## 示例输出

### 简短报告示例

```
## 代码审查报告：app.py

**状态**：⚠️ 需改进（发现3个问题）

**优先级问题**：
1. Line 45: 函数缺少异常处理
2. Line 78: 变量命名不清晰
3. Line 102: 行长度超过规范

**建议**：添加try-except块，使用描述性变量名
```

### 详细报告示例

```
## 代码审查报告

### 概述
- 审查文件：3个
- 发现问题：5个（2错误，2警告，1建议）
- 质量评级：B

### 详细发现

🔴 **错误1**：未处理异常（app.py:45）
- 描述：数据库查询可能抛出异常，但代码中没有try-except块
- 建议：添加异常处理，记录错误日志
- 示例：
  ```python
  try:
      result = db.query(sql)
  except Exception as e:
      logger.error(f"Query failed: {e}")
      return None
  ```
...
```
```

## 三层次的协作关系

三个层次不是孤立的，而是相互支撑的关系。

### 层次间的引用关系

```markdown
## 触发条件

当用户需要**生成周报**时激活...

## 执行步骤

1. **收集数据**
   - 根据触发条件中提到的"周报"需求，收集本周数据
   - ...

## 输出规范

### 格式
- 按照执行步骤中收集的数据类型，组织成周报格式
- ...
```

### 层次间的平衡

**触发条件 vs 执行步骤**：
- 触发条件说明"什么情况下做"
- 执行步骤说明"具体怎么做"
- 不要在触发条件中写操作细节
- 不要在执行步骤中重复触发逻辑

**执行步骤 vs 输出规范**：
- 执行步骤关注过程
- 输出规范关注结果
- 执行步骤中提到的重要信息，应该在输出规范中体现
- 输出规范要求的格式，应该在执行步骤中准备

## 编写技巧与常见错误

### 编写技巧

**技巧1：使用清晰的标题**

```markdown
## 触发条件          ✓ 清晰
## 执行流程          ✓ 清晰
## 输出规范          ✓ 清晰
## 条件              ✗ 太模糊
## 步骤              ✗ 太笼统
```

**技巧2：列表优于段落**

```markdown
✓ 使用列表：
1. 读取文件
2. 分析内容
3. 生成报告

✗ 避免长段落：
首先你需要读取文件，然后分析文件的内容...
```

**技巧3：具体而非抽象**

```markdown
✓ 具体：
检查代码是否符合PEP 8规范，包括：
- 变量命名使用snake_case
- 行长度不超过88字符
- 函数长度不超过50行

✗ 抽象：
检查代码风格是否符合规范
```

### 常见错误

**错误1：触发条件过于宽泛**

```markdown
✗ 问题：
## 触发条件
当用户需要编程帮助时激活

✓ 改进：
## 触发条件
当用户需要审查代码质量时激活，包括：
- 代码风格检查
- 安全漏洞扫描
- 性能问题分析
```

**错误2：执行步骤缺少细节**

```markdown
✗ 问题：
## 执行步骤
1. 检查代码
2. 生成报告

✓ 改进：
## 执行步骤
1. **静态分析**
   - 使用pylint检查代码规范
   - 使用bandit检查安全问题
   - 记录所有发现的问题

2. **报告生成**
   - 按严重程度分类问题
   - 为每个问题提供修复建议
   - 生成Markdown格式的报告
```

**错误3：输出规范过于简单**

```markdown
✗ 问题：
## 输出格式
返回检查结果

✓ 改进：
## 输出格式

### 结构
1. **概述**：文件数量、问题统计、质量评级
2. **详细发现**：位置、严重程度、描述、建议
3. **总结**：优先级问题、改进方向

### 示例
[提供具体的输出示例]
```

## 完整案例：三层结构的实战

让我们通过一个完整的例子，展示三层结构如何协同工作。

**场景**：代码格式化Skill

```markdown
## 触发条件

当用户需要格式化代码时激活：
- 请求"格式化这个文件"
- 要求"整理代码风格"
- 提到"代码太乱，帮我排版"

**触发示例**：
- "格式化app.py"
- "帮我整理这段代码的格式"
- "代码风格不对，帮我调整"

**不触发场景**：
- 用户询问代码逻辑问题（非格式问题）
- 用户要求重构代码结构（应该使用refactor Skill）

## 执行步骤

1. **识别语言**
   - 根据文件扩展名确定编程语言
   - 支持的类型：Python(.py)、JavaScript(.js/.ts)、Go(.go)
   - 如果不支持，提示用户

2. **检查配置**
   - 查找项目根目录的配置文件
   - Python: pyproject.toml、setup.cfg
   - JavaScript: .prettierrc、.eslintrc
   - 如果有配置，使用配置；如果没有，使用默认配置

3. **确认操作**
   - 如果是Git仓库且有未提交修改：
     - 提示用户："将格式化{{file_path}}，是否继续？"
     - 等待用户确认

4. **执行格式化**
   - Python: 使用black
   - JavaScript: 使用prettier
   - Go: 使用gofmt
   - 执行格式化命令

5. **显示结果**
   - 显示修改前后的对比（diff格式）
   - 报告修改的行数
   - 如果有错误，显示错误信息

## 输出规范

### 成功输出

```
## 格式化报告：{{file_path}}

**状态**：✅ 已完成

**修改统计**：
- 修改行数：12
- 修改类型：缩进调整、空行规范化、行长度调整

**示例修改**：
```diff
- def  my_function(x,y):
-     return x+y
+ def my_function(x, y):
+     return x + y
```

### 失败输出

```
## 格式化报告：{{file_path}}

**状态**：❌ 失败

**错误信息**：
[具体的错误描述]

**建议**：
[解决问题的建议]
```

### 取消输出

```
## 格式化报告：{{file_path}}

**状态**：⏹️ 已取消

**原因**：用户取消操作（文件有未提交修改）

**建议**：
如需继续，请：
1. 提交当前修改：git commit -am "保存进度"
2. 再次运行格式化命令
```
```

这个案例展示了：
- 触发条件明确界定了使用场景
- 执行步骤详细说明了处理流程
- 输出规范定义了各种情况下的输出格式

## 小结

Markdown正文的三个层次构成了Skill的行为蓝图：

**触发条件**：
- 解决"什么时候做"的问题
- 覆盖主要场景，明确边界
- 包含关键词提示

**执行步骤**：
- 解决"怎么做"的问题
- 原子化、可验证、可恢复
- 明确工具调用和条件判断

**输出规范**：
- 解决"做成什么样"的问题
- 定义格式、内容、长度要求
- 提供具体示例

三层次相互支撑，共同构成一个完整、可执行的Skill定义。掌握这种结构设计，是编写高质量Skill的关键。
