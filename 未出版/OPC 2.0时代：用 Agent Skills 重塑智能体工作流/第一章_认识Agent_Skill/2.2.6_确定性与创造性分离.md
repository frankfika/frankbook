---
section_id: "2.2.6"
title: "确定性与创造性分离原则"
status: draft
word_count: 2680
target_words: 2500
---

# 2.2.6 确定性与创造性分离原则

## 为什么要分离

在构建AI系统时，我们面临一个根本性的矛盾：AI擅长创造性任务，但在确定性任务上却不够可靠。这种不可靠性来源于大语言模型的本质特性——概率性输出。

想象一下这些场景：
- 你让AI计算100个数字的平均值，它可能偶尔会算错
- 你让AI解析一个JSON文件，它可能偶尔会把字段名拼错
- 你让AI统计代码行数，每次可能给出不同的结果

这些问题不是AI不够"聪明"，而是它的设计目标决定的。大语言模型被训练来生成"看起来像正确答案"的文本，而不是执行精确的算法计算。

**确定性与创造性分离原则**的核心思想是：
- **确定性任务**交给脚本和工具
- **创造性任务**交给AI
- 两者通过清晰的接口协作

## 确定性与创造性的边界

### 什么是确定性任务

确定性任务是指那些：
- 有明确的输入和输出
- 执行过程可精确复现
- 结果可以用算法验证
- 不需要判断或创意

**典型的确定性任务**：

```python
# 1. 数据解析
import json

def parse_json(content):
    """解析JSON字符串，返回结构化数据"""
    return json.loads(content)

# 2. 数值计算
def calculate_complexity(lines):
    """计算圈复杂度"""
    return sum(1 for line in lines if line.strip().startswith('if '))

# 3. 文件操作
def count_lines(file_path):
    """统计文件行数"""
    with open(file_path, 'r') as f:
        return len(f.readlines())

# 4. 格式转换
def convert_to_csv(data):
    """将数据转换为CSV格式"""
    import csv
    import io
    output = io.StringIO()
    writer = csv.writer(output)
    writer.writerows(data)
    return output.getvalue()
```

### 什么是创造性任务

创造性任务是指那些：
- 需要理解和判断
- 没有唯一正确的答案
- 涉及模式识别和推理
- 需要生成新内容

**典型的创造性任务**：

```markdown
**创造性任务示例**：

1. **代码审查中的判断**
   - "这段代码是否易于理解？"
   - "这个函数名是否符合语义？"
   - "这段逻辑是否有更优雅的实现方式？"

2. **文档生成**
   - "如何组织这篇技术文档的结构？"
   - "这个API的最佳描述方式是什么？"
   - "哪些信息对用户最重要？"

3. **问题诊断**
   - "根据错误日志，可能是什么原因导致的？"
   - "这个问题的影响范围有多大？"
   - "应该优先解决哪个问题？"

4. **设计决策**
   - "这个系统应该采用什么架构？"
   - "如何平衡性能和可维护性？"
   - "这个变更是否值得实施？"
```

### 边界模糊的任务

有些任务位于边界上，需要仔细分析：

| 任务 | 倾向 | 原因 |
|------|------|------|
| 代码格式化 | 确定性 | 有明确规则，可用工具实现 |
| 代码风格检查 | 混合 | 部分规则确定，部分需要判断 |
| 重构建议 | 创造性 | 需要理解意图和设计原则 |
| 复杂度分析 | 确定性 | 可用算法计算 |
| 代码可读性评估 | 创造性 | 需要主观判断 |
| 安全漏洞识别 | 混合 | 已知模式可确定，新漏洞需判断 |

## 实践原则

### 原则1：能脚本就不AI

如果一个问题可以用脚本可靠解决，就不要交给AI。

**反例**：让AI统计代码行数

```markdown
❌ 不好的做法：
## 执行步骤
1. 读取代码文件
2. 分析文件内容，统计行数
3. 返回结果
```

**正例**：用脚本统计

```markdown
✓ 好的做法：
## 执行步骤
1. **统计行数**
   ```bash
   wc -l {{file_path}}
   ```
   记录输出结果

2. **分析内容（AI）**
   基于行数统计结果，分析代码规模：
   - 少于100行：简单模块
   - 100-500行：中等模块
   - 超过500行：可能需要拆分
```

### 原则2：脚本做计算，AI做解读

脚本负责精确的数值计算，AI负责基于数值进行有意义的解读。

**案例：代码质量报告**

```python
# scripts/analyze_quality.py
import json
import sys
from radon.complexity import cc_visit
from radon.metrics import mi_visit

def analyze_file(file_path):
    """分析代码质量指标"""
    with open(file_path, 'r') as f:
        code = f.read()

    # 确定性计算：圈复杂度
    complexities = cc_visit(code)
    avg_complexity = sum(c.complexity for c in complexities) / len(complexities) if complexities else 0
    max_complexity = max((c.complexity for c in complexities), default=0)

    # 确定性计算：可维护性指数
    mi_score = mi_visit(code, True)

    # 确定性计算：代码行数
    lines = len(code.split('\n'))

    return {
        'file': file_path,
        'lines': lines,
        'avg_complexity': round(avg_complexity, 2),
        'max_complexity': max_complexity,
        'maintainability_index': round(mi_score, 2) if mi_score else None
    }

if __name__ == '__main__':
    result = analyze_file(sys.argv[1])
    print(json.dumps(result, indent=2))
```

SKILL.md中：

```markdown
## 执行步骤

1. **收集指标（脚本）**
   ```bash
   python scripts/analyze_quality.py {{file_path}}
   ```
   获取JSON格式的质量指标

2. **解读结果（AI）**
   基于收集的指标进行分析：
   - 如果max_complexity > 10：指出复杂度过高的函数
   - 如果maintainability_index < 65：说明可维护性问题
   - 结合代码行数评估整体质量

3. **生成建议（AI）**
   根据分析结果，提供针对性的改进建议
```

### 原则3：用脚本验证AI输出

当AI生成结构化输出时，用脚本验证其格式正确性。

**案例：JSON配置生成**

```markdown
## 执行步骤

1. **生成配置（AI）**
   基于用户需求，生成package.json配置

2. **验证格式（脚本）**
   ```bash
   python scripts/validate_json.py temp_config.json
   ```
   检查：
   - JSON格式是否有效
   - 必需字段是否存在
   - 版本号格式是否正确

3. **修正问题（AI）**
   如果验证失败，根据错误信息修正配置

4. **最终确认（脚本）**
   再次验证，直到通过
```

```python
# scripts/validate_json.py
import json
import sys

def validate_package_json(file_path):
    """验证package.json格式"""
    errors = []

    try:
        with open(file_path, 'r') as f:
            data = json.load(f)
    except json.JSONDecodeError as e:
        return {'valid': False, 'error': f'JSON解析错误: {e}'}

    # 检查必需字段
    required_fields = ['name', 'version']
    for field in required_fields:
        if field not in data:
            errors.append(f'缺少必需字段: {field}')

    # 检查版本号格式
    if 'version' in data:
        import re
        if not re.match(r'^\d+\.\d+\.\d+', data['version']):
            errors.append('版本号格式不正确，应为 x.y.z')

    return {
        'valid': len(errors) == 0,
        'errors': errors
    }

if __name__ == '__main__':
    result = validate_package_json(sys.argv[1])
    print(json.dumps(result, indent=2))
    sys.exit(0 if result['valid'] else 1)
```

### 原则4：明确的交接点

脚本和AI之间的交接应该有清晰的定义。

**不好的交接**：

```markdown
❌ 模糊的交接：
1. 运行脚本分析代码
2. AI根据分析结果生成报告
```

**好的交接**：

```markdown
✓ 清晰的交接：
1. **运行分析脚本**
   ```bash
   python scripts/analyze.py {{file_path}}
   ```
   输出JSON格式：
   ```json
   {
     "metrics": {
       "lines": 150,
       "complexity": 8.5,
       "issues": 3
     },
     "findings": [
       {"type": "complexity", "line": 45, "severity": "high"}
     ]
   }
   ```

2. **AI解读**
   输入：上述JSON数据
   任务：
   - 评估metrics.complexity的风险等级
   - 为每个finding提供解释和建议
   - 生成人类可读的报告
```

## 实际案例分析

### 案例1：代码审查Skill

**任务分解**：

```
代码审查
├── 确定性部分（脚本）
│   ├── 统计代码行数
│   ├── 计算圈复杂度
│   ├── 检测语法错误
│   ├── 检查导入语句
│   └── 搜索特定模式（如TODO、FIXME）
│
└── 创造性部分（AI）
    ├── 评估代码可读性
    ├── 判断设计合理性
    ├── 提出架构改进建议
    ├── 解释复杂逻辑
    └── 生成教育性建议
```

**实现**：

```markdown
## 执行步骤

1. **静态分析（脚本）**
   ```bash
   python scripts/complexity.py {{file_path}}
   python scripts/syntax_check.py {{file_path}}
   python scripts/find_patterns.py {{file_path}}
   ```

2. **结果整合（脚本）**
   ```bash
   python scripts/merge_results.py {{file_path}}
   ```
   生成统一格式的分析报告

3. **深度审查（AI）**
   读取分析报告的metrics部分，重点关注：
   - complexity > 10的函数
   - 存在语法错误的区域
   - 发现的TODO/FIXME项

4. **生成建议（AI）**
   基于：
   - 脚本提供的精确数据
   - 对代码逻辑的理解
   生成：
   - 优先级排序的问题列表
   - 具体的修复建议
   - 最佳实践指导

5. **格式化输出（脚本）**
   ```bash
   python scripts/format_report.py --template=markdown
   ```
```

### 案例2：周报生成Skill

**任务分解**：

```
周报生成
├── 确定性部分（脚本）
│   ├── 收集Git提交记录
│   ├── 统计代码变更量
│   ├── 提取任务完成状态
│   └── 格式化时间范围
│
└── 创造性部分（AI）
    ├── 识别重要工作项
    ├── 总结工作成果
    ├── 撰写进展描述
    └── 规划下周工作
```

**实现**：

```markdown
## 执行步骤

1. **数据收集（脚本）**
   ```bash
   # 获取本周提交
   git log --since="last monday" --pretty=format:"%h %s" > /tmp/commits.txt

   # 统计变更
   git diff --stat HEAD~7 HEAD > /tmp/changes.txt

   # 解析数据
   python scripts/parse_git_data.py /tmp/commits.txt /tmp/changes.txt
   ```

2. **数据结构化（脚本）**
   输出JSON：
   ```json
   {
     "period": "2024-01-15 to 2024-01-21",
     "commits": 12,
     "files_changed": 15,
     "lines_added": 450,
     "lines_removed": 120,
     "commit_messages": [...]
   }
   ```

3. **内容生成（AI）**
   基于结构化数据：
   - 识别commit中的关键主题
   - 总结主要工作内容
   - 评估任务完成度
   - 生成下周工作计划建议

4. **格式化（脚本）**
   ```bash
   python scripts/format_weekly.py --data=/tmp/report.json --template=company
   ```
```

### 案例3：API文档生成Skill

**任务分解**：

```
API文档生成
├── 确定性部分（脚本）
│   ├── 解析代码中的docstring
│   ├── 提取函数签名
│   ├── 识别参数类型
│   └── 收集路由信息
│
└── 创造性部分（AI）
    ├── 理解API的业务逻辑
    ├── 撰写使用示例
    ├── 解释复杂参数
    └── 组织文档结构
```

**实现**：

```python
# scripts/extract_api.py
import ast
import json
import sys
from pathlib import Path

def extract_functions(file_path):
    """提取文件中的函数定义"""
    with open(file_path, 'r') as f:
        tree = ast.parse(f.read())

    functions = []
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef):
            func_info = {
                'name': node.name,
                'docstring': ast.get_docstring(node),
                'args': [
                    {
                        'name': arg.arg,
                        'annotation': ast.unparse(arg.annotation) if arg.annotation else None
                    }
                    for arg in node.args.args
                ],
                'line': node.lineno
            }
            functions.append(func_info)

    return functions

if __name__ == '__main__':
    functions = extract_functions(sys.argv[1])
    print(json.dumps(functions, indent=2))
```

```markdown
## 执行步骤

1. **提取API信息（脚本）**
   ```bash
   python scripts/extract_api.py {{file_path}}
   ```

2. **读取上下文（AI）**
   读取提取的函数定义，理解：
   - 函数的用途
   - 参数的含义
   - 返回值的意义

3. **生成文档（AI）**
   基于函数签名和docstring，生成：
   - API描述
   - 参数说明
   - 返回值说明
   - 使用示例

4. **格式化输出（脚本）**
   ```bash
   python scripts/format_docs.py --format=markdown
   ```
```

## 常见误区

### 误区1：过度依赖AI

**问题**：让AI执行本可以脚本化的任务

```markdown
❌ 不好的做法：
## 执行步骤
1. 分析代码，找出所有的函数定义
2. 统计每个函数的参数数量
3. 列出所有返回类型

# 问题：这些都可以用AST解析脚本精确完成
```

**改进**：

```markdown
✓ 好的做法：
## 执行步骤
1. **提取函数信息（脚本）**
   ```bash
   python scripts/extract_functions.py {{file_path}}
   ```

2. **分析函数设计（AI）**
   基于脚本提取的函数列表，分析：
   - 函数职责是否单一
   - 参数设计是否合理
   - 命名是否清晰
```

### 误区2：脚本过于复杂

**问题**：脚本做了太多应该由AI完成的判断

```python
❌ 过于复杂的脚本：
def evaluate_code_quality(file_path):
    # 试图用规则判断代码质量
    score = 100
    if line_count > 100:
        score -= 10
    if complexity > 10:
        score -= 20
    if not has_comments:
        score -= 15
    # 这种评分过于机械
```

**改进**：

```python
✓ 简单的脚本：
def collect_metrics(file_path):
    # 只收集客观数据
    return {
        'line_count': count_lines(file_path),
        'complexity': calculate_complexity(file_path),
        'comment_ratio': calculate_comment_ratio(file_path)
    }
    # 让AI基于这些数据做质量评估
```

### 误区3：交接不清晰

**问题**：脚本输出和AI输入之间没有明确契约

```markdown
❌ 模糊的契约：
1. 运行分析脚本
2. AI分析报告并生成建议

# 问题：AI不知道脚本会输出什么格式
```

**改进**：

```markdown
✓ 明确的契约：
1. **运行分析脚本**
   ```bash
   python scripts/analyze.py {{file_path}}
   ```
   **输出格式**（JSON）：
   ```json
   {
     "file": "string",
     "metrics": {
       "lines": "number",
       "complexity": "number"
     },
     "issues": [
       {"type": "string", "line": "number", "message": "string"}
     ]
   }
   ```

2. **AI分析**
   输入：上述JSON结构
   处理：...
```

## 技术实现建议

### 脚本编写规范

1. **输入输出明确**
   - 使用标准输入/输出或文件
   - 支持JSON格式便于解析
   - 提供清晰的错误信息

2. **单一职责**
   - 每个脚本只做一件事
   - 便于测试和复用
   - 易于并行执行

3. **错误处理**
   - 返回非零退出码表示失败
   - 错误信息输出到stderr
   - 提供详细的错误上下文

```python
# 好的脚本模板
#!/usr/bin/env python3
import json
import sys

def main(input_path):
    try:
        result = process(input_path)
        print(json.dumps(result, indent=2))
        return 0
    except FileNotFoundError as e:
        print(f"Error: File not found - {e}", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 2

if __name__ == '__main__':
    sys.exit(main(sys.argv[1]))
```

### AI与脚本的协作模式

1. **顺序执行**：脚本 → AI → 脚本
2. **并行执行**：多个脚本同时运行，AI整合结果
3. **迭代执行**：脚本 → AI → 脚本（修正）→ AI（再评估）
4. **条件执行**：根据脚本输出决定AI的任务分支

## 小结

确定性与创造性分离原则是构建可靠AI系统的核心思想：

**为什么要分离**：
- AI擅长判断和创造，不擅长精确计算
- 脚本擅长确定性的计算和处理
- 分离可以发挥各自优势，提高系统可靠性

**分离的边界**：
- 确定性任务：可精确复现的计算和操作
- 创造性任务：需要理解和判断的工作
- 边界任务：根据可靠性要求决定分工

**实践原则**：
- 能脚本就不AI
- 脚本做计算，AI做解读
- 用脚本验证AI输出
- 明确的交接点定义

掌握这个原则，可以显著提升Skill的可靠性和实用性，避免AI"一本正经地胡说八道"的问题。
